{"ast":null,"code":"import { Material } from 'three';\nimport { getNodeChildren, getCacheKey } from '../core/NodeUtils.js';\nimport { attribute } from '../core/AttributeNode.js';\nimport { output, diffuseColor, varyingProperty } from '../core/PropertyNode.js';\nimport { materialAlphaTest, materialColor, materialOpacity, materialEmissive, materialNormal } from '../accessors/MaterialNode.js';\nimport { modelViewProjection } from '../accessors/ModelViewProjectionNode.js';\nimport { transformedNormalView, normalLocal } from '../accessors/NormalNode.js';\nimport { instance } from '../accessors/InstanceNode.js';\nimport { batch } from '../accessors/BatchNode.js';\nimport { materialReference } from '../accessors/MaterialReferenceNode.js';\nimport { positionLocal, positionView } from '../accessors/PositionNode.js';\nimport { skinningReference } from '../accessors/SkinningNode.js';\nimport { morphReference } from '../accessors/MorphNode.js';\nimport { texture } from '../accessors/TextureNode.js';\nimport { cubeTexture } from '../accessors/CubeTextureNode.js';\nimport { lightsNode } from '../lighting/LightsNode.js';\nimport { mix } from '../math/MathNode.js';\nimport { float, vec3, vec4 } from '../shadernode/ShaderNode.js';\nimport AONode from '../lighting/AONode.js';\nimport { lightingContext } from '../lighting/LightingContextNode.js';\nimport EnvironmentNode from '../lighting/EnvironmentNode.js';\nimport IrradianceNode from '../lighting/IrradianceNode.js';\nimport { depthPixel } from '../display/ViewportDepthNode.js';\nimport { cameraLogDepth } from '../accessors/CameraNode.js';\nimport { clipping, clippingAlpha } from '../accessors/ClippingNode.js';\nimport { faceDirection } from '../display/FrontFacingNode.js';\nconst NodeMaterials = new Map();\nclass NodeMaterial extends Material {\n  constructor() {\n    super();\n    this.isNodeMaterial = true;\n    this.type = this.constructor.type;\n    this.forceSinglePass = false;\n    this.fog = true;\n    this.lights = true;\n    this.normals = true;\n    this.lightsNode = null;\n    this.envNode = null;\n    this.aoNode = null;\n    this.colorNode = null;\n    this.normalNode = null;\n    this.opacityNode = null;\n    this.backdropNode = null;\n    this.backdropAlphaNode = null;\n    this.alphaTestNode = null;\n    this.positionNode = null;\n    this.depthNode = null;\n    this.shadowNode = null;\n    this.shadowPositionNode = null;\n    this.outputNode = null;\n    this.fragmentNode = null;\n    this.vertexNode = null;\n  }\n  customProgramCacheKey() {\n    return this.type + getCacheKey(this);\n  }\n  build(builder) {\n    this.setup(builder);\n  }\n  setup(builder) {\n    // < VERTEX STAGE >\n\n    builder.addStack();\n    builder.stack.outputNode = this.vertexNode || this.setupPosition(builder);\n    builder.addFlow('vertex', builder.removeStack());\n\n    // < FRAGMENT STAGE >\n\n    builder.addStack();\n    let resultNode;\n    const clippingNode = this.setupClipping(builder);\n    if (this.depthWrite === true) this.setupDepth(builder);\n    if (this.fragmentNode === null) {\n      if (this.normals === true) this.setupNormal(builder);\n      this.setupDiffuseColor(builder);\n      this.setupVariants(builder);\n      const outgoingLightNode = this.setupLighting(builder);\n      if (clippingNode !== null) builder.stack.add(clippingNode);\n\n      // force unsigned floats - useful for RenderTargets\n\n      const basicOutput = vec4(outgoingLightNode, diffuseColor.a).max(0);\n      resultNode = this.setupOutput(builder, basicOutput);\n\n      // OUTPUT NODE\n\n      output.assign(resultNode);\n\n      //\n\n      if (this.outputNode !== null) resultNode = this.outputNode;\n    } else {\n      let fragmentNode = this.fragmentNode;\n      if (fragmentNode.isOutputStructNode !== true) {\n        fragmentNode = vec4(fragmentNode);\n      }\n      resultNode = this.setupOutput(builder, fragmentNode);\n    }\n    builder.stack.outputNode = resultNode;\n    builder.addFlow('fragment', builder.removeStack());\n  }\n  setupClipping(builder) {\n    if (builder.clippingContext === null) return null;\n    const {\n      globalClippingCount,\n      localClippingCount\n    } = builder.clippingContext;\n    let result = null;\n    if (globalClippingCount || localClippingCount) {\n      if (this.alphaToCoverage) {\n        // to be added to flow when the color/alpha value has been determined\n        result = clippingAlpha();\n      } else {\n        builder.stack.add(clipping());\n      }\n    }\n    return result;\n  }\n  setupDepth(builder) {\n    const {\n      renderer\n    } = builder;\n\n    // Depth\n\n    let depthNode = this.depthNode;\n    if (depthNode === null && renderer.logarithmicDepthBuffer === true) {\n      const fragDepth = modelViewProjection().w.add(1);\n      depthNode = fragDepth.log2().mul(cameraLogDepth).mul(0.5);\n    }\n    if (depthNode !== null) {\n      depthPixel.assign(depthNode).append();\n    }\n  }\n  setupPosition(builder) {\n    const {\n      object\n    } = builder;\n    const geometry = object.geometry;\n    builder.addStack();\n\n    // Vertex\n\n    if (geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color) {\n      morphReference(object).append();\n    }\n    if (object.isSkinnedMesh === true) {\n      skinningReference(object).append();\n    }\n    if (this.displacementMap) {\n      const displacementMap = materialReference('displacementMap', 'texture');\n      const displacementScale = materialReference('displacementScale', 'float');\n      const displacementBias = materialReference('displacementBias', 'float');\n      positionLocal.addAssign(normalLocal.normalize().mul(displacementMap.x.mul(displacementScale).add(displacementBias)));\n    }\n    if (object.isBatchedMesh) {\n      batch(object).append();\n    }\n    if (object.instanceMatrix && object.instanceMatrix.isInstancedBufferAttribute === true && builder.isAvailable('instance') === true) {\n      instance(object).append();\n    }\n    if (this.positionNode !== null) {\n      positionLocal.assign(this.positionNode);\n    }\n    const mvp = modelViewProjection();\n    builder.context.vertex = builder.removeStack();\n    builder.context.mvp = mvp;\n    return mvp;\n  }\n  setupDiffuseColor({\n    object,\n    geometry\n  }) {\n    let colorNode = this.colorNode ? vec4(this.colorNode) : materialColor;\n\n    // VERTEX COLORS\n\n    if (this.vertexColors === true && geometry.hasAttribute('color')) {\n      colorNode = vec4(colorNode.xyz.mul(attribute('color', 'vec3')), colorNode.a);\n    }\n\n    // Instanced colors\n\n    if (object.instanceColor) {\n      const instanceColor = varyingProperty('vec3', 'vInstanceColor');\n      colorNode = instanceColor.mul(colorNode);\n    }\n\n    // COLOR\n\n    diffuseColor.assign(colorNode);\n\n    // OPACITY\n\n    const opacityNode = this.opacityNode ? float(this.opacityNode) : materialOpacity;\n    diffuseColor.a.assign(diffuseColor.a.mul(opacityNode));\n\n    // ALPHA TEST\n\n    if (this.alphaTestNode !== null || this.alphaTest > 0) {\n      const alphaTestNode = this.alphaTestNode !== null ? float(this.alphaTestNode) : materialAlphaTest;\n      diffuseColor.a.lessThanEqual(alphaTestNode).discard();\n    }\n  }\n  setupVariants( /*builder*/\n  ) {\n\n    // Interface function.\n  }\n  setupNormal() {\n    // NORMAL VIEW\n\n    if (this.flatShading === true) {\n      const normalNode = positionView.dFdx().cross(positionView.dFdy()).normalize();\n      transformedNormalView.assign(normalNode.mul(faceDirection));\n    } else {\n      const normalNode = this.normalNode ? vec3(this.normalNode) : materialNormal;\n      transformedNormalView.assign(normalNode.mul(faceDirection));\n    }\n  }\n  getEnvNode(builder) {\n    let node = null;\n    if (this.envNode) {\n      node = this.envNode;\n    } else if (this.envMap) {\n      node = this.envMap.isCubeTexture ? cubeTexture(this.envMap) : texture(this.envMap);\n    } else if (builder.environmentNode) {\n      node = builder.environmentNode;\n    }\n    return node;\n  }\n  setupLights(builder) {\n    const envNode = this.getEnvNode(builder);\n\n    //\n\n    const materialLightsNode = [];\n    if (envNode) {\n      materialLightsNode.push(new EnvironmentNode(envNode));\n    }\n    if (builder.material.lightMap) {\n      materialLightsNode.push(new IrradianceNode(materialReference('lightMap', 'texture')));\n    }\n    if (this.aoNode !== null || builder.material.aoMap) {\n      const aoNode = this.aoNode !== null ? this.aoNode : texture(builder.material.aoMap);\n      materialLightsNode.push(new AONode(aoNode));\n    }\n    let lightsN = this.lightsNode || builder.lightsNode;\n    if (materialLightsNode.length > 0) {\n      lightsN = lightsNode([...lightsN.lightNodes, ...materialLightsNode]);\n    }\n    return lightsN;\n  }\n  setupLightingModel( /*builder*/\n  ) {\n\n    // Interface function.\n  }\n  setupLighting(builder) {\n    const {\n      material\n    } = builder;\n    const {\n      backdropNode,\n      backdropAlphaNode,\n      emissiveNode\n    } = this;\n\n    // OUTGOING LIGHT\n\n    const lights = this.lights === true || this.lightsNode !== null;\n    const lightsNode = lights ? this.setupLights(builder) : null;\n    let outgoingLightNode = diffuseColor.rgb;\n    if (lightsNode && lightsNode.hasLight !== false) {\n      const lightingModel = this.setupLightingModel(builder);\n      outgoingLightNode = lightingContext(lightsNode, lightingModel, backdropNode, backdropAlphaNode);\n    } else if (backdropNode !== null) {\n      outgoingLightNode = vec3(backdropAlphaNode !== null ? mix(outgoingLightNode, backdropNode, backdropAlphaNode) : backdropNode);\n    }\n\n    // EMISSIVE\n\n    if (emissiveNode && emissiveNode.isNode === true || material.emissive && material.emissive.isColor === true) {\n      outgoingLightNode = outgoingLightNode.add(vec3(emissiveNode ? emissiveNode : materialEmissive));\n    }\n    return outgoingLightNode;\n  }\n  setupOutput(builder, outputNode) {\n    // FOG\n\n    const fogNode = builder.fogNode;\n    if (fogNode) outputNode = vec4(fogNode.mix(outputNode.rgb, fogNode.colorNode), outputNode.a);\n    return outputNode;\n  }\n  setDefaultValues(material) {\n    // This approach is to reuse the native refreshUniforms*\n    // and turn available the use of features like transmission and environment in core\n\n    for (const property in material) {\n      const value = material[property];\n      if (this[property] === undefined) {\n        this[property] = value;\n        if (value && value.clone) this[property] = value.clone();\n      }\n    }\n    const descriptors = Object.getOwnPropertyDescriptors(material.constructor.prototype);\n    for (const key in descriptors) {\n      if (Object.getOwnPropertyDescriptor(this.constructor.prototype, key) === undefined && descriptors[key].get !== undefined) {\n        Object.defineProperty(this.constructor.prototype, key, descriptors[key]);\n      }\n    }\n  }\n  toJSON(meta) {\n    const isRoot = meta === undefined || typeof meta === 'string';\n    if (isRoot) {\n      meta = {\n        textures: {},\n        images: {},\n        nodes: {}\n      };\n    }\n    const data = Material.prototype.toJSON.call(this, meta);\n    const nodeChildren = getNodeChildren(this);\n    data.inputNodes = {};\n    for (const {\n      property,\n      childNode\n    } of nodeChildren) {\n      data.inputNodes[property] = childNode.toJSON(meta).uuid;\n    }\n\n    // TODO: Copied from Object3D.toJSON\n\n    function extractFromCache(cache) {\n      const values = [];\n      for (const key in cache) {\n        const data = cache[key];\n        delete data.metadata;\n        values.push(data);\n      }\n      return values;\n    }\n    if (isRoot) {\n      const textures = extractFromCache(meta.textures);\n      const images = extractFromCache(meta.images);\n      const nodes = extractFromCache(meta.nodes);\n      if (textures.length > 0) data.textures = textures;\n      if (images.length > 0) data.images = images;\n      if (nodes.length > 0) data.nodes = nodes;\n    }\n    return data;\n  }\n  copy(source) {\n    this.lightsNode = source.lightsNode;\n    this.envNode = source.envNode;\n    this.colorNode = source.colorNode;\n    this.normalNode = source.normalNode;\n    this.opacityNode = source.opacityNode;\n    this.backdropNode = source.backdropNode;\n    this.backdropAlphaNode = source.backdropAlphaNode;\n    this.alphaTestNode = source.alphaTestNode;\n    this.positionNode = source.positionNode;\n    this.depthNode = source.depthNode;\n    this.shadowNode = source.shadowNode;\n    this.shadowPositionNode = source.shadowPositionNode;\n    this.outputNode = source.outputNode;\n    this.fragmentNode = source.fragmentNode;\n    this.vertexNode = source.vertexNode;\n    return super.copy(source);\n  }\n  static fromMaterial(material) {\n    if (material.isNodeMaterial === true) {\n      // is already a node material\n\n      return material;\n    }\n    const type = material.type.replace('Material', 'NodeMaterial');\n    const nodeMaterial = createNodeMaterialFromType(type);\n    if (nodeMaterial === undefined) {\n      throw new Error(`NodeMaterial: Material \"${material.type}\" is not compatible.`);\n    }\n    for (const key in material) {\n      nodeMaterial[key] = material[key];\n    }\n    return nodeMaterial;\n  }\n}\nexport default NodeMaterial;\nexport function addNodeMaterial(type, nodeMaterial) {\n  if (typeof nodeMaterial !== 'function' || !type) throw new Error(`Node material ${type} is not a class`);\n  if (NodeMaterials.has(type)) {\n    console.warn(`Redefinition of node material ${type}`);\n    return;\n  }\n  NodeMaterials.set(type, nodeMaterial);\n  nodeMaterial.type = type;\n}\nexport function createNodeMaterialFromType(type) {\n  const Material = NodeMaterials.get(type);\n  if (Material !== undefined) {\n    return new Material();\n  }\n}\naddNodeMaterial('NodeMaterial', NodeMaterial);","map":{"version":3,"names":["Material","getNodeChildren","getCacheKey","attribute","output","diffuseColor","varyingProperty","materialAlphaTest","materialColor","materialOpacity","materialEmissive","materialNormal","modelViewProjection","transformedNormalView","normalLocal","instance","batch","materialReference","positionLocal","positionView","skinningReference","morphReference","texture","cubeTexture","lightsNode","mix","float","vec3","vec4","AONode","lightingContext","EnvironmentNode","IrradianceNode","depthPixel","cameraLogDepth","clipping","clippingAlpha","faceDirection","NodeMaterials","Map","NodeMaterial","constructor","isNodeMaterial","type","forceSinglePass","fog","lights","normals","envNode","aoNode","colorNode","normalNode","opacityNode","backdropNode","backdropAlphaNode","alphaTestNode","positionNode","depthNode","shadowNode","shadowPositionNode","outputNode","fragmentNode","vertexNode","customProgramCacheKey","build","builder","setup","addStack","stack","setupPosition","addFlow","removeStack","resultNode","clippingNode","setupClipping","depthWrite","setupDepth","setupNormal","setupDiffuseColor","setupVariants","outgoingLightNode","setupLighting","add","basicOutput","a","max","setupOutput","assign","isOutputStructNode","clippingContext","globalClippingCount","localClippingCount","result","alphaToCoverage","renderer","logarithmicDepthBuffer","fragDepth","w","log2","mul","append","object","geometry","morphAttributes","position","normal","color","isSkinnedMesh","displacementMap","displacementScale","displacementBias","addAssign","normalize","x","isBatchedMesh","instanceMatrix","isInstancedBufferAttribute","isAvailable","mvp","context","vertex","vertexColors","hasAttribute","xyz","instanceColor","alphaTest","lessThanEqual","discard","flatShading","dFdx","cross","dFdy","getEnvNode","node","envMap","isCubeTexture","environmentNode","setupLights","materialLightsNode","push","material","lightMap","aoMap","lightsN","length","lightNodes","setupLightingModel","emissiveNode","rgb","hasLight","lightingModel","isNode","emissive","isColor","fogNode","setDefaultValues","property","value","undefined","clone","descriptors","Object","getOwnPropertyDescriptors","prototype","key","getOwnPropertyDescriptor","get","defineProperty","toJSON","meta","isRoot","textures","images","nodes","data","call","nodeChildren","inputNodes","childNode","uuid","extractFromCache","cache","values","metadata","copy","source","fromMaterial","replace","nodeMaterial","createNodeMaterialFromType","Error","addNodeMaterial","has","console","warn","set"],"sources":["D:/dumps/online-learning-platform-main/Frontend/node_modules/three/examples/jsm/nodes/materials/NodeMaterial.js"],"sourcesContent":["import { Material } from 'three';\nimport { getNodeChildren, getCacheKey } from '../core/NodeUtils.js';\nimport { attribute } from '../core/AttributeNode.js';\nimport { output, diffuseColor, varyingProperty } from '../core/PropertyNode.js';\nimport { materialAlphaTest, materialColor, materialOpacity, materialEmissive, materialNormal } from '../accessors/MaterialNode.js';\nimport { modelViewProjection } from '../accessors/ModelViewProjectionNode.js';\nimport { transformedNormalView, normalLocal } from '../accessors/NormalNode.js';\nimport { instance } from '../accessors/InstanceNode.js';\nimport { batch } from '../accessors/BatchNode.js';\nimport { materialReference } from '../accessors/MaterialReferenceNode.js';\nimport { positionLocal, positionView } from '../accessors/PositionNode.js';\nimport { skinningReference } from '../accessors/SkinningNode.js';\nimport { morphReference } from '../accessors/MorphNode.js';\nimport { texture } from '../accessors/TextureNode.js';\nimport { cubeTexture } from '../accessors/CubeTextureNode.js';\nimport { lightsNode } from '../lighting/LightsNode.js';\nimport { mix } from '../math/MathNode.js';\nimport { float, vec3, vec4 } from '../shadernode/ShaderNode.js';\nimport AONode from '../lighting/AONode.js';\nimport { lightingContext } from '../lighting/LightingContextNode.js';\nimport EnvironmentNode from '../lighting/EnvironmentNode.js';\nimport IrradianceNode from '../lighting/IrradianceNode.js';\nimport { depthPixel } from '../display/ViewportDepthNode.js';\nimport { cameraLogDepth } from '../accessors/CameraNode.js';\nimport { clipping, clippingAlpha } from '../accessors/ClippingNode.js';\nimport { faceDirection } from '../display/FrontFacingNode.js';\n\nconst NodeMaterials = new Map();\n\nclass NodeMaterial extends Material {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isNodeMaterial = true;\n\n\t\tthis.type = this.constructor.type;\n\n\t\tthis.forceSinglePass = false;\n\n\t\tthis.fog = true;\n\t\tthis.lights = true;\n\t\tthis.normals = true;\n\n\t\tthis.lightsNode = null;\n\t\tthis.envNode = null;\n\t\tthis.aoNode = null;\n\n\t\tthis.colorNode = null;\n\t\tthis.normalNode = null;\n\t\tthis.opacityNode = null;\n\t\tthis.backdropNode = null;\n\t\tthis.backdropAlphaNode = null;\n\t\tthis.alphaTestNode = null;\n\n\t\tthis.positionNode = null;\n\n\t\tthis.depthNode = null;\n\t\tthis.shadowNode = null;\n\t\tthis.shadowPositionNode = null;\n\n\t\tthis.outputNode = null;\n\n\t\tthis.fragmentNode = null;\n\t\tthis.vertexNode = null;\n\n\t}\n\n\tcustomProgramCacheKey() {\n\n\t\treturn this.type + getCacheKey( this );\n\n\t}\n\n\tbuild( builder ) {\n\n\t\tthis.setup( builder );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\t// < VERTEX STAGE >\n\n\t\tbuilder.addStack();\n\n\t\tbuilder.stack.outputNode = this.vertexNode || this.setupPosition( builder );\n\n\t\tbuilder.addFlow( 'vertex', builder.removeStack() );\n\n\t\t// < FRAGMENT STAGE >\n\n\t\tbuilder.addStack();\n\n\t\tlet resultNode;\n\n\t\tconst clippingNode = this.setupClipping( builder );\n\n\t\tif ( this.depthWrite === true ) this.setupDepth( builder );\n\n\t\tif ( this.fragmentNode === null ) {\n\n\t\t\tif ( this.normals === true ) this.setupNormal( builder );\n\n\t\t\tthis.setupDiffuseColor( builder );\n\t\t\tthis.setupVariants( builder );\n\n\t\t\tconst outgoingLightNode = this.setupLighting( builder );\n\n\t\t\tif ( clippingNode !== null ) builder.stack.add( clippingNode );\n\n\t\t\t// force unsigned floats - useful for RenderTargets\n\n\t\t\tconst basicOutput = vec4( outgoingLightNode, diffuseColor.a ).max( 0 );\n\n\t\t\tresultNode = this.setupOutput( builder, basicOutput );\n\n\t\t\t// OUTPUT NODE\n\n\t\t\toutput.assign( resultNode );\n\n\t\t\t//\n\n\t\t\tif ( this.outputNode !== null ) resultNode = this.outputNode;\n\n\t\t} else {\n\n\t\t\tlet fragmentNode = this.fragmentNode;\n\n\t\t\tif ( fragmentNode.isOutputStructNode !== true ) {\n\n\t\t\t\tfragmentNode = vec4( fragmentNode );\n\n\t\t\t}\n\n\t\t\tresultNode = this.setupOutput( builder, fragmentNode );\n\n\t\t}\n\n\t\tbuilder.stack.outputNode = resultNode;\n\n\t\tbuilder.addFlow( 'fragment', builder.removeStack() );\n\n\t}\n\n\tsetupClipping( builder ) {\n\n\t\tif ( builder.clippingContext === null ) return null;\n\n\t\tconst { globalClippingCount, localClippingCount } = builder.clippingContext;\n\n\t\tlet result = null;\n\n\t\tif ( globalClippingCount || localClippingCount ) {\n\n\t\t\tif ( this.alphaToCoverage ) {\n\n\t\t\t\t// to be added to flow when the color/alpha value has been determined\n\t\t\t\tresult = clippingAlpha();\n\n\t\t\t} else {\n\n\t\t\t\tbuilder.stack.add( clipping() );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tsetupDepth( builder ) {\n\n\t\tconst { renderer } = builder;\n\n\t\t// Depth\n\n\t\tlet depthNode = this.depthNode;\n\n\t\tif ( depthNode === null && renderer.logarithmicDepthBuffer === true ) {\n\n\t\t\tconst fragDepth = modelViewProjection().w.add( 1 );\n\n\t\t\tdepthNode = fragDepth.log2().mul( cameraLogDepth ).mul( 0.5 );\n\n\t\t}\n\n\t\tif ( depthNode !== null ) {\n\n\t\t\tdepthPixel.assign( depthNode ).append();\n\n\t\t}\n\n\t}\n\n\tsetupPosition( builder ) {\n\n\t\tconst { object } = builder;\n\t\tconst geometry = object.geometry;\n\n\t\tbuilder.addStack();\n\n\t\t// Vertex\n\n\t\tif ( geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color ) {\n\n\t\t\tmorphReference( object ).append();\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh === true ) {\n\n\t\t\tskinningReference( object ).append();\n\n\t\t}\n\n\t\tif ( this.displacementMap ) {\n\n\t\t\tconst displacementMap = materialReference( 'displacementMap', 'texture' );\n\t\t\tconst displacementScale = materialReference( 'displacementScale', 'float' );\n\t\t\tconst displacementBias = materialReference( 'displacementBias', 'float' );\n\n\t\t\tpositionLocal.addAssign( normalLocal.normalize().mul( ( displacementMap.x.mul( displacementScale ).add( displacementBias ) ) ) );\n\n\t\t}\n\n\t\tif ( object.isBatchedMesh ) {\n\n\t\t\tbatch( object ).append();\n\n\t\t}\n\n\t\tif ( ( object.instanceMatrix && object.instanceMatrix.isInstancedBufferAttribute === true ) && builder.isAvailable( 'instance' ) === true ) {\n\n\t\t\tinstance( object ).append();\n\n\t\t}\n\n\t\tif ( this.positionNode !== null ) {\n\n\t\t\tpositionLocal.assign( this.positionNode );\n\n\t\t}\n\n\t\tconst mvp = modelViewProjection();\n\n\t\tbuilder.context.vertex = builder.removeStack();\n\t\tbuilder.context.mvp = mvp;\n\n\t\treturn mvp;\n\n\t}\n\n\tsetupDiffuseColor( { object, geometry } ) {\n\n\t\tlet colorNode = this.colorNode ? vec4( this.colorNode ) : materialColor;\n\n\t\t// VERTEX COLORS\n\n\t\tif ( this.vertexColors === true && geometry.hasAttribute( 'color' ) ) {\n\n\t\t\tcolorNode = vec4( colorNode.xyz.mul( attribute( 'color', 'vec3' ) ), colorNode.a );\n\n\t\t}\n\n\t\t// Instanced colors\n\n\t\tif ( object.instanceColor ) {\n\n\t\t\tconst instanceColor = varyingProperty( 'vec3', 'vInstanceColor' );\n\n\t\t\tcolorNode = instanceColor.mul( colorNode );\n\n\t\t}\n\n\t\t// COLOR\n\n\t\tdiffuseColor.assign( colorNode );\n\n\t\t// OPACITY\n\n\t\tconst opacityNode = this.opacityNode ? float( this.opacityNode ) : materialOpacity;\n\t\tdiffuseColor.a.assign( diffuseColor.a.mul( opacityNode ) );\n\n\t\t// ALPHA TEST\n\n\t\tif ( this.alphaTestNode !== null || this.alphaTest > 0 ) {\n\n\t\t\tconst alphaTestNode = this.alphaTestNode !== null ? float( this.alphaTestNode ) : materialAlphaTest;\n\n\t\t\tdiffuseColor.a.lessThanEqual( alphaTestNode ).discard();\n\n\t\t}\n\n\t}\n\n\tsetupVariants( /*builder*/ ) {\n\n\t\t// Interface function.\n\n\t}\n\n\tsetupNormal() {\n\n\t\t// NORMAL VIEW\n\n\t\tif ( this.flatShading === true ) {\n\n\t\t\tconst normalNode = positionView.dFdx().cross( positionView.dFdy() ).normalize();\n\n\t\t\ttransformedNormalView.assign( normalNode.mul( faceDirection ) );\n\n\t\t} else {\n\n\t\t\tconst normalNode = this.normalNode ? vec3( this.normalNode ) : materialNormal;\n\n\t\t\ttransformedNormalView.assign( normalNode.mul( faceDirection ) );\n\n\t\t}\n\n\t}\n\n\tgetEnvNode( builder ) {\n\n\t\tlet node = null;\n\n\t\tif ( this.envNode ) {\n\n\t\t\tnode = this.envNode;\n\n\t\t} else if ( this.envMap ) {\n\n\t\t\tnode = this.envMap.isCubeTexture ? cubeTexture( this.envMap ) : texture( this.envMap );\n\n\t\t} else if ( builder.environmentNode ) {\n\n\t\t\tnode = builder.environmentNode;\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\tsetupLights( builder ) {\n\n\t\tconst envNode = this.getEnvNode( builder );\n\n\t\t//\n\n\t\tconst materialLightsNode = [];\n\n\t\tif ( envNode ) {\n\n\t\t\tmaterialLightsNode.push( new EnvironmentNode( envNode ) );\n\n\t\t}\n\n\t\tif ( builder.material.lightMap ) {\n\n\t\t\tmaterialLightsNode.push( new IrradianceNode( materialReference( 'lightMap', 'texture' ) ) );\n\n\t\t}\n\n\t\tif ( this.aoNode !== null || builder.material.aoMap ) {\n\n\t\t\tconst aoNode = this.aoNode !== null ? this.aoNode : texture( builder.material.aoMap );\n\n\t\t\tmaterialLightsNode.push( new AONode( aoNode ) );\n\n\t\t}\n\n\t\tlet lightsN = this.lightsNode || builder.lightsNode;\n\n\t\tif ( materialLightsNode.length > 0 ) {\n\n\t\t\tlightsN = lightsNode( [ ...lightsN.lightNodes, ...materialLightsNode ] );\n\n\t\t}\n\n\t\treturn lightsN;\n\n\t}\n\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\t// Interface function.\n\n\t}\n\n\tsetupLighting( builder ) {\n\n\t\tconst { material } = builder;\n\t\tconst { backdropNode, backdropAlphaNode, emissiveNode } = this;\n\n\t\t// OUTGOING LIGHT\n\n\t\tconst lights = this.lights === true || this.lightsNode !== null;\n\n\t\tconst lightsNode = lights ? this.setupLights( builder ) : null;\n\n\t\tlet outgoingLightNode = diffuseColor.rgb;\n\n\t\tif ( lightsNode && lightsNode.hasLight !== false ) {\n\n\t\t\tconst lightingModel = this.setupLightingModel( builder );\n\n\t\t\toutgoingLightNode = lightingContext( lightsNode, lightingModel, backdropNode, backdropAlphaNode );\n\n\t\t} else if ( backdropNode !== null ) {\n\n\t\t\toutgoingLightNode = vec3( backdropAlphaNode !== null ? mix( outgoingLightNode, backdropNode, backdropAlphaNode ) : backdropNode );\n\n\t\t}\n\n\t\t// EMISSIVE\n\n\t\tif ( ( emissiveNode && emissiveNode.isNode === true ) || ( material.emissive && material.emissive.isColor === true ) ) {\n\n\t\t\toutgoingLightNode = outgoingLightNode.add( vec3( emissiveNode ? emissiveNode : materialEmissive ) );\n\n\t\t}\n\n\t\treturn outgoingLightNode;\n\n\t}\n\n\tsetupOutput( builder, outputNode ) {\n\n\t\t// FOG\n\n\t\tconst fogNode = builder.fogNode;\n\n\t\tif ( fogNode ) outputNode = vec4( fogNode.mix( outputNode.rgb, fogNode.colorNode ), outputNode.a );\n\n\t\treturn outputNode;\n\n\t}\n\n\tsetDefaultValues( material ) {\n\n\t\t// This approach is to reuse the native refreshUniforms*\n\t\t// and turn available the use of features like transmission and environment in core\n\n\t\tfor ( const property in material ) {\n\n\t\t\tconst value = material[ property ];\n\n\t\t\tif ( this[ property ] === undefined ) {\n\n\t\t\t\tthis[ property ] = value;\n\n\t\t\t\tif ( value && value.clone ) this[ property ] = value.clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst descriptors = Object.getOwnPropertyDescriptors( material.constructor.prototype );\n\n\t\tfor ( const key in descriptors ) {\n\n\t\t\tif ( Object.getOwnPropertyDescriptor( this.constructor.prototype, key ) === undefined &&\n\t\t\t     descriptors[ key ].get !== undefined ) {\n\n\t\t\t\tObject.defineProperty( this.constructor.prototype, key, descriptors[ key ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst isRoot = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( isRoot ) {\n\n\t\t\tmeta = {\n\t\t\t\ttextures: {},\n\t\t\t\timages: {},\n\t\t\t\tnodes: {}\n\t\t\t};\n\n\t\t}\n\n\t\tconst data = Material.prototype.toJSON.call( this, meta );\n\t\tconst nodeChildren = getNodeChildren( this );\n\n\t\tdata.inputNodes = {};\n\n\t\tfor ( const { property, childNode } of nodeChildren ) {\n\n\t\t\tdata.inputNodes[ property ] = childNode.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\t// TODO: Copied from Object3D.toJSON\n\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tconst values = [];\n\n\t\t\tfor ( const key in cache ) {\n\n\t\t\t\tconst data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t\tif ( isRoot ) {\n\n\t\t\tconst textures = extractFromCache( meta.textures );\n\t\t\tconst images = extractFromCache( meta.images );\n\t\t\tconst nodes = extractFromCache( meta.nodes );\n\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\tif ( images.length > 0 ) data.images = images;\n\t\t\tif ( nodes.length > 0 ) data.nodes = nodes;\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.lightsNode = source.lightsNode;\n\t\tthis.envNode = source.envNode;\n\n\t\tthis.colorNode = source.colorNode;\n\t\tthis.normalNode = source.normalNode;\n\t\tthis.opacityNode = source.opacityNode;\n\t\tthis.backdropNode = source.backdropNode;\n\t\tthis.backdropAlphaNode = source.backdropAlphaNode;\n\t\tthis.alphaTestNode = source.alphaTestNode;\n\n\t\tthis.positionNode = source.positionNode;\n\n\t\tthis.depthNode = source.depthNode;\n\t\tthis.shadowNode = source.shadowNode;\n\t\tthis.shadowPositionNode = source.shadowPositionNode;\n\n\t\tthis.outputNode = source.outputNode;\n\n\t\tthis.fragmentNode = source.fragmentNode;\n\t\tthis.vertexNode = source.vertexNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n\tstatic fromMaterial( material ) {\n\n\t\tif ( material.isNodeMaterial === true ) { // is already a node material\n\n\t\t\treturn material;\n\n\t\t}\n\n\t\tconst type = material.type.replace( 'Material', 'NodeMaterial' );\n\n\t\tconst nodeMaterial = createNodeMaterialFromType( type );\n\n\t\tif ( nodeMaterial === undefined ) {\n\n\t\t\tthrow new Error( `NodeMaterial: Material \"${ material.type }\" is not compatible.` );\n\n\t\t}\n\n\t\tfor ( const key in material ) {\n\n\t\t\tnodeMaterial[ key ] = material[ key ];\n\n\t\t}\n\n\t\treturn nodeMaterial;\n\n\t}\n\n}\n\nexport default NodeMaterial;\n\nexport function addNodeMaterial( type, nodeMaterial ) {\n\n\tif ( typeof nodeMaterial !== 'function' || ! type ) throw new Error( `Node material ${ type } is not a class` );\n\tif ( NodeMaterials.has( type ) ) {\n\n\t\tconsole.warn( `Redefinition of node material ${ type }` );\n\t\treturn;\n\n\t}\n\n\tNodeMaterials.set( type, nodeMaterial );\n\tnodeMaterial.type = type;\n\n}\n\nexport function createNodeMaterialFromType( type ) {\n\n\tconst Material = NodeMaterials.get( type );\n\n\tif ( Material !== undefined ) {\n\n\t\treturn new Material();\n\n\t}\n\n}\n\naddNodeMaterial( 'NodeMaterial', NodeMaterial );\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}