{"ast":null,"code":"import Node, { addNodeClass } from '../core/Node.js';\nimport ArrayElementNode from '../utils/ArrayElementNode.js';\nimport ConvertNode from '../utils/ConvertNode.js';\nimport JoinNode from '../utils/JoinNode.js';\nimport SplitNode from '../utils/SplitNode.js';\nimport SetNode from '../utils/SetNode.js';\nimport ConstNode from '../core/ConstNode.js';\nimport { getValueFromType, getValueType } from '../core/NodeUtils.js';\n\n//\n\nlet currentStack = null;\nconst NodeElements = new Map(); // @TODO: Currently only a few nodes are added, probably also add others\n\nexport function addNodeElement(name, nodeElement) {\n  if (NodeElements.has(name)) {\n    console.warn(`Redefinition of node element ${name}`);\n    return;\n  }\n  if (typeof nodeElement !== 'function') throw new Error(`Node element ${name} is not a function`);\n  NodeElements.set(name, nodeElement);\n}\nconst parseSwizzle = props => props.replace(/r|s/g, 'x').replace(/g|t/g, 'y').replace(/b|p/g, 'z').replace(/a|q/g, 'w');\nconst shaderNodeHandler = {\n  setup(NodeClosure, params) {\n    const inputs = params.shift();\n    return NodeClosure(nodeObjects(inputs), ...params);\n  },\n  get(node, prop, nodeObj) {\n    if (typeof prop === 'string' && node[prop] === undefined) {\n      if (node.isStackNode !== true && prop === 'assign') {\n        return (...params) => {\n          currentStack.assign(nodeObj, ...params);\n          return nodeObj;\n        };\n      } else if (NodeElements.has(prop)) {\n        const nodeElement = NodeElements.get(prop);\n        return node.isStackNode ? (...params) => nodeObj.add(nodeElement(...params)) : (...params) => nodeElement(nodeObj, ...params);\n      } else if (prop === 'self') {\n        return node;\n      } else if (prop.endsWith('Assign') && NodeElements.has(prop.slice(0, prop.length - 'Assign'.length))) {\n        const nodeElement = NodeElements.get(prop.slice(0, prop.length - 'Assign'.length));\n        return node.isStackNode ? (...params) => nodeObj.assign(params[0], nodeElement(...params)) : (...params) => nodeObj.assign(nodeElement(nodeObj, ...params));\n      } else if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true) {\n        // accessing properties ( swizzle )\n\n        prop = parseSwizzle(prop);\n        return nodeObject(new SplitNode(nodeObj, prop));\n      } else if (/^set[XYZWRGBASTPQ]{1,4}$/.test(prop) === true) {\n        // set properties ( swizzle )\n\n        prop = parseSwizzle(prop.slice(3).toLowerCase());\n\n        // sort to xyzw sequence\n\n        prop = prop.split('').sort().join('');\n        return value => nodeObject(new SetNode(node, prop, value));\n      } else if (prop === 'width' || prop === 'height' || prop === 'depth') {\n        // accessing property\n\n        if (prop === 'width') prop = 'x';else if (prop === 'height') prop = 'y';else if (prop === 'depth') prop = 'z';\n        return nodeObject(new SplitNode(node, prop));\n      } else if (/^\\d+$/.test(prop) === true) {\n        // accessing array\n\n        return nodeObject(new ArrayElementNode(nodeObj, new ConstNode(Number(prop), 'uint')));\n      }\n    }\n    return Reflect.get(node, prop, nodeObj);\n  },\n  set(node, prop, value, nodeObj) {\n    if (typeof prop === 'string' && node[prop] === undefined) {\n      // setting properties\n\n      if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true || prop === 'width' || prop === 'height' || prop === 'depth' || /^\\d+$/.test(prop) === true) {\n        nodeObj[prop].assign(value);\n        return true;\n      }\n    }\n    return Reflect.set(node, prop, value, nodeObj);\n  }\n};\nconst nodeObjectsCacheMap = new WeakMap();\nconst nodeBuilderFunctionsCacheMap = new WeakMap();\nconst ShaderNodeObject = function (obj, altType = null) {\n  const type = getValueType(obj);\n  if (type === 'node') {\n    let nodeObject = nodeObjectsCacheMap.get(obj);\n    if (nodeObject === undefined) {\n      nodeObject = new Proxy(obj, shaderNodeHandler);\n      nodeObjectsCacheMap.set(obj, nodeObject);\n      nodeObjectsCacheMap.set(nodeObject, nodeObject);\n    }\n    return nodeObject;\n  } else if (altType === null && (type === 'float' || type === 'boolean') || type && type !== 'shader' && type !== 'string') {\n    return nodeObject(getConstNode(obj, altType));\n  } else if (type === 'shader') {\n    return tslFn(obj);\n  }\n  return obj;\n};\nconst ShaderNodeObjects = function (objects, altType = null) {\n  for (const name in objects) {\n    objects[name] = nodeObject(objects[name], altType);\n  }\n  return objects;\n};\nconst ShaderNodeArray = function (array, altType = null) {\n  const len = array.length;\n  for (let i = 0; i < len; i++) {\n    array[i] = nodeObject(array[i], altType);\n  }\n  return array;\n};\nconst ShaderNodeProxy = function (NodeClass, scope = null, factor = null, settings = null) {\n  const assignNode = node => nodeObject(settings !== null ? Object.assign(node, settings) : node);\n  if (scope === null) {\n    return (...params) => {\n      return assignNode(new NodeClass(...nodeArray(params)));\n    };\n  } else if (factor !== null) {\n    factor = nodeObject(factor);\n    return (...params) => {\n      return assignNode(new NodeClass(scope, ...nodeArray(params), factor));\n    };\n  } else {\n    return (...params) => {\n      return assignNode(new NodeClass(scope, ...nodeArray(params)));\n    };\n  }\n};\nconst ShaderNodeImmutable = function (NodeClass, ...params) {\n  return nodeObject(new NodeClass(...nodeArray(params)));\n};\nclass ShaderCallNodeInternal extends Node {\n  constructor(shaderNode, inputNodes) {\n    super();\n    this.shaderNode = shaderNode;\n    this.inputNodes = inputNodes;\n  }\n  getNodeType(builder) {\n    const properties = builder.getNodeProperties(this);\n    if (properties.outputNode === null) {\n      properties.outputNode = this.setupOutput(builder);\n    }\n    return properties.outputNode.getNodeType(builder);\n  }\n  call(builder) {\n    const {\n      shaderNode,\n      inputNodes\n    } = this;\n    if (shaderNode.layout) {\n      let functionNodesCacheMap = nodeBuilderFunctionsCacheMap.get(builder.constructor);\n      if (functionNodesCacheMap === undefined) {\n        functionNodesCacheMap = new WeakMap();\n        nodeBuilderFunctionsCacheMap.set(builder.constructor, functionNodesCacheMap);\n      }\n      let functionNode = functionNodesCacheMap.get(shaderNode);\n      if (functionNode === undefined) {\n        functionNode = nodeObject(builder.buildFunctionNode(shaderNode));\n        functionNodesCacheMap.set(shaderNode, functionNode);\n      }\n      if (builder.currentFunctionNode !== null) {\n        builder.currentFunctionNode.includes.push(functionNode);\n      }\n      return nodeObject(functionNode.call(inputNodes));\n    }\n    const jsFunc = shaderNode.jsFunc;\n    const outputNode = inputNodes !== null ? jsFunc(inputNodes, builder.stack, builder) : jsFunc(builder.stack, builder);\n    return nodeObject(outputNode);\n  }\n  setup(builder) {\n    const {\n      outputNode\n    } = builder.getNodeProperties(this);\n    return outputNode || this.setupOutput(builder);\n  }\n  setupOutput(builder) {\n    builder.addStack();\n    builder.stack.outputNode = this.call(builder);\n    return builder.removeStack();\n  }\n  generate(builder, output) {\n    const {\n      outputNode\n    } = builder.getNodeProperties(this);\n    if (outputNode === null) {\n      // TSL: It's recommended to use `tslFn` in setup() pass.\n\n      return this.call(builder).build(builder, output);\n    }\n    return super.generate(builder, output);\n  }\n}\nclass ShaderNodeInternal extends Node {\n  constructor(jsFunc) {\n    super();\n    this.jsFunc = jsFunc;\n    this.layout = null;\n  }\n  get isArrayInput() {\n    return /^\\((\\s+)?\\[/.test(this.jsFunc.toString());\n  }\n  setLayout(layout) {\n    this.layout = layout;\n    return this;\n  }\n  call(inputs = null) {\n    nodeObjects(inputs);\n    return nodeObject(new ShaderCallNodeInternal(this, inputs));\n  }\n  setup() {\n    return this.call();\n  }\n}\nconst bools = [false, true];\nconst uints = [0, 1, 2, 3];\nconst ints = [-1, -2];\nconst floats = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2];\nconst boolsCacheMap = new Map();\nfor (const bool of bools) boolsCacheMap.set(bool, new ConstNode(bool));\nconst uintsCacheMap = new Map();\nfor (const uint of uints) uintsCacheMap.set(uint, new ConstNode(uint, 'uint'));\nconst intsCacheMap = new Map([...uintsCacheMap].map(el => new ConstNode(el.value, 'int')));\nfor (const int of ints) intsCacheMap.set(int, new ConstNode(int, 'int'));\nconst floatsCacheMap = new Map([...intsCacheMap].map(el => new ConstNode(el.value)));\nfor (const float of floats) floatsCacheMap.set(float, new ConstNode(float));\nfor (const float of floats) floatsCacheMap.set(-float, new ConstNode(-float));\nconst cacheMaps = {\n  bool: boolsCacheMap,\n  uint: uintsCacheMap,\n  ints: intsCacheMap,\n  float: floatsCacheMap\n};\nconst constNodesCacheMap = new Map([...boolsCacheMap, ...floatsCacheMap]);\nconst getConstNode = (value, type) => {\n  if (constNodesCacheMap.has(value)) {\n    return constNodesCacheMap.get(value);\n  } else if (value.isNode === true) {\n    return value;\n  } else {\n    return new ConstNode(value, type);\n  }\n};\nconst safeGetNodeType = node => {\n  try {\n    return node.getNodeType();\n  } catch (_) {\n    return undefined;\n  }\n};\nconst ConvertType = function (type, cacheMap = null) {\n  return (...params) => {\n    if (params.length === 0 || !['bool', 'float', 'int', 'uint'].includes(type) && params.every(param => typeof param !== 'object')) {\n      params = [getValueFromType(type, ...params)];\n    }\n    if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {\n      return nodeObject(cacheMap.get(params[0]));\n    }\n    if (params.length === 1) {\n      const node = getConstNode(params[0], type);\n      if (safeGetNodeType(node) === type) return nodeObject(node);\n      return nodeObject(new ConvertNode(node, type));\n    }\n    const nodes = params.map(param => getConstNode(param));\n    return nodeObject(new JoinNode(nodes, type));\n  };\n};\n\n// exports\n\nexport const defined = value => value && value.value;\n\n// utils\n\nexport const getConstNodeType = value => value !== undefined && value !== null ? value.nodeType || value.convertTo || (typeof value === 'string' ? value : null) : null;\n\n// shader node base\n\nexport function ShaderNode(jsFunc) {\n  return new Proxy(new ShaderNodeInternal(jsFunc), shaderNodeHandler);\n}\nexport const nodeObject = (val, altType = null) => /* new */ShaderNodeObject(val, altType);\nexport const nodeObjects = (val, altType = null) => new ShaderNodeObjects(val, altType);\nexport const nodeArray = (val, altType = null) => new ShaderNodeArray(val, altType);\nexport const nodeProxy = (...params) => new ShaderNodeProxy(...params);\nexport const nodeImmutable = (...params) => new ShaderNodeImmutable(...params);\nexport const tslFn = jsFunc => {\n  const shaderNode = new ShaderNode(jsFunc);\n  const fn = (...params) => {\n    let inputs;\n    nodeObjects(params);\n    if (params[0] && params[0].isNode) {\n      inputs = [...params];\n    } else {\n      inputs = params[0];\n    }\n    return shaderNode.call(inputs);\n  };\n  fn.shaderNode = shaderNode;\n  fn.setLayout = layout => {\n    shaderNode.setLayout(layout);\n    return fn;\n  };\n  return fn;\n};\naddNodeClass('ShaderNode', ShaderNode);\n\n//\n\naddNodeElement('toGlobal', node => {\n  node.global = true;\n  return node;\n});\n\n//\n\nexport const setCurrentStack = stack => {\n  if (currentStack === stack) {\n\n    //throw new Error( 'Stack already defined.' );\n  }\n  currentStack = stack;\n};\nexport const getCurrentStack = () => currentStack;\nexport const If = (...params) => currentStack.if(...params);\nexport function append(node) {\n  if (currentStack) currentStack.add(node);\n  return node;\n}\naddNodeElement('append', append);\n\n// types\n// @TODO: Maybe export from ConstNode.js?\n\nexport const color = new ConvertType('color');\nexport const float = new ConvertType('float', cacheMaps.float);\nexport const int = new ConvertType('int', cacheMaps.ints);\nexport const uint = new ConvertType('uint', cacheMaps.uint);\nexport const bool = new ConvertType('bool', cacheMaps.bool);\nexport const vec2 = new ConvertType('vec2');\nexport const ivec2 = new ConvertType('ivec2');\nexport const uvec2 = new ConvertType('uvec2');\nexport const bvec2 = new ConvertType('bvec2');\nexport const vec3 = new ConvertType('vec3');\nexport const ivec3 = new ConvertType('ivec3');\nexport const uvec3 = new ConvertType('uvec3');\nexport const bvec3 = new ConvertType('bvec3');\nexport const vec4 = new ConvertType('vec4');\nexport const ivec4 = new ConvertType('ivec4');\nexport const uvec4 = new ConvertType('uvec4');\nexport const bvec4 = new ConvertType('bvec4');\nexport const mat2 = new ConvertType('mat2');\nexport const imat2 = new ConvertType('imat2');\nexport const umat2 = new ConvertType('umat2');\nexport const bmat2 = new ConvertType('bmat2');\nexport const mat3 = new ConvertType('mat3');\nexport const imat3 = new ConvertType('imat3');\nexport const umat3 = new ConvertType('umat3');\nexport const bmat3 = new ConvertType('bmat3');\nexport const mat4 = new ConvertType('mat4');\nexport const imat4 = new ConvertType('imat4');\nexport const umat4 = new ConvertType('umat4');\nexport const bmat4 = new ConvertType('bmat4');\nexport const string = (value = '') => nodeObject(new ConstNode(value, 'string'));\nexport const arrayBuffer = value => nodeObject(new ConstNode(value, 'ArrayBuffer'));\naddNodeElement('toColor', color);\naddNodeElement('toFloat', float);\naddNodeElement('toInt', int);\naddNodeElement('toUint', uint);\naddNodeElement('toBool', bool);\naddNodeElement('toVec2', vec2);\naddNodeElement('toIvec2', ivec2);\naddNodeElement('toUvec2', uvec2);\naddNodeElement('toBvec2', bvec2);\naddNodeElement('toVec3', vec3);\naddNodeElement('toIvec3', ivec3);\naddNodeElement('toUvec3', uvec3);\naddNodeElement('toBvec3', bvec3);\naddNodeElement('toVec4', vec4);\naddNodeElement('toIvec4', ivec4);\naddNodeElement('toUvec4', uvec4);\naddNodeElement('toBvec4', bvec4);\naddNodeElement('toMat2', mat2);\naddNodeElement('toImat2', imat2);\naddNodeElement('toUmat2', umat2);\naddNodeElement('toBmat2', bmat2);\naddNodeElement('toMat3', mat3);\naddNodeElement('toImat3', imat3);\naddNodeElement('toUmat3', umat3);\naddNodeElement('toBmat3', bmat3);\naddNodeElement('toMat4', mat4);\naddNodeElement('toImat4', imat4);\naddNodeElement('toUmat4', umat4);\naddNodeElement('toBmat4', bmat4);\n\n// basic nodes\n// HACK - we cannot export them from the corresponding files because of the cyclic dependency\nexport const element = nodeProxy(ArrayElementNode);\nexport const convert = (node, types) => nodeObject(new ConvertNode(nodeObject(node), types));\nexport const split = (node, channels) => nodeObject(new SplitNode(nodeObject(node), channels));\naddNodeElement('element', element);\naddNodeElement('convert', convert);","map":{"version":3,"names":["Node","addNodeClass","ArrayElementNode","ConvertNode","JoinNode","SplitNode","SetNode","ConstNode","getValueFromType","getValueType","currentStack","NodeElements","Map","addNodeElement","name","nodeElement","has","console","warn","Error","set","parseSwizzle","props","replace","shaderNodeHandler","setup","NodeClosure","params","inputs","shift","nodeObjects","get","node","prop","nodeObj","undefined","isStackNode","assign","add","endsWith","slice","length","test","nodeObject","toLowerCase","split","sort","join","value","Number","Reflect","nodeObjectsCacheMap","WeakMap","nodeBuilderFunctionsCacheMap","ShaderNodeObject","obj","altType","type","Proxy","getConstNode","tslFn","ShaderNodeObjects","objects","ShaderNodeArray","array","len","i","ShaderNodeProxy","NodeClass","scope","factor","settings","assignNode","Object","nodeArray","ShaderNodeImmutable","ShaderCallNodeInternal","constructor","shaderNode","inputNodes","getNodeType","builder","properties","getNodeProperties","outputNode","setupOutput","call","layout","functionNodesCacheMap","functionNode","buildFunctionNode","currentFunctionNode","includes","push","jsFunc","stack","addStack","removeStack","generate","output","build","ShaderNodeInternal","isArrayInput","toString","setLayout","bools","uints","ints","floats","Math","PI","boolsCacheMap","bool","uintsCacheMap","uint","intsCacheMap","map","el","int","floatsCacheMap","float","cacheMaps","constNodesCacheMap","isNode","safeGetNodeType","_","ConvertType","cacheMap","every","param","nodes","defined","getConstNodeType","nodeType","convertTo","ShaderNode","val","nodeProxy","nodeImmutable","fn","global","setCurrentStack","getCurrentStack","If","if","append","color","vec2","ivec2","uvec2","bvec2","vec3","ivec3","uvec3","bvec3","vec4","ivec4","uvec4","bvec4","mat2","imat2","umat2","bmat2","mat3","imat3","umat3","bmat3","mat4","imat4","umat4","bmat4","string","arrayBuffer","element","convert","types","channels"],"sources":["D:/dumps/online-learning-platform-main/Frontend/node_modules/three/examples/jsm/nodes/shadernode/ShaderNode.js"],"sourcesContent":["import Node, { addNodeClass } from '../core/Node.js';\nimport ArrayElementNode from '../utils/ArrayElementNode.js';\nimport ConvertNode from '../utils/ConvertNode.js';\nimport JoinNode from '../utils/JoinNode.js';\nimport SplitNode from '../utils/SplitNode.js';\nimport SetNode from '../utils/SetNode.js';\nimport ConstNode from '../core/ConstNode.js';\nimport { getValueFromType, getValueType } from '../core/NodeUtils.js';\n\n//\n\nlet currentStack = null;\n\nconst NodeElements = new Map(); // @TODO: Currently only a few nodes are added, probably also add others\n\nexport function addNodeElement( name, nodeElement ) {\n\n\tif ( NodeElements.has( name ) ) {\n\n\t\tconsole.warn( `Redefinition of node element ${ name }` );\n\t\treturn;\n\n\t}\n\n\tif ( typeof nodeElement !== 'function' ) throw new Error( `Node element ${ name } is not a function` );\n\n\tNodeElements.set( name, nodeElement );\n\n}\n\nconst parseSwizzle = ( props ) => props.replace( /r|s/g, 'x' ).replace( /g|t/g, 'y' ).replace( /b|p/g, 'z' ).replace( /a|q/g, 'w' );\n\nconst shaderNodeHandler = {\n\n\tsetup( NodeClosure, params ) {\n\n\t\tconst inputs = params.shift();\n\n\t\treturn NodeClosure( nodeObjects( inputs ), ...params );\n\n\t},\n\n\tget( node, prop, nodeObj ) {\n\n\t\tif ( typeof prop === 'string' && node[ prop ] === undefined ) {\n\n\t\t\tif ( node.isStackNode !== true && prop === 'assign' ) {\n\n\t\t\t\treturn ( ...params ) => {\n\n\t\t\t\t\tcurrentStack.assign( nodeObj, ...params );\n\n\t\t\t\t\treturn nodeObj;\n\n\t\t\t\t};\n\n\t\t\t} else if ( NodeElements.has( prop ) ) {\n\n\t\t\t\tconst nodeElement = NodeElements.get( prop );\n\n\t\t\t\treturn node.isStackNode ? ( ...params ) => nodeObj.add( nodeElement( ...params ) ) : ( ...params ) => nodeElement( nodeObj, ...params );\n\n\t\t\t} else if ( prop === 'self' ) {\n\n\t\t\t\treturn node;\n\n\t\t\t} else if ( prop.endsWith( 'Assign' ) && NodeElements.has( prop.slice( 0, prop.length - 'Assign'.length ) ) ) {\n\n\t\t\t\tconst nodeElement = NodeElements.get( prop.slice( 0, prop.length - 'Assign'.length ) );\n\n\t\t\t\treturn node.isStackNode ? ( ...params ) => nodeObj.assign( params[ 0 ], nodeElement( ...params ) ) : ( ...params ) => nodeObj.assign( nodeElement( nodeObj, ...params ) );\n\n\t\t\t} else if ( /^[xyzwrgbastpq]{1,4}$/.test( prop ) === true ) {\n\n\t\t\t\t// accessing properties ( swizzle )\n\n\t\t\t\tprop = parseSwizzle( prop );\n\n\t\t\t\treturn nodeObject( new SplitNode( nodeObj, prop ) );\n\n\t\t\t} else if ( /^set[XYZWRGBASTPQ]{1,4}$/.test( prop ) === true ) {\n\n\t\t\t\t// set properties ( swizzle )\n\n\t\t\t\tprop = parseSwizzle( prop.slice( 3 ).toLowerCase() );\n\n\t\t\t\t// sort to xyzw sequence\n\n\t\t\t\tprop = prop.split( '' ).sort().join( '' );\n\n\t\t\t\treturn ( value ) => nodeObject( new SetNode( node, prop, value ) );\n\n\t\t\t} else if ( prop === 'width' || prop === 'height' || prop === 'depth' ) {\n\n\t\t\t\t// accessing property\n\n\t\t\t\tif ( prop === 'width' ) prop = 'x';\n\t\t\t\telse if ( prop === 'height' ) prop = 'y';\n\t\t\t\telse if ( prop === 'depth' ) prop = 'z';\n\n\t\t\t\treturn nodeObject( new SplitNode( node, prop ) );\n\n\t\t\t} else if ( /^\\d+$/.test( prop ) === true ) {\n\n\t\t\t\t// accessing array\n\n\t\t\t\treturn nodeObject( new ArrayElementNode( nodeObj, new ConstNode( Number( prop ), 'uint' ) ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Reflect.get( node, prop, nodeObj );\n\n\t},\n\n\tset( node, prop, value, nodeObj ) {\n\n\t\tif ( typeof prop === 'string' && node[ prop ] === undefined ) {\n\n\t\t\t// setting properties\n\n\t\t\tif ( /^[xyzwrgbastpq]{1,4}$/.test( prop ) === true || prop === 'width' || prop === 'height' || prop === 'depth' || /^\\d+$/.test( prop ) === true ) {\n\n\t\t\t\tnodeObj[ prop ].assign( value );\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Reflect.set( node, prop, value, nodeObj );\n\n\t}\n\n};\n\nconst nodeObjectsCacheMap = new WeakMap();\nconst nodeBuilderFunctionsCacheMap = new WeakMap();\n\nconst ShaderNodeObject = function ( obj, altType = null ) {\n\n\tconst type = getValueType( obj );\n\n\tif ( type === 'node' ) {\n\n\t\tlet nodeObject = nodeObjectsCacheMap.get( obj );\n\n\t\tif ( nodeObject === undefined ) {\n\n\t\t\tnodeObject = new Proxy( obj, shaderNodeHandler );\n\n\t\t\tnodeObjectsCacheMap.set( obj, nodeObject );\n\t\t\tnodeObjectsCacheMap.set( nodeObject, nodeObject );\n\n\t\t}\n\n\t\treturn nodeObject;\n\n\t} else if ( ( altType === null && ( type === 'float' || type === 'boolean' ) ) || ( type && type !== 'shader' && type !== 'string' ) ) {\n\n\t\treturn nodeObject( getConstNode( obj, altType ) );\n\n\t} else if ( type === 'shader' ) {\n\n\t\treturn tslFn( obj );\n\n\t}\n\n\treturn obj;\n\n};\n\nconst ShaderNodeObjects = function ( objects, altType = null ) {\n\n\tfor ( const name in objects ) {\n\n\t\tobjects[ name ] = nodeObject( objects[ name ], altType );\n\n\t}\n\n\treturn objects;\n\n};\n\nconst ShaderNodeArray = function ( array, altType = null ) {\n\n\tconst len = array.length;\n\n\tfor ( let i = 0; i < len; i ++ ) {\n\n\t\tarray[ i ] = nodeObject( array[ i ], altType );\n\n\t}\n\n\treturn array;\n\n};\n\nconst ShaderNodeProxy = function ( NodeClass, scope = null, factor = null, settings = null ) {\n\n\tconst assignNode = ( node ) => nodeObject( settings !== null ? Object.assign( node, settings ) : node );\n\n\tif ( scope === null ) {\n\n\t\treturn ( ...params ) => {\n\n\t\t\treturn assignNode( new NodeClass( ...nodeArray( params ) ) );\n\n\t\t};\n\n\t} else if ( factor !== null ) {\n\n\t\tfactor = nodeObject( factor );\n\n\t\treturn ( ...params ) => {\n\n\t\t\treturn assignNode( new NodeClass( scope, ...nodeArray( params ), factor ) );\n\n\t\t};\n\n\t} else {\n\n\t\treturn ( ...params ) => {\n\n\t\t\treturn assignNode( new NodeClass( scope, ...nodeArray( params ) ) );\n\n\t\t};\n\n\t}\n\n};\n\nconst ShaderNodeImmutable = function ( NodeClass, ...params ) {\n\n\treturn nodeObject( new NodeClass( ...nodeArray( params ) ) );\n\n};\n\nclass ShaderCallNodeInternal extends Node {\n\n\tconstructor( shaderNode, inputNodes ) {\n\n\t\tsuper();\n\n\t\tthis.shaderNode = shaderNode;\n\t\tthis.inputNodes = inputNodes;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tif ( properties.outputNode === null ) {\n\n\t\t\tproperties.outputNode = this.setupOutput( builder );\n\n\t\t}\n\n\t\treturn properties.outputNode.getNodeType( builder );\n\n\t}\n\n\tcall( builder ) {\n\n\t\tconst { shaderNode, inputNodes } = this;\n\n\t\tif ( shaderNode.layout ) {\n\n\t\t\tlet functionNodesCacheMap = nodeBuilderFunctionsCacheMap.get( builder.constructor );\n\n\t\t\tif ( functionNodesCacheMap === undefined ) {\n\n\t\t\t\tfunctionNodesCacheMap = new WeakMap();\n\n\t\t\t\tnodeBuilderFunctionsCacheMap.set( builder.constructor, functionNodesCacheMap );\n\n\t\t\t}\n\n\t\t\tlet functionNode = functionNodesCacheMap.get( shaderNode );\n\n\t\t\tif ( functionNode === undefined ) {\n\n\t\t\t\tfunctionNode = nodeObject( builder.buildFunctionNode( shaderNode ) );\n\n\t\t\t\tfunctionNodesCacheMap.set( shaderNode, functionNode );\n\n\t\t\t}\n\n\t\t\tif ( builder.currentFunctionNode !== null ) {\n\n\t\t\t\tbuilder.currentFunctionNode.includes.push( functionNode );\n\n\t\t\t}\n\n\t\t\treturn nodeObject( functionNode.call( inputNodes ) );\n\n\t\t}\n\n\t\tconst jsFunc = shaderNode.jsFunc;\n\t\tconst outputNode = inputNodes !== null ? jsFunc( inputNodes, builder.stack, builder ) : jsFunc( builder.stack, builder );\n\n\t\treturn nodeObject( outputNode );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst { outputNode } = builder.getNodeProperties( this );\n\n\t\treturn outputNode || this.setupOutput( builder );\n\n\t}\n\n\tsetupOutput( builder ) {\n\n\t\tbuilder.addStack();\n\n\t\tbuilder.stack.outputNode = this.call( builder );\n\n\t\treturn builder.removeStack();\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst { outputNode } = builder.getNodeProperties( this );\n\n\t\tif ( outputNode === null ) {\n\n\t\t\t// TSL: It's recommended to use `tslFn` in setup() pass.\n\n\t\t\treturn this.call( builder ).build( builder, output );\n\n\t\t}\n\n\t\treturn super.generate( builder, output );\n\n\t}\n\n}\n\nclass ShaderNodeInternal extends Node {\n\n\tconstructor( jsFunc ) {\n\n\t\tsuper();\n\n\t\tthis.jsFunc = jsFunc;\n\t\tthis.layout = null;\n\n\t}\n\n\tget isArrayInput() {\n\n\t\treturn /^\\((\\s+)?\\[/.test( this.jsFunc.toString() );\n\n\t}\n\n\tsetLayout( layout ) {\n\n\t\tthis.layout = layout;\n\n\t\treturn this;\n\n\t}\n\n\tcall( inputs = null ) {\n\n\t\tnodeObjects( inputs );\n\n\t\treturn nodeObject( new ShaderCallNodeInternal( this, inputs ) );\n\n\t}\n\n\tsetup() {\n\n\t\treturn this.call();\n\n\t}\n\n}\n\nconst bools = [ false, true ];\nconst uints = [ 0, 1, 2, 3 ];\nconst ints = [ - 1, - 2 ];\nconst floats = [ 0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / ( Math.PI * 2 ), Math.PI / 2 ];\n\nconst boolsCacheMap = new Map();\nfor ( const bool of bools ) boolsCacheMap.set( bool, new ConstNode( bool ) );\n\nconst uintsCacheMap = new Map();\nfor ( const uint of uints ) uintsCacheMap.set( uint, new ConstNode( uint, 'uint' ) );\n\nconst intsCacheMap = new Map( [ ...uintsCacheMap ].map( el => new ConstNode( el.value, 'int' ) ) );\nfor ( const int of ints ) intsCacheMap.set( int, new ConstNode( int, 'int' ) );\n\nconst floatsCacheMap = new Map( [ ...intsCacheMap ].map( el => new ConstNode( el.value ) ) );\nfor ( const float of floats ) floatsCacheMap.set( float, new ConstNode( float ) );\nfor ( const float of floats ) floatsCacheMap.set( - float, new ConstNode( - float ) );\n\nconst cacheMaps = { bool: boolsCacheMap, uint: uintsCacheMap, ints: intsCacheMap, float: floatsCacheMap };\n\nconst constNodesCacheMap = new Map( [ ...boolsCacheMap, ...floatsCacheMap ] );\n\nconst getConstNode = ( value, type ) => {\n\n\tif ( constNodesCacheMap.has( value ) ) {\n\n\t\treturn constNodesCacheMap.get( value );\n\n\t} else if ( value.isNode === true ) {\n\n\t\treturn value;\n\n\t} else {\n\n\t\treturn new ConstNode( value, type );\n\n\t}\n\n};\n\nconst safeGetNodeType = ( node ) => {\n\n\ttry {\n\n\t\treturn node.getNodeType();\n\n\t} catch ( _ ) {\n\n\t\treturn undefined;\n\n\t}\n\n};\n\nconst ConvertType = function ( type, cacheMap = null ) {\n\n\treturn ( ...params ) => {\n\n\t\tif ( params.length === 0 || ( ! [ 'bool', 'float', 'int', 'uint' ].includes( type ) && params.every( param => typeof param !== 'object' ) ) ) {\n\n\t\t\tparams = [ getValueFromType( type, ...params ) ];\n\n\t\t}\n\n\t\tif ( params.length === 1 && cacheMap !== null && cacheMap.has( params[ 0 ] ) ) {\n\n\t\t\treturn nodeObject( cacheMap.get( params[ 0 ] ) );\n\n\t\t}\n\n\t\tif ( params.length === 1 ) {\n\n\t\t\tconst node = getConstNode( params[ 0 ], type );\n\t\t\tif ( safeGetNodeType( node ) === type ) return nodeObject( node );\n\t\t\treturn nodeObject( new ConvertNode( node, type ) );\n\n\t\t}\n\n\t\tconst nodes = params.map( param => getConstNode( param ) );\n\t\treturn nodeObject( new JoinNode( nodes, type ) );\n\n\t};\n\n};\n\n// exports\n\nexport const defined = ( value ) => value && value.value;\n\n// utils\n\nexport const getConstNodeType = ( value ) => ( value !== undefined && value !== null ) ? ( value.nodeType || value.convertTo || ( typeof value === 'string' ? value : null ) ) : null;\n\n// shader node base\n\nexport function ShaderNode( jsFunc ) {\n\n\treturn new Proxy( new ShaderNodeInternal( jsFunc ), shaderNodeHandler );\n\n}\n\nexport const nodeObject = ( val, altType = null ) => /* new */ ShaderNodeObject( val, altType );\nexport const nodeObjects = ( val, altType = null ) => new ShaderNodeObjects( val, altType );\nexport const nodeArray = ( val, altType = null ) => new ShaderNodeArray( val, altType );\nexport const nodeProxy = ( ...params ) => new ShaderNodeProxy( ...params );\nexport const nodeImmutable = ( ...params ) => new ShaderNodeImmutable( ...params );\n\nexport const tslFn = ( jsFunc ) => {\n\n\tconst shaderNode = new ShaderNode( jsFunc );\n\n\tconst fn = ( ...params ) => {\n\n\t\tlet inputs;\n\n\t\tnodeObjects( params );\n\n\t\tif ( params[ 0 ] && params[ 0 ].isNode ) {\n\n\t\t\tinputs = [ ...params ];\n\n\t\t} else {\n\n\t\t\tinputs = params[ 0 ];\n\n\t\t}\n\n\t\treturn shaderNode.call( inputs );\n\n\t};\n\n\tfn.shaderNode = shaderNode;\n\tfn.setLayout = ( layout ) => {\n\n\t\tshaderNode.setLayout( layout );\n\n\t\treturn fn;\n\n\t};\n\n\treturn fn;\n\n};\n\naddNodeClass( 'ShaderNode', ShaderNode );\n\n//\n\naddNodeElement( 'toGlobal', ( node ) => {\n\n\tnode.global = true;\n\n\treturn node;\n\n} );\n\n//\n\nexport const setCurrentStack = ( stack ) => {\n\n\tif ( currentStack === stack ) {\n\n\t\t//throw new Error( 'Stack already defined.' );\n\n\t}\n\n\tcurrentStack = stack;\n\n};\n\nexport const getCurrentStack = () => currentStack;\n\nexport const If = ( ...params ) => currentStack.if( ...params );\n\nexport function append( node ) {\n\n\tif ( currentStack ) currentStack.add( node );\n\n\treturn node;\n\n}\n\naddNodeElement( 'append', append );\n\n// types\n// @TODO: Maybe export from ConstNode.js?\n\nexport const color = new ConvertType( 'color' );\n\nexport const float = new ConvertType( 'float', cacheMaps.float );\nexport const int = new ConvertType( 'int', cacheMaps.ints );\nexport const uint = new ConvertType( 'uint', cacheMaps.uint );\nexport const bool = new ConvertType( 'bool', cacheMaps.bool );\n\nexport const vec2 = new ConvertType( 'vec2' );\nexport const ivec2 = new ConvertType( 'ivec2' );\nexport const uvec2 = new ConvertType( 'uvec2' );\nexport const bvec2 = new ConvertType( 'bvec2' );\n\nexport const vec3 = new ConvertType( 'vec3' );\nexport const ivec3 = new ConvertType( 'ivec3' );\nexport const uvec3 = new ConvertType( 'uvec3' );\nexport const bvec3 = new ConvertType( 'bvec3' );\n\nexport const vec4 = new ConvertType( 'vec4' );\nexport const ivec4 = new ConvertType( 'ivec4' );\nexport const uvec4 = new ConvertType( 'uvec4' );\nexport const bvec4 = new ConvertType( 'bvec4' );\n\nexport const mat2 = new ConvertType( 'mat2' );\nexport const imat2 = new ConvertType( 'imat2' );\nexport const umat2 = new ConvertType( 'umat2' );\nexport const bmat2 = new ConvertType( 'bmat2' );\n\nexport const mat3 = new ConvertType( 'mat3' );\nexport const imat3 = new ConvertType( 'imat3' );\nexport const umat3 = new ConvertType( 'umat3' );\nexport const bmat3 = new ConvertType( 'bmat3' );\n\nexport const mat4 = new ConvertType( 'mat4' );\nexport const imat4 = new ConvertType( 'imat4' );\nexport const umat4 = new ConvertType( 'umat4' );\nexport const bmat4 = new ConvertType( 'bmat4' );\n\nexport const string = ( value = '' ) => nodeObject( new ConstNode( value, 'string' ) );\nexport const arrayBuffer = ( value ) => nodeObject( new ConstNode( value, 'ArrayBuffer' ) );\n\naddNodeElement( 'toColor', color );\naddNodeElement( 'toFloat', float );\naddNodeElement( 'toInt', int );\naddNodeElement( 'toUint', uint );\naddNodeElement( 'toBool', bool );\naddNodeElement( 'toVec2', vec2 );\naddNodeElement( 'toIvec2', ivec2 );\naddNodeElement( 'toUvec2', uvec2 );\naddNodeElement( 'toBvec2', bvec2 );\naddNodeElement( 'toVec3', vec3 );\naddNodeElement( 'toIvec3', ivec3 );\naddNodeElement( 'toUvec3', uvec3 );\naddNodeElement( 'toBvec3', bvec3 );\naddNodeElement( 'toVec4', vec4 );\naddNodeElement( 'toIvec4', ivec4 );\naddNodeElement( 'toUvec4', uvec4 );\naddNodeElement( 'toBvec4', bvec4 );\naddNodeElement( 'toMat2', mat2 );\naddNodeElement( 'toImat2', imat2 );\naddNodeElement( 'toUmat2', umat2 );\naddNodeElement( 'toBmat2', bmat2 );\naddNodeElement( 'toMat3', mat3 );\naddNodeElement( 'toImat3', imat3 );\naddNodeElement( 'toUmat3', umat3 );\naddNodeElement( 'toBmat3', bmat3 );\naddNodeElement( 'toMat4', mat4 );\naddNodeElement( 'toImat4', imat4 );\naddNodeElement( 'toUmat4', umat4 );\naddNodeElement( 'toBmat4', bmat4 );\n\n// basic nodes\n// HACK - we cannot export them from the corresponding files because of the cyclic dependency\nexport const element = nodeProxy( ArrayElementNode );\nexport const convert = ( node, types ) => nodeObject( new ConvertNode( nodeObject( node ), types ) );\nexport const split = ( node, channels ) => nodeObject( new SplitNode( nodeObject( node ), channels ) );\n\naddNodeElement( 'element', element );\naddNodeElement( 'convert', convert );\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}