{"ast":null,"code":"import Node, { addNodeClass } from './Node.js';\nimport { varying } from './VaryingNode.js';\nimport { nodeObject } from '../shadernode/ShaderNode.js';\nclass AttributeNode extends Node {\n  constructor(attributeName, nodeType = null, defaultNode = null) {\n    super(nodeType);\n    this.defaultNode = defaultNode;\n    this._attributeName = attributeName;\n  }\n  isGlobal() {\n    return true;\n  }\n  getHash(builder) {\n    return this.getAttributeName(builder);\n  }\n  getNodeType(builder) {\n    let nodeType = super.getNodeType(builder);\n    if (nodeType === null) {\n      const attributeName = this.getAttributeName(builder);\n      if (builder.hasGeometryAttribute(attributeName)) {\n        const attribute = builder.geometry.getAttribute(attributeName);\n        nodeType = builder.getTypeFromAttribute(attribute);\n      } else {\n        nodeType = 'float';\n      }\n    }\n    return nodeType;\n  }\n  setAttributeName(attributeName) {\n    this._attributeName = attributeName;\n    return this;\n  }\n  getAttributeName( /*builder*/\n  ) {\n    return this._attributeName;\n  }\n  generate(builder) {\n    const attributeName = this.getAttributeName(builder);\n    const nodeType = this.getNodeType(builder);\n    const geometryAttribute = builder.hasGeometryAttribute(attributeName);\n    if (geometryAttribute === true) {\n      const attribute = builder.geometry.getAttribute(attributeName);\n      const attributeType = builder.getTypeFromAttribute(attribute);\n      const nodeAttribute = builder.getAttribute(attributeName, attributeType);\n      if (builder.shaderStage === 'vertex') {\n        return builder.format(nodeAttribute.name, attributeType, nodeType);\n      } else {\n        const nodeVarying = varying(this);\n        return nodeVarying.build(builder, nodeType);\n      }\n    } else {\n      console.warn(`AttributeNode: Vertex attribute \"${attributeName}\" not found on geometry.`);\n      const {\n        defaultNode\n      } = this;\n      if (defaultNode !== null) {\n        return defaultNode.build(builder, nodeType);\n      } else {\n        return builder.generateConst(nodeType);\n      }\n    }\n  }\n}\nexport default AttributeNode;\nexport const attribute = (name, nodeType, defaultNode) => nodeObject(new AttributeNode(name, nodeType, nodeObject(defaultNode)));\naddNodeClass('AttributeNode', AttributeNode);","map":{"version":3,"names":["Node","addNodeClass","varying","nodeObject","AttributeNode","constructor","attributeName","nodeType","defaultNode","_attributeName","isGlobal","getHash","builder","getAttributeName","getNodeType","hasGeometryAttribute","attribute","geometry","getAttribute","getTypeFromAttribute","setAttributeName","generate","geometryAttribute","attributeType","nodeAttribute","shaderStage","format","name","nodeVarying","build","console","warn","generateConst"],"sources":["D:/dumps/online-learning-platform-main/Frontend/node_modules/three/examples/jsm/nodes/core/AttributeNode.js"],"sourcesContent":["import Node, { addNodeClass } from './Node.js';\nimport { varying } from './VaryingNode.js';\nimport { nodeObject } from '../shadernode/ShaderNode.js';\n\nclass AttributeNode extends Node {\n\n\tconstructor( attributeName, nodeType = null, defaultNode = null ) {\n\n\t\tsuper( nodeType );\n\n\t\tthis.defaultNode = defaultNode;\n\n\t\tthis._attributeName = attributeName;\n\n\t}\n\n\tisGlobal() {\n\n\t\treturn true;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.getAttributeName( builder );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tlet nodeType = super.getNodeType( builder );\n\n\t\tif ( nodeType === null ) {\n\n\t\t\tconst attributeName = this.getAttributeName( builder );\n\n\t\t\tif ( builder.hasGeometryAttribute( attributeName ) ) {\n\n\t\t\t\tconst attribute = builder.geometry.getAttribute( attributeName );\n\n\t\t\t\tnodeType = builder.getTypeFromAttribute( attribute );\n\n\t\t\t} else {\n\n\t\t\t\tnodeType = 'float';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn nodeType;\n\n\t}\n\n\tsetAttributeName( attributeName ) {\n\n\t\tthis._attributeName = attributeName;\n\n\t\treturn this;\n\n\t}\n\n\tgetAttributeName( /*builder*/ ) {\n\n\t\treturn this._attributeName;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst attributeName = this.getAttributeName( builder );\n\t\tconst nodeType = this.getNodeType( builder );\n\t\tconst geometryAttribute = builder.hasGeometryAttribute( attributeName );\n\n\t\tif ( geometryAttribute === true ) {\n\n\t\t\tconst attribute = builder.geometry.getAttribute( attributeName );\n\t\t\tconst attributeType = builder.getTypeFromAttribute( attribute );\n\n\t\t\tconst nodeAttribute = builder.getAttribute( attributeName, attributeType );\n\n\t\t\tif ( builder.shaderStage === 'vertex' ) {\n\n\t\t\t\treturn builder.format( nodeAttribute.name, attributeType, nodeType );\n\n\t\t\t} else {\n\n\t\t\t\tconst nodeVarying = varying( this );\n\n\t\t\t\treturn nodeVarying.build( builder, nodeType );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( `AttributeNode: Vertex attribute \"${ attributeName }\" not found on geometry.` );\n\n\t\t\tconst { defaultNode } = this;\n\n\t\t\tif ( defaultNode !== null ) {\n\n\t\t\t\treturn defaultNode.build( builder, nodeType );\n\n\t\t\t} else {\n\n\t\t\t\treturn builder.generateConst( nodeType );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nexport default AttributeNode;\n\nexport const attribute = ( name, nodeType, defaultNode ) => nodeObject( new AttributeNode( name, nodeType, nodeObject( defaultNode ) ) );\n\naddNodeClass( 'AttributeNode', AttributeNode );\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}