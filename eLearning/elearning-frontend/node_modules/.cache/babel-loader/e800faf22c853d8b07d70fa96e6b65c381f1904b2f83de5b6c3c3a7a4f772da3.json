{"ast":null,"code":"import NodeMaterial from '../../../nodes/materials/NodeMaterial.js';\nimport { getDirection, blur } from '../../../nodes/pmrem/PMREMUtils.js';\nimport { equirectUV } from '../../../nodes/utils/EquirectUVNode.js';\nimport { uniform } from '../../../nodes/core/UniformNode.js';\nimport { uniforms } from '../../../nodes/accessors/UniformsNode.js';\nimport { texture } from '../../../nodes/accessors/TextureNode.js';\nimport { cubeTexture } from '../../../nodes/accessors/CubeTextureNode.js';\nimport { float, vec3 } from '../../../nodes/shadernode/ShaderNode.js';\nimport { uv } from '../../../nodes/accessors/UVNode.js';\nimport { attribute } from '../../../nodes/core/AttributeNode.js';\nimport { OrthographicCamera, Color, Vector3, BufferGeometry, BufferAttribute, RenderTarget, Mesh, CubeReflectionMapping, CubeRefractionMapping, CubeUVReflectionMapping, LinearFilter, NoBlending, RGBAFormat, HalfFloatType, BackSide, LinearSRGBColorSpace, PerspectiveCamera, MeshBasicMaterial, BoxGeometry } from 'three';\nconst LOD_MIN = 4;\n\n// The standard deviations (radians) associated with the extra mips. These are\n// chosen to approximate a Trowbridge-Reitz distribution function times the\n// geometric shadowing function. These sigma values squared must match the\n// variance #defines in cube_uv_reflection_fragment.glsl.js.\nconst EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];\n\n// The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\nconst MAX_SAMPLES = 20;\nconst _flatCamera = /*@__PURE__*/new OrthographicCamera(-1, 1, 1, -1, 0, 1);\nconst _cubeCamera = /*@__PURE__*/new PerspectiveCamera(90, 1);\nconst _clearColor = /*@__PURE__*/new Color();\nlet _oldTarget = null;\nlet _oldActiveCubeFace = 0;\nlet _oldActiveMipmapLevel = 0;\n\n// Golden Ratio\nconst PHI = (1 + Math.sqrt(5)) / 2;\nconst INV_PHI = 1 / PHI;\n\n// Vertices of a dodecahedron (except the opposites, which represent the\n// same axis), used as axis directions evenly spread on a sphere.\nconst _axisDirections = [/*@__PURE__*/new Vector3(-PHI, INV_PHI, 0), /*@__PURE__*/new Vector3(PHI, INV_PHI, 0), /*@__PURE__*/new Vector3(-INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(0, PHI, -INV_PHI), /*@__PURE__*/new Vector3(0, PHI, INV_PHI), /*@__PURE__*/new Vector3(-1, 1, -1), /*@__PURE__*/new Vector3(1, 1, -1), /*@__PURE__*/new Vector3(-1, 1, 1), /*@__PURE__*/new Vector3(1, 1, 1)];\n\n//\n\n// WebGPU Face indices\nconst _faceLib = [3, 1, 5, 0, 4, 2];\nconst direction = getDirection(uv(), attribute('faceIndex')).normalize();\nconst outputDirection = vec3(direction.x, direction.y.negate(), direction.z);\n\n/**\n * This class generates a Prefiltered, Mipmapped Radiance Environment Map\n * (PMREM) from a cubeMap environment texture. This allows different levels of\n * blur to be quickly accessed based on material roughness. It is packed into a\n * special CubeUV format that allows us to perform custom interpolation so that\n * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\n * chain, it only goes down to the LOD_MIN level (above), and then creates extra\n * even more filtered 'mips' at the same LOD_MIN resolution, associated with\n * higher roughness levels. In this way we maintain resolution to smoothly\n * interpolate diffuse lighting while limiting sampling computation.\n *\n * Paper: Fast, Accurate Image-Based Lighting\n * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view\n*/\n\nclass PMREMGenerator {\n  constructor(renderer) {\n    this._renderer = renderer;\n    this._pingPongRenderTarget = null;\n    this._lodMax = 0;\n    this._cubeSize = 0;\n    this._lodPlanes = [];\n    this._sizeLods = [];\n    this._sigmas = [];\n    this._lodMeshes = [];\n    this._blurMaterial = null;\n    this._cubemapMaterial = null;\n    this._equirectMaterial = null;\n    this._backgroundBox = null;\n  }\n\n  /**\n   * Generates a PMREM from a supplied Scene, which can be faster than using an\n   * image if networking bandwidth is low. Optional sigma specifies a blur radius\n   * in radians to be applied to the scene before PMREM generation. Optional near\n   * and far planes ensure the scene is rendered in its entirety (the cubeCamera\n   * is placed at the origin).\n   */\n  fromScene(scene, sigma = 0, near = 0.1, far = 100) {\n    _oldTarget = this._renderer.getRenderTarget();\n    _oldActiveCubeFace = this._renderer.getActiveCubeFace();\n    _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();\n    this._setSize(256);\n    const cubeUVRenderTarget = this._allocateTargets();\n    cubeUVRenderTarget.depthBuffer = true;\n    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);\n    if (sigma > 0) {\n      this._blur(cubeUVRenderTarget, 0, 0, sigma);\n    }\n    this._applyPMREM(cubeUVRenderTarget);\n    this._cleanup(cubeUVRenderTarget);\n    return cubeUVRenderTarget;\n  }\n\n  /**\n   * Generates a PMREM from an equirectangular texture, which can be either LDR\n   * or HDR. The ideal input image size is 1k (1024 x 512),\n   * as this matches best with the 256 x 256 cubemap output.\n   */\n  fromEquirectangular(equirectangular, renderTarget = null) {\n    return this._fromTexture(equirectangular, renderTarget);\n  }\n\n  /**\n   * Generates a PMREM from an cubemap texture, which can be either LDR\n   * or HDR. The ideal input cube size is 256 x 256,\n   * as this matches best with the 256 x 256 cubemap output.\n   */\n  fromCubemap(cubemap, renderTarget = null) {\n    return this._fromTexture(cubemap, renderTarget);\n  }\n\n  /**\n   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\n   * your texture's network fetch for increased concurrency.\n   */\n  compileCubemapShader() {\n    if (this._cubemapMaterial === null) {\n      this._cubemapMaterial = _getCubemapMaterial();\n      this._compileMaterial(this._cubemapMaterial);\n    }\n  }\n\n  /**\n   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\n   * your texture's network fetch for increased concurrency.\n   */\n  compileEquirectangularShader() {\n    if (this._equirectMaterial === null) {\n      this._equirectMaterial = _getEquirectMaterial();\n      this._compileMaterial(this._equirectMaterial);\n    }\n  }\n\n  /**\n   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\n   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\n   * one of them will cause any others to also become unusable.\n   */\n  dispose() {\n    this._dispose();\n    if (this._cubemapMaterial !== null) this._cubemapMaterial.dispose();\n    if (this._equirectMaterial !== null) this._equirectMaterial.dispose();\n    if (this._backgroundBox !== null) {\n      this._backgroundBox.geometry.dispose();\n      this._backgroundBox.material.dispose();\n    }\n  }\n\n  // private interface\n\n  _setSize(cubeSize) {\n    this._lodMax = Math.floor(Math.log2(cubeSize));\n    this._cubeSize = Math.pow(2, this._lodMax);\n  }\n  _dispose() {\n    if (this._blurMaterial !== null) this._blurMaterial.dispose();\n    if (this._pingPongRenderTarget !== null) this._pingPongRenderTarget.dispose();\n    for (let i = 0; i < this._lodPlanes.length; i++) {\n      this._lodPlanes[i].dispose();\n    }\n  }\n  _cleanup(outputTarget) {\n    this._renderer.setRenderTarget(_oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel);\n    outputTarget.scissorTest = false;\n    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);\n  }\n  _fromTexture(texture, renderTarget) {\n    if (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping) {\n      this._setSize(texture.image.length === 0 ? 16 : texture.image[0].width || texture.image[0].image.width);\n    } else {\n      // Equirectangular\n\n      this._setSize(texture.image.width / 4);\n    }\n    _oldTarget = this._renderer.getRenderTarget();\n    _oldActiveCubeFace = this._renderer.getActiveCubeFace();\n    _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();\n    const cubeUVRenderTarget = renderTarget || this._allocateTargets();\n    this._textureToCubeUV(texture, cubeUVRenderTarget);\n    this._applyPMREM(cubeUVRenderTarget);\n    this._cleanup(cubeUVRenderTarget);\n    return cubeUVRenderTarget;\n  }\n  _allocateTargets() {\n    const width = 3 * Math.max(this._cubeSize, 16 * 7);\n    const height = 4 * this._cubeSize;\n    const params = {\n      magFilter: LinearFilter,\n      minFilter: LinearFilter,\n      generateMipmaps: false,\n      type: HalfFloatType,\n      format: RGBAFormat,\n      colorSpace: LinearSRGBColorSpace\n      //depthBuffer: false\n    };\n\n    const cubeUVRenderTarget = _createRenderTarget(width, height, params);\n    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height) {\n      if (this._pingPongRenderTarget !== null) {\n        this._dispose();\n      }\n      this._pingPongRenderTarget = _createRenderTarget(width, height, params);\n      const {\n        _lodMax\n      } = this;\n      ({\n        sizeLods: this._sizeLods,\n        lodPlanes: this._lodPlanes,\n        sigmas: this._sigmas,\n        lodMeshes: this._lodMeshes\n      } = _createPlanes(_lodMax));\n      this._blurMaterial = _getBlurShader(_lodMax, width, height);\n    }\n    return cubeUVRenderTarget;\n  }\n  _compileMaterial(material) {\n    const tmpMesh = this._lodMeshes[0];\n    tmpMesh.material = material;\n    this._renderer.compile(tmpMesh, _flatCamera);\n  }\n  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {\n    const cubeCamera = _cubeCamera;\n    cubeCamera.near = near;\n    cubeCamera.far = far;\n\n    // px, py, pz, nx, ny, nz\n    const upSign = [-1, 1, -1, -1, -1, -1];\n    const forwardSign = [1, 1, 1, -1, -1, -1];\n    const renderer = this._renderer;\n    const originalAutoClear = renderer.autoClear;\n    renderer.getClearColor(_clearColor);\n    renderer.autoClear = false;\n    let backgroundBox = this._backgroundBox;\n    if (backgroundBox === null) {\n      const backgroundMaterial = new MeshBasicMaterial({\n        name: 'PMREM.Background',\n        side: BackSide,\n        depthWrite: false,\n        depthTest: false\n      });\n      backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);\n    }\n    let useSolidColor = false;\n    const background = scene.background;\n    if (background) {\n      if (background.isColor) {\n        backgroundBox.material.color.copy(background);\n        scene.background = null;\n        useSolidColor = true;\n      }\n    } else {\n      backgroundBox.material.color.copy(_clearColor);\n      useSolidColor = true;\n    }\n    renderer.setRenderTarget(cubeUVRenderTarget);\n    renderer.clear();\n    if (useSolidColor) {\n      renderer.render(backgroundBox, cubeCamera);\n    }\n    for (let i = 0; i < 6; i++) {\n      const col = i % 3;\n      if (col === 0) {\n        cubeCamera.up.set(0, upSign[i], 0);\n        cubeCamera.lookAt(forwardSign[i], 0, 0);\n      } else if (col === 1) {\n        cubeCamera.up.set(0, 0, upSign[i]);\n        cubeCamera.lookAt(0, forwardSign[i], 0);\n      } else {\n        cubeCamera.up.set(0, upSign[i], 0);\n        cubeCamera.lookAt(0, 0, forwardSign[i]);\n      }\n      const size = this._cubeSize;\n      _setViewport(cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size);\n      renderer.render(scene, cubeCamera);\n    }\n    renderer.autoClear = originalAutoClear;\n    scene.background = background;\n  }\n  _textureToCubeUV(texture, cubeUVRenderTarget) {\n    const renderer = this._renderer;\n    const isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;\n    if (isCubeTexture) {\n      if (this._cubemapMaterial === null) {\n        this._cubemapMaterial = _getCubemapMaterial(texture);\n      }\n    } else {\n      if (this._equirectMaterial === null) {\n        this._equirectMaterial = _getEquirectMaterial(texture);\n      }\n    }\n    const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;\n    material.fragmentNode.value = texture;\n    const mesh = this._lodMeshes[0];\n    mesh.material = material;\n    const size = this._cubeSize;\n    _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);\n    renderer.setRenderTarget(cubeUVRenderTarget);\n    renderer.render(mesh, _flatCamera);\n  }\n  _applyPMREM(cubeUVRenderTarget) {\n    const renderer = this._renderer;\n    const autoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    const n = this._lodPlanes.length;\n    for (let i = 1; i < n; i++) {\n      const sigma = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]);\n      const poleAxis = _axisDirections[(n - i - 1) % _axisDirections.length];\n      this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);\n    }\n    renderer.autoClear = autoClear;\n  }\n\n  /**\n   * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n   * vertically and horizontally, but this breaks down on a cube. Here we apply\n   * the blur latitudinally (around the poles), and then longitudinally (towards\n   * the poles) to approximate the orthogonally-separable blur. It is least\n   * accurate at the poles, but still does a decent job.\n   */\n  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {\n    const pingPongRenderTarget = this._pingPongRenderTarget;\n    this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);\n    this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);\n  }\n  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {\n    const renderer = this._renderer;\n    const blurMaterial = this._blurMaterial;\n    if (direction !== 'latitudinal' && direction !== 'longitudinal') {\n      console.error('blur direction must be either latitudinal or longitudinal!');\n    }\n\n    // Number of standard deviations at which to cut off the discrete approximation.\n    const STANDARD_DEVIATIONS = 3;\n    const blurMesh = this._lodMeshes[lodOut];\n    blurMesh.material = blurMaterial;\n    const blurUniforms = blurMaterial.uniforms;\n    const pixels = this._sizeLods[lodIn] - 1;\n    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);\n    const sigmaPixels = sigmaRadians / radiansPerPixel;\n    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;\n    if (samples > MAX_SAMPLES) {\n      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);\n    }\n    const weights = [];\n    let sum = 0;\n    for (let i = 0; i < MAX_SAMPLES; ++i) {\n      const x = i / sigmaPixels;\n      const weight = Math.exp(-x * x / 2);\n      weights.push(weight);\n      if (i === 0) {\n        sum += weight;\n      } else if (i < samples) {\n        sum += 2 * weight;\n      }\n    }\n    for (let i = 0; i < weights.length; i++) {\n      weights[i] = weights[i] / sum;\n    }\n    targetIn.texture.frame = (targetIn.texture.frame || 0) + 1;\n    blurUniforms.envMap.value = targetIn.texture;\n    blurUniforms.samples.value = samples;\n    blurUniforms.weights.array = weights;\n    blurUniforms.latitudinal.value = direction === 'latitudinal' ? 1 : 0;\n    if (poleAxis) {\n      blurUniforms.poleAxis.value = poleAxis;\n    }\n    const {\n      _lodMax\n    } = this;\n    blurUniforms.dTheta.value = radiansPerPixel;\n    blurUniforms.mipInt.value = _lodMax - lodIn;\n    const outputSize = this._sizeLods[lodOut];\n    const x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);\n    const y = 4 * (this._cubeSize - outputSize);\n    _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);\n    renderer.setRenderTarget(targetOut);\n    renderer.render(blurMesh, _flatCamera);\n  }\n}\nfunction _createPlanes(lodMax) {\n  const lodPlanes = [];\n  const sizeLods = [];\n  const sigmas = [];\n  const lodMeshes = [];\n  let lod = lodMax;\n  const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;\n  for (let i = 0; i < totalLods; i++) {\n    const sizeLod = Math.pow(2, lod);\n    sizeLods.push(sizeLod);\n    let sigma = 1.0 / sizeLod;\n    if (i > lodMax - LOD_MIN) {\n      sigma = EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - 1];\n    } else if (i === 0) {\n      sigma = 0;\n    }\n    sigmas.push(sigma);\n    const texelSize = 1.0 / (sizeLod - 2);\n    const min = -texelSize;\n    const max = 1 + texelSize;\n    const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];\n    const cubeFaces = 6;\n    const vertices = 6;\n    const positionSize = 3;\n    const uvSize = 2;\n    const faceIndexSize = 1;\n    const position = new Float32Array(positionSize * vertices * cubeFaces);\n    const uv = new Float32Array(uvSize * vertices * cubeFaces);\n    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);\n    for (let face = 0; face < cubeFaces; face++) {\n      const x = face % 3 * 2 / 3 - 1;\n      const y = face > 2 ? 0 : -1;\n      const coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];\n      const faceIdx = _faceLib[face];\n      position.set(coordinates, positionSize * vertices * faceIdx);\n      uv.set(uv1, uvSize * vertices * faceIdx);\n      const fill = [faceIdx, faceIdx, faceIdx, faceIdx, faceIdx, faceIdx];\n      faceIndex.set(fill, faceIndexSize * vertices * faceIdx);\n    }\n    const planes = new BufferGeometry();\n    planes.setAttribute('position', new BufferAttribute(position, positionSize));\n    planes.setAttribute('uv', new BufferAttribute(uv, uvSize));\n    planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));\n    lodPlanes.push(planes);\n    lodMeshes.push(new Mesh(planes, null));\n    if (lod > LOD_MIN) {\n      lod--;\n    }\n  }\n  return {\n    lodPlanes,\n    sizeLods,\n    sigmas,\n    lodMeshes\n  };\n}\nfunction _createRenderTarget(width, height, params) {\n  const cubeUVRenderTarget = new RenderTarget(width, height, params);\n  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n  cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';\n  cubeUVRenderTarget.texture.isPMREMTexture = true;\n  cubeUVRenderTarget.scissorTest = true;\n  return cubeUVRenderTarget;\n}\nfunction _setViewport(target, x, y, width, height) {\n  const viewY = target.height - height - y;\n  target.viewport.set(x, viewY, width, height);\n  target.scissor.set(x, viewY, width, height);\n}\nfunction _getMaterial() {\n  const material = new NodeMaterial();\n  material.depthTest = false;\n  material.depthWrite = false;\n  material.blending = NoBlending;\n  return material;\n}\nfunction _getBlurShader(lodMax, width, height) {\n  const weights = uniforms(new Array(MAX_SAMPLES).fill(0));\n  const poleAxis = uniform(new Vector3(0, 1, 0));\n  const dTheta = uniform(0);\n  const n = float(MAX_SAMPLES);\n  const latitudinal = uniform(0); // false, bool\n  const samples = uniform(1); // int\n  const envMap = texture(null);\n  const mipInt = uniform(0); // int\n  const CUBEUV_TEXEL_WIDTH = float(1 / width);\n  const CUBEUV_TEXEL_HEIGHT = float(1 / height);\n  const CUBEUV_MAX_MIP = float(lodMax);\n  const materialUniforms = {\n    n,\n    latitudinal,\n    weights,\n    poleAxis,\n    outputDirection,\n    dTheta,\n    samples,\n    envMap,\n    mipInt,\n    CUBEUV_TEXEL_WIDTH,\n    CUBEUV_TEXEL_HEIGHT,\n    CUBEUV_MAX_MIP\n  };\n  const material = _getMaterial();\n  material.uniforms = materialUniforms; // TODO: Move to outside of the material\n  material.fragmentNode = blur({\n    ...materialUniforms,\n    latitudinal: latitudinal.equal(1)\n  });\n  return material;\n}\nfunction _getCubemapMaterial(envTexture) {\n  const material = _getMaterial();\n  material.fragmentNode = cubeTexture(envTexture, outputDirection);\n  return material;\n}\nfunction _getEquirectMaterial(envTexture) {\n  const material = _getMaterial();\n  material.fragmentNode = texture(envTexture, equirectUV(outputDirection), 0);\n  return material;\n}\nexport default PMREMGenerator;","map":{"version":3,"names":["NodeMaterial","getDirection","blur","equirectUV","uniform","uniforms","texture","cubeTexture","float","vec3","uv","attribute","OrthographicCamera","Color","Vector3","BufferGeometry","BufferAttribute","RenderTarget","Mesh","CubeReflectionMapping","CubeRefractionMapping","CubeUVReflectionMapping","LinearFilter","NoBlending","RGBAFormat","HalfFloatType","BackSide","LinearSRGBColorSpace","PerspectiveCamera","MeshBasicMaterial","BoxGeometry","LOD_MIN","EXTRA_LOD_SIGMA","MAX_SAMPLES","_flatCamera","_cubeCamera","_clearColor","_oldTarget","_oldActiveCubeFace","_oldActiveMipmapLevel","PHI","Math","sqrt","INV_PHI","_axisDirections","_faceLib","direction","normalize","outputDirection","x","y","negate","z","PMREMGenerator","constructor","renderer","_renderer","_pingPongRenderTarget","_lodMax","_cubeSize","_lodPlanes","_sizeLods","_sigmas","_lodMeshes","_blurMaterial","_cubemapMaterial","_equirectMaterial","_backgroundBox","fromScene","scene","sigma","near","far","getRenderTarget","getActiveCubeFace","getActiveMipmapLevel","_setSize","cubeUVRenderTarget","_allocateTargets","depthBuffer","_sceneToCubeUV","_blur","_applyPMREM","_cleanup","fromEquirectangular","equirectangular","renderTarget","_fromTexture","fromCubemap","cubemap","compileCubemapShader","_getCubemapMaterial","_compileMaterial","compileEquirectangularShader","_getEquirectMaterial","dispose","_dispose","geometry","material","cubeSize","floor","log2","pow","i","length","outputTarget","setRenderTarget","scissorTest","_setViewport","width","height","mapping","image","_textureToCubeUV","max","params","magFilter","minFilter","generateMipmaps","type","format","colorSpace","_createRenderTarget","sizeLods","lodPlanes","sigmas","lodMeshes","_createPlanes","_getBlurShader","tmpMesh","compile","cubeCamera","upSign","forwardSign","originalAutoClear","autoClear","getClearColor","backgroundBox","backgroundMaterial","name","side","depthWrite","depthTest","useSolidColor","background","isColor","color","copy","clear","render","col","up","set","lookAt","size","isCubeTexture","fragmentNode","value","mesh","n","poleAxis","lodIn","lodOut","pingPongRenderTarget","_halfBlur","targetIn","targetOut","sigmaRadians","blurMaterial","console","error","STANDARD_DEVIATIONS","blurMesh","blurUniforms","pixels","radiansPerPixel","isFinite","PI","sigmaPixels","samples","warn","weights","sum","weight","exp","push","frame","envMap","array","latitudinal","dTheta","mipInt","outputSize","lodMax","lod","totalLods","sizeLod","texelSize","min","uv1","cubeFaces","vertices","positionSize","uvSize","faceIndexSize","position","Float32Array","faceIndex","face","coordinates","faceIdx","fill","planes","setAttribute","isPMREMTexture","target","viewY","viewport","scissor","_getMaterial","blending","Array","CUBEUV_TEXEL_WIDTH","CUBEUV_TEXEL_HEIGHT","CUBEUV_MAX_MIP","materialUniforms","equal","envTexture"],"sources":["D:/dumps/online-learning-platform-main/Frontend/node_modules/three/examples/jsm/renderers/common/extras/PMREMGenerator.js"],"sourcesContent":["import NodeMaterial from '../../../nodes/materials/NodeMaterial.js';\nimport { getDirection, blur } from '../../../nodes/pmrem/PMREMUtils.js';\nimport { equirectUV } from '../../../nodes/utils/EquirectUVNode.js';\nimport { uniform } from '../../../nodes/core/UniformNode.js';\nimport { uniforms } from '../../../nodes/accessors/UniformsNode.js';\nimport { texture } from '../../../nodes/accessors/TextureNode.js';\nimport { cubeTexture } from '../../../nodes/accessors/CubeTextureNode.js';\nimport { float, vec3 } from '../../../nodes/shadernode/ShaderNode.js';\nimport { uv } from '../../../nodes/accessors/UVNode.js';\nimport { attribute } from '../../../nodes/core/AttributeNode.js';\nimport {\n\tOrthographicCamera,\n\tColor,\n\tVector3,\n\tBufferGeometry,\n\tBufferAttribute,\n\tRenderTarget,\n\tMesh,\n\tCubeReflectionMapping,\n\tCubeRefractionMapping,\n\tCubeUVReflectionMapping,\n\tLinearFilter,\n\tNoBlending,\n\tRGBAFormat,\n\tHalfFloatType,\n\tBackSide,\n\tLinearSRGBColorSpace,\n\tPerspectiveCamera,\n\tMeshBasicMaterial,\n\tBoxGeometry\n} from 'three';\n\nconst LOD_MIN = 4;\n\n// The standard deviations (radians) associated with the extra mips. These are\n// chosen to approximate a Trowbridge-Reitz distribution function times the\n// geometric shadowing function. These sigma values squared must match the\n// variance #defines in cube_uv_reflection_fragment.glsl.js.\nconst EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];\n\n// The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\nconst MAX_SAMPLES = 20;\n\nconst _flatCamera = /*@__PURE__*/ new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\nconst _cubeCamera = /*@__PURE__*/ new PerspectiveCamera( 90, 1 );\nconst _clearColor = /*@__PURE__*/ new Color();\nlet _oldTarget = null;\nlet _oldActiveCubeFace = 0;\nlet _oldActiveMipmapLevel = 0;\n\n// Golden Ratio\nconst PHI = ( 1 + Math.sqrt( 5 ) ) / 2;\nconst INV_PHI = 1 / PHI;\n\n// Vertices of a dodecahedron (except the opposites, which represent the\n// same axis), used as axis directions evenly spread on a sphere.\nconst _axisDirections = [\n\t/*@__PURE__*/ new Vector3( - PHI, INV_PHI, 0 ),\n\t/*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ),\n\t/*@__PURE__*/ new Vector3( - INV_PHI, 0, PHI ),\n\t/*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ),\n\t/*@__PURE__*/ new Vector3( 0, PHI, - INV_PHI ),\n\t/*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ),\n\t/*@__PURE__*/ new Vector3( - 1, 1, - 1 ),\n\t/*@__PURE__*/ new Vector3( 1, 1, - 1 ),\n\t/*@__PURE__*/ new Vector3( - 1, 1, 1 ),\n\t/*@__PURE__*/ new Vector3( 1, 1, 1 )\n];\n\n//\n\n// WebGPU Face indices\nconst _faceLib = [\n\t3, 1, 5,\n\t0, 4, 2\n];\n\nconst direction = getDirection( uv(), attribute( 'faceIndex' ) ).normalize();\nconst outputDirection = vec3( direction.x, direction.y.negate(), direction.z );\n\n/**\n * This class generates a Prefiltered, Mipmapped Radiance Environment Map\n * (PMREM) from a cubeMap environment texture. This allows different levels of\n * blur to be quickly accessed based on material roughness. It is packed into a\n * special CubeUV format that allows us to perform custom interpolation so that\n * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\n * chain, it only goes down to the LOD_MIN level (above), and then creates extra\n * even more filtered 'mips' at the same LOD_MIN resolution, associated with\n * higher roughness levels. In this way we maintain resolution to smoothly\n * interpolate diffuse lighting while limiting sampling computation.\n *\n * Paper: Fast, Accurate Image-Based Lighting\n * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view\n*/\n\nclass PMREMGenerator {\n\n\tconstructor( renderer ) {\n\n\t\tthis._renderer = renderer;\n\t\tthis._pingPongRenderTarget = null;\n\n\t\tthis._lodMax = 0;\n\t\tthis._cubeSize = 0;\n\t\tthis._lodPlanes = [];\n\t\tthis._sizeLods = [];\n\t\tthis._sigmas = [];\n\t\tthis._lodMeshes = [];\n\n\t\tthis._blurMaterial = null;\n\t\tthis._cubemapMaterial = null;\n\t\tthis._equirectMaterial = null;\n\t\tthis._backgroundBox = null;\n\n\t}\n\n\t/**\n\t * Generates a PMREM from a supplied Scene, which can be faster than using an\n\t * image if networking bandwidth is low. Optional sigma specifies a blur radius\n\t * in radians to be applied to the scene before PMREM generation. Optional near\n\t * and far planes ensure the scene is rendered in its entirety (the cubeCamera\n\t * is placed at the origin).\n\t */\n\tfromScene( scene, sigma = 0, near = 0.1, far = 100 ) {\n\n\t\t_oldTarget = this._renderer.getRenderTarget();\n\t\t_oldActiveCubeFace = this._renderer.getActiveCubeFace();\n\t\t_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();\n\n\t\tthis._setSize( 256 );\n\n\t\tconst cubeUVRenderTarget = this._allocateTargets();\n\t\tcubeUVRenderTarget.depthBuffer = true;\n\n\t\tthis._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );\n\n\t\tif ( sigma > 0 ) {\n\n\t\t\tthis._blur( cubeUVRenderTarget, 0, 0, sigma );\n\n\t\t}\n\n\t\tthis._applyPMREM( cubeUVRenderTarget );\n\n\t\tthis._cleanup( cubeUVRenderTarget );\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an equirectangular texture, which can be either LDR\n\t * or HDR. The ideal input image size is 1k (1024 x 512),\n\t * as this matches best with the 256 x 256 cubemap output.\n\t */\n\tfromEquirectangular( equirectangular, renderTarget = null ) {\n\n\t\treturn this._fromTexture( equirectangular, renderTarget );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an cubemap texture, which can be either LDR\n\t * or HDR. The ideal input cube size is 256 x 256,\n\t * as this matches best with the 256 x 256 cubemap output.\n\t */\n\tfromCubemap( cubemap, renderTarget = null ) {\n\n\t\treturn this._fromTexture( cubemap, renderTarget );\n\n\t}\n\n\t/**\n\t * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\n\t * your texture's network fetch for increased concurrency.\n\t */\n\tcompileCubemapShader() {\n\n\t\tif ( this._cubemapMaterial === null ) {\n\n\t\t\tthis._cubemapMaterial = _getCubemapMaterial();\n\t\t\tthis._compileMaterial( this._cubemapMaterial );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\n\t * your texture's network fetch for increased concurrency.\n\t */\n\tcompileEquirectangularShader() {\n\n\t\tif ( this._equirectMaterial === null ) {\n\n\t\t\tthis._equirectMaterial = _getEquirectMaterial();\n\t\t\tthis._compileMaterial( this._equirectMaterial );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\n\t * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\n\t * one of them will cause any others to also become unusable.\n\t */\n\tdispose() {\n\n\t\tthis._dispose();\n\n\t\tif ( this._cubemapMaterial !== null ) this._cubemapMaterial.dispose();\n\t\tif ( this._equirectMaterial !== null ) this._equirectMaterial.dispose();\n\t\tif ( this._backgroundBox !== null ) {\n\n\t\t\tthis._backgroundBox.geometry.dispose();\n\t\t\tthis._backgroundBox.material.dispose();\n\n\t\t}\n\n\t}\n\n\t// private interface\n\n\t_setSize( cubeSize ) {\n\n\t\tthis._lodMax = Math.floor( Math.log2( cubeSize ) );\n\t\tthis._cubeSize = Math.pow( 2, this._lodMax );\n\n\t}\n\n\t_dispose() {\n\n\t\tif ( this._blurMaterial !== null ) this._blurMaterial.dispose();\n\n\t\tif ( this._pingPongRenderTarget !== null ) this._pingPongRenderTarget.dispose();\n\n\t\tfor ( let i = 0; i < this._lodPlanes.length; i ++ ) {\n\n\t\t\tthis._lodPlanes[ i ].dispose();\n\n\t\t}\n\n\t}\n\n\t_cleanup( outputTarget ) {\n\n\t\tthis._renderer.setRenderTarget( _oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel );\n\t\toutputTarget.scissorTest = false;\n\t\t_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );\n\n\t}\n\n\t_fromTexture( texture, renderTarget ) {\n\n\t\tif ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping ) {\n\n\t\t\tthis._setSize( texture.image.length === 0 ? 16 : ( texture.image[ 0 ].width || texture.image[ 0 ].image.width ) );\n\n\t\t} else { // Equirectangular\n\n\t\t\tthis._setSize( texture.image.width / 4 );\n\n\t\t}\n\n\t\t_oldTarget = this._renderer.getRenderTarget();\n\t\t_oldActiveCubeFace = this._renderer.getActiveCubeFace();\n\t\t_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();\n\n\t\tconst cubeUVRenderTarget = renderTarget || this._allocateTargets();\n\t\tthis._textureToCubeUV( texture, cubeUVRenderTarget );\n\t\tthis._applyPMREM( cubeUVRenderTarget );\n\t\tthis._cleanup( cubeUVRenderTarget );\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t_allocateTargets() {\n\n\t\tconst width = 3 * Math.max( this._cubeSize, 16 * 7 );\n\t\tconst height = 4 * this._cubeSize;\n\n\t\tconst params = {\n\t\t\tmagFilter: LinearFilter,\n\t\t\tminFilter: LinearFilter,\n\t\t\tgenerateMipmaps: false,\n\t\t\ttype: HalfFloatType,\n\t\t\tformat: RGBAFormat,\n\t\t\tcolorSpace: LinearSRGBColorSpace,\n\t\t\t//depthBuffer: false\n\t\t};\n\n\t\tconst cubeUVRenderTarget = _createRenderTarget( width, height, params );\n\n\t\tif ( this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height ) {\n\n\t\t\tif ( this._pingPongRenderTarget !== null ) {\n\n\t\t\t\tthis._dispose();\n\n\t\t\t}\n\n\t\t\tthis._pingPongRenderTarget = _createRenderTarget( width, height, params );\n\n\t\t\tconst { _lodMax } = this;\n\t\t\t( { sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas, lodMeshes: this._lodMeshes } = _createPlanes( _lodMax ) );\n\n\t\t\tthis._blurMaterial = _getBlurShader( _lodMax, width, height );\n\n\t\t}\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t_compileMaterial( material ) {\n\n\t\tconst tmpMesh = this._lodMeshes[ 0 ];\n\t\ttmpMesh.material = material;\n\n\t\tthis._renderer.compile( tmpMesh, _flatCamera );\n\n\t}\n\n\t_sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {\n\n\t\tconst cubeCamera = _cubeCamera;\n\t\tcubeCamera.near = near;\n\t\tcubeCamera.far = far;\n\n\t\t// px, py, pz, nx, ny, nz\n\t\tconst upSign = [ - 1, 1, - 1, - 1, - 1, - 1 ];\n\t\tconst forwardSign = [ 1, 1, 1, - 1, - 1, - 1 ];\n\n\t\tconst renderer = this._renderer;\n\n\t\tconst originalAutoClear = renderer.autoClear;\n\n\t\trenderer.getClearColor( _clearColor );\n\n\t\trenderer.autoClear = false;\n\n\t\tlet backgroundBox = this._backgroundBox;\n\n\t\tif ( backgroundBox === null ) {\n\n\t\t\tconst backgroundMaterial = new MeshBasicMaterial( {\n\t\t\t\tname: 'PMREM.Background',\n\t\t\t\tside: BackSide,\n\t\t\t\tdepthWrite: false,\n\t\t\t\tdepthTest: false\n\t\t\t} );\n\n\t\t\tbackgroundBox = new Mesh( new BoxGeometry(), backgroundMaterial );\n\n\t\t}\n\n\t\tlet useSolidColor = false;\n\t\tconst background = scene.background;\n\n\t\tif ( background ) {\n\n\t\t\tif ( background.isColor ) {\n\n\t\t\t\tbackgroundBox.material.color.copy( background );\n\t\t\t\tscene.background = null;\n\t\t\t\tuseSolidColor = true;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tbackgroundBox.material.color.copy( _clearColor );\n\t\t\tuseSolidColor = true;\n\n\t\t}\n\n\t\trenderer.setRenderTarget( cubeUVRenderTarget );\n\n\t\trenderer.clear();\n\n\t\tif ( useSolidColor ) {\n\n\t\t\trenderer.render( backgroundBox, cubeCamera );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst col = i % 3;\n\n\t\t\tif ( col === 0 ) {\n\n\t\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\n\t\t\t\tcubeCamera.lookAt( forwardSign[ i ], 0, 0 );\n\n\t\t\t} else if ( col === 1 ) {\n\n\t\t\t\tcubeCamera.up.set( 0, 0, upSign[ i ] );\n\t\t\t\tcubeCamera.lookAt( 0, forwardSign[ i ], 0 );\n\n\t\t\t} else {\n\n\t\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\n\t\t\t\tcubeCamera.lookAt( 0, 0, forwardSign[ i ] );\n\n\t\t\t}\n\n\t\t\tconst size = this._cubeSize;\n\n\t\t\t_setViewport( cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size );\n\n\t\t\trenderer.render( scene, cubeCamera );\n\n\t\t}\n\n\t\trenderer.autoClear = originalAutoClear;\n\t\tscene.background = background;\n\n\t}\n\n\t_textureToCubeUV( texture, cubeUVRenderTarget ) {\n\n\t\tconst renderer = this._renderer;\n\n\t\tconst isCubeTexture = ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping );\n\n\t\tif ( isCubeTexture ) {\n\n\t\t\tif ( this._cubemapMaterial === null ) {\n\n\t\t\t\tthis._cubemapMaterial = _getCubemapMaterial( texture );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this._equirectMaterial === null ) {\n\n\t\t\t\tthis._equirectMaterial = _getEquirectMaterial( texture );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;\n\t\tmaterial.fragmentNode.value = texture;\n\n\t\tconst mesh = this._lodMeshes[ 0 ];\n\t\tmesh.material = material;\n\n\t\tconst size = this._cubeSize;\n\n\t\t_setViewport( cubeUVRenderTarget, 0, 0, 3 * size, 2 * size );\n\n\t\trenderer.setRenderTarget( cubeUVRenderTarget );\n\t\trenderer.render( mesh, _flatCamera );\n\n\t}\n\n\t_applyPMREM( cubeUVRenderTarget ) {\n\n\t\tconst renderer = this._renderer;\n\t\tconst autoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\t\tconst n = this._lodPlanes.length;\n\n\t\tfor ( let i = 1; i < n; i ++ ) {\n\n\t\t\tconst sigma = Math.sqrt( this._sigmas[ i ] * this._sigmas[ i ] - this._sigmas[ i - 1 ] * this._sigmas[ i - 1 ] );\n\n\t\t\tconst poleAxis = _axisDirections[ ( n - i - 1 ) % _axisDirections.length ];\n\n\t\t\tthis._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );\n\n\t\t}\n\n\t\trenderer.autoClear = autoClear;\n\n\t}\n\n\t/**\n\t * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n\t * vertically and horizontally, but this breaks down on a cube. Here we apply\n\t * the blur latitudinally (around the poles), and then longitudinally (towards\n\t * the poles) to approximate the orthogonally-separable blur. It is least\n\t * accurate at the poles, but still does a decent job.\n\t */\n\t_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {\n\n\t\tconst pingPongRenderTarget = this._pingPongRenderTarget;\n\n\t\tthis._halfBlur(\n\t\t\tcubeUVRenderTarget,\n\t\t\tpingPongRenderTarget,\n\t\t\tlodIn,\n\t\t\tlodOut,\n\t\t\tsigma,\n\t\t\t'latitudinal',\n\t\t\tpoleAxis );\n\n\t\tthis._halfBlur(\n\t\t\tpingPongRenderTarget,\n\t\t\tcubeUVRenderTarget,\n\t\t\tlodOut,\n\t\t\tlodOut,\n\t\t\tsigma,\n\t\t\t'longitudinal',\n\t\t\tpoleAxis );\n\n\t}\n\n\t_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {\n\n\t\tconst renderer = this._renderer;\n\t\tconst blurMaterial = this._blurMaterial;\n\n\t\tif ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {\n\n\t\t\tconsole.error( 'blur direction must be either latitudinal or longitudinal!' );\n\n\t\t}\n\n\t\t// Number of standard deviations at which to cut off the discrete approximation.\n\t\tconst STANDARD_DEVIATIONS = 3;\n\n\t\tconst blurMesh = this._lodMeshes[ lodOut ];\n\t\tblurMesh.material = blurMaterial;\n\n\t\tconst blurUniforms = blurMaterial.uniforms;\n\n\t\tconst pixels = this._sizeLods[ lodIn ] - 1;\n\t\tconst radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );\n\t\tconst sigmaPixels = sigmaRadians / radiansPerPixel;\n\t\tconst samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;\n\n\t\tif ( samples > MAX_SAMPLES ) {\n\n\t\t\tconsole.warn( `sigmaRadians, ${\n\t\t\t\tsigmaRadians}, is too large and will clip, as it requested ${\n\t\t\t\tsamples} samples when the maximum is set to ${MAX_SAMPLES}` );\n\n\t\t}\n\n\t\tconst weights = [];\n\t\tlet sum = 0;\n\n\t\tfor ( let i = 0; i < MAX_SAMPLES; ++ i ) {\n\n\t\t\tconst x = i / sigmaPixels;\n\t\t\tconst weight = Math.exp( - x * x / 2 );\n\t\t\tweights.push( weight );\n\n\t\t\tif ( i === 0 ) {\n\n\t\t\t\tsum += weight;\n\n\t\t\t} else if ( i < samples ) {\n\n\t\t\t\tsum += 2 * weight;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < weights.length; i ++ ) {\n\n\t\t\tweights[ i ] = weights[ i ] / sum;\n\n\t\t}\n\n\t\ttargetIn.texture.frame = ( targetIn.texture.frame || 0 ) + 1;\n\n\t\tblurUniforms.envMap.value = targetIn.texture;\n\t\tblurUniforms.samples.value = samples;\n\t\tblurUniforms.weights.array = weights;\n\t\tblurUniforms.latitudinal.value = direction === 'latitudinal' ? 1 : 0;\n\n\t\tif ( poleAxis ) {\n\n\t\t\tblurUniforms.poleAxis.value = poleAxis;\n\n\t\t}\n\n\t\tconst { _lodMax } = this;\n\t\tblurUniforms.dTheta.value = radiansPerPixel;\n\t\tblurUniforms.mipInt.value = _lodMax - lodIn;\n\n\t\tconst outputSize = this._sizeLods[ lodOut ];\n\t\tconst x = 3 * outputSize * ( lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0 );\n\t\tconst y = 4 * ( this._cubeSize - outputSize );\n\n\t\t_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );\n\t\trenderer.setRenderTarget( targetOut );\n\t\trenderer.render( blurMesh, _flatCamera );\n\n\t}\n\n}\n\nfunction _createPlanes( lodMax ) {\n\n\tconst lodPlanes = [];\n\tconst sizeLods = [];\n\tconst sigmas = [];\n\tconst lodMeshes = [];\n\n\tlet lod = lodMax;\n\n\tconst totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;\n\n\tfor ( let i = 0; i < totalLods; i ++ ) {\n\n\t\tconst sizeLod = Math.pow( 2, lod );\n\t\tsizeLods.push( sizeLod );\n\t\tlet sigma = 1.0 / sizeLod;\n\n\t\tif ( i > lodMax - LOD_MIN ) {\n\n\t\t\tsigma = EXTRA_LOD_SIGMA[ i - lodMax + LOD_MIN - 1 ];\n\n\t\t} else if ( i === 0 ) {\n\n\t\t\tsigma = 0;\n\n\t\t}\n\n\t\tsigmas.push( sigma );\n\n\t\tconst texelSize = 1.0 / ( sizeLod - 2 );\n\t\tconst min = - texelSize;\n\t\tconst max = 1 + texelSize;\n\t\tconst uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];\n\n\t\tconst cubeFaces = 6;\n\t\tconst vertices = 6;\n\t\tconst positionSize = 3;\n\t\tconst uvSize = 2;\n\t\tconst faceIndexSize = 1;\n\n\t\tconst position = new Float32Array( positionSize * vertices * cubeFaces );\n\t\tconst uv = new Float32Array( uvSize * vertices * cubeFaces );\n\t\tconst faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );\n\n\t\tfor ( let face = 0; face < cubeFaces; face ++ ) {\n\n\t\t\tconst x = ( face % 3 ) * 2 / 3 - 1;\n\t\t\tconst y = face > 2 ? 0 : - 1;\n\t\t\tconst coordinates = [\n\t\t\t\tx, y, 0,\n\t\t\t\tx + 2 / 3, y, 0,\n\t\t\t\tx + 2 / 3, y + 1, 0,\n\t\t\t\tx, y, 0,\n\t\t\t\tx + 2 / 3, y + 1, 0,\n\t\t\t\tx, y + 1, 0\n\t\t\t];\n\n\t\t\tconst faceIdx = _faceLib[ face ];\n\t\t\tposition.set( coordinates, positionSize * vertices * faceIdx );\n\t\t\tuv.set( uv1, uvSize * vertices * faceIdx );\n\t\t\tconst fill = [ faceIdx, faceIdx, faceIdx, faceIdx, faceIdx, faceIdx ];\n\t\t\tfaceIndex.set( fill, faceIndexSize * vertices * faceIdx );\n\n\t\t}\n\n\t\tconst planes = new BufferGeometry();\n\t\tplanes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );\n\t\tplanes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );\n\t\tplanes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );\n\t\tlodPlanes.push( planes );\n\t\tlodMeshes.push( new Mesh( planes, null ) );\n\n\t\tif ( lod > LOD_MIN ) {\n\n\t\t\tlod --;\n\n\t\t}\n\n\t}\n\n\treturn { lodPlanes, sizeLods, sigmas, lodMeshes };\n\n}\n\nfunction _createRenderTarget( width, height, params ) {\n\n\tconst cubeUVRenderTarget = new RenderTarget( width, height, params );\n\tcubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n\tcubeUVRenderTarget.texture.name = 'PMREM.cubeUv';\n\tcubeUVRenderTarget.texture.isPMREMTexture = true;\n\tcubeUVRenderTarget.scissorTest = true;\n\treturn cubeUVRenderTarget;\n\n}\n\nfunction _setViewport( target, x, y, width, height ) {\n\n\tconst viewY = target.height - height - y;\n\n\ttarget.viewport.set( x, viewY, width, height );\n\ttarget.scissor.set( x, viewY, width, height );\n\n}\n\nfunction _getMaterial() {\n\n\tconst material = new NodeMaterial();\n\tmaterial.depthTest = false;\n\tmaterial.depthWrite = false;\n\tmaterial.blending = NoBlending;\n\n\treturn material;\n\n}\n\nfunction _getBlurShader( lodMax, width, height ) {\n\n\tconst weights = uniforms( new Array( MAX_SAMPLES ).fill( 0 ) );\n\tconst poleAxis = uniform( new Vector3( 0, 1, 0 ) );\n\tconst dTheta = uniform( 0 );\n\tconst n = float( MAX_SAMPLES );\n\tconst latitudinal = uniform( 0 ); // false, bool\n\tconst samples = uniform( 1 ); // int\n\tconst envMap = texture( null );\n\tconst mipInt = uniform( 0 ); // int\n\tconst CUBEUV_TEXEL_WIDTH = float( 1 / width );\n\tconst CUBEUV_TEXEL_HEIGHT = float( 1 / height );\n\tconst CUBEUV_MAX_MIP = float( lodMax );\n\n\tconst materialUniforms = {\n\t\tn,\n\t\tlatitudinal,\n\t\tweights,\n\t\tpoleAxis,\n\t\toutputDirection,\n\t\tdTheta,\n\t\tsamples,\n\t\tenvMap,\n\t\tmipInt,\n\t\tCUBEUV_TEXEL_WIDTH,\n\t\tCUBEUV_TEXEL_HEIGHT,\n\t\tCUBEUV_MAX_MIP\n\t};\n\n\tconst material = _getMaterial();\n\tmaterial.uniforms = materialUniforms; // TODO: Move to outside of the material\n\tmaterial.fragmentNode = blur( { ...materialUniforms, latitudinal: latitudinal.equal( 1 ) } );\n\n\treturn material;\n\n}\n\nfunction _getCubemapMaterial( envTexture ) {\n\n\tconst material = _getMaterial();\n\tmaterial.fragmentNode = cubeTexture( envTexture, outputDirection );\n\n\treturn material;\n\n}\n\nfunction _getEquirectMaterial( envTexture ) {\n\n\tconst material = _getMaterial();\n\tmaterial.fragmentNode = texture( envTexture, equirectUV( outputDirection ), 0 );\n\n\treturn material;\n\n}\n\nexport default PMREMGenerator;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}