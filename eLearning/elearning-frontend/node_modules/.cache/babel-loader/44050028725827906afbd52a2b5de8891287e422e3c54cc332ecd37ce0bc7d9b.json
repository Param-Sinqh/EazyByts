{"ast":null,"code":"import UniformNode, { uniform } from '../core/UniformNode.js';\nimport { uv } from './UVNode.js';\nimport { textureSize } from './TextureSizeNode.js';\nimport { colorSpaceToLinear } from '../display/ColorSpaceNode.js';\nimport { expression } from '../code/ExpressionNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { maxMipLevel } from '../utils/MaxMipLevelNode.js';\nimport { addNodeElement, nodeProxy, vec3, nodeObject } from '../shadernode/ShaderNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\nclass TextureNode extends UniformNode {\n  constructor(value, uvNode = null, levelNode = null) {\n    super(value);\n    this.isTextureNode = true;\n    this.uvNode = uvNode;\n    this.levelNode = levelNode;\n    this.compareNode = null;\n    this.depthNode = null;\n    this.gradNode = null;\n    this.sampler = true;\n    this.updateMatrix = false;\n    this.updateType = NodeUpdateType.NONE;\n    this.referenceNode = null;\n    this._value = value;\n    this.setUpdateMatrix(uvNode === null);\n  }\n  set value(value) {\n    if (this.referenceNode) {\n      this.referenceNode.value = value;\n    } else {\n      this._value = value;\n    }\n  }\n  get value() {\n    return this.referenceNode ? this.referenceNode.value : this._value;\n  }\n  getUniformHash( /*builder*/\n  ) {\n    return this.value.uuid;\n  }\n  getNodeType( /*builder*/\n  ) {\n    if (this.value.isDepthTexture === true) return 'float';\n    return 'vec4';\n  }\n  getInputType( /*builder*/\n  ) {\n    return 'texture';\n  }\n  getDefaultUV() {\n    return uv(this.value.channel);\n  }\n  updateReference( /*state*/\n  ) {\n    return this.value;\n  }\n  getTransformedUV(uvNode) {\n    const texture = this.value;\n    return uniform(texture.matrix).mul(vec3(uvNode, 1)).xy;\n  }\n  setUpdateMatrix(value) {\n    this.updateMatrix = value;\n    this.updateType = value ? NodeUpdateType.FRAME : NodeUpdateType.NONE;\n    return this;\n  }\n  setupUV(builder, uvNode) {\n    const texture = this.value;\n    if (builder.isFlipY() && (texture.isRenderTargetTexture === true || texture.isFramebufferTexture === true || texture.isDepthTexture === true)) {\n      uvNode = uvNode.setY(uvNode.y.oneMinus());\n    }\n    return uvNode;\n  }\n  setup(builder) {\n    const properties = builder.getNodeProperties(this);\n\n    //\n\n    let uvNode = this.uvNode;\n    if ((uvNode === null || builder.context.forceUVContext === true) && builder.context.getUV) {\n      uvNode = builder.context.getUV(this);\n    }\n    if (!uvNode) uvNode = this.getDefaultUV();\n    if (this.updateMatrix === true) {\n      uvNode = this.getTransformedUV(uvNode);\n    }\n    uvNode = this.setupUV(builder, uvNode);\n\n    //\n\n    let levelNode = this.levelNode;\n    if (levelNode === null && builder.context.getTextureLevel) {\n      levelNode = builder.context.getTextureLevel(this);\n    }\n\n    //\n\n    properties.uvNode = uvNode;\n    properties.levelNode = levelNode;\n    properties.compareNode = this.compareNode;\n    properties.gradNode = this.gradNode;\n    properties.depthNode = this.depthNode;\n  }\n  generateUV(builder, uvNode) {\n    return uvNode.build(builder, this.sampler === true ? 'vec2' : 'ivec2');\n  }\n  generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, depthSnippet, compareSnippet, gradSnippet) {\n    const texture = this.value;\n    let snippet;\n    if (levelSnippet) {\n      snippet = builder.generateTextureLevel(texture, textureProperty, uvSnippet, levelSnippet, depthSnippet);\n    } else if (gradSnippet) {\n      snippet = builder.generateTextureGrad(texture, textureProperty, uvSnippet, gradSnippet, depthSnippet);\n    } else if (compareSnippet) {\n      snippet = builder.generateTextureCompare(texture, textureProperty, uvSnippet, compareSnippet, depthSnippet);\n    } else if (this.sampler === false) {\n      snippet = builder.generateTextureLoad(texture, textureProperty, uvSnippet, depthSnippet);\n    } else {\n      snippet = builder.generateTexture(texture, textureProperty, uvSnippet, depthSnippet);\n    }\n    return snippet;\n  }\n  generate(builder, output) {\n    const properties = builder.getNodeProperties(this);\n    const texture = this.value;\n    if (!texture || texture.isTexture !== true) {\n      throw new Error('TextureNode: Need a three.js texture.');\n    }\n    const textureProperty = super.generate(builder, 'property');\n    if (output === 'sampler') {\n      return textureProperty + '_sampler';\n    } else if (builder.isReference(output)) {\n      return textureProperty;\n    } else {\n      const nodeData = builder.getDataFromNode(this);\n      let propertyName = nodeData.propertyName;\n      if (propertyName === undefined) {\n        const {\n          uvNode,\n          levelNode,\n          compareNode,\n          depthNode,\n          gradNode\n        } = properties;\n        const uvSnippet = this.generateUV(builder, uvNode);\n        const levelSnippet = levelNode ? levelNode.build(builder, 'float') : null;\n        const depthSnippet = depthNode ? depthNode.build(builder, 'int') : null;\n        const compareSnippet = compareNode ? compareNode.build(builder, 'float') : null;\n        const gradSnippet = gradNode ? [gradNode[0].build(builder, 'vec2'), gradNode[1].build(builder, 'vec2')] : null;\n        const nodeVar = builder.getVarFromNode(this);\n        propertyName = builder.getPropertyName(nodeVar);\n        const snippet = this.generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, depthSnippet, compareSnippet, gradSnippet);\n        builder.addLineFlowCode(`${propertyName} = ${snippet}`);\n        if (builder.context.tempWrite !== false) {\n          nodeData.snippet = snippet;\n          nodeData.propertyName = propertyName;\n        }\n      }\n      let snippet = propertyName;\n      const nodeType = this.getNodeType(builder);\n      if (builder.needsColorSpaceToLinear(texture)) {\n        snippet = colorSpaceToLinear(expression(snippet, nodeType), texture.colorSpace).setup(builder).build(builder, nodeType);\n      }\n      return builder.format(snippet, nodeType, output);\n    }\n  }\n  setSampler(value) {\n    this.sampler = value;\n    return this;\n  }\n  getSampler() {\n    return this.sampler;\n  }\n\n  // @TODO: Move to TSL\n\n  uv(uvNode) {\n    const textureNode = this.clone();\n    textureNode.uvNode = uvNode;\n    textureNode.referenceNode = this;\n    return nodeObject(textureNode);\n  }\n  blur(levelNode) {\n    const textureNode = this.clone();\n    textureNode.levelNode = levelNode.mul(maxMipLevel(textureNode));\n    textureNode.referenceNode = this;\n    return nodeObject(textureNode);\n  }\n  level(levelNode) {\n    const textureNode = this.clone();\n    textureNode.levelNode = levelNode;\n    textureNode.referenceNode = this;\n    return textureNode;\n  }\n  size(levelNode) {\n    return textureSize(this, levelNode);\n  }\n  compare(compareNode) {\n    const textureNode = this.clone();\n    textureNode.compareNode = nodeObject(compareNode);\n    textureNode.referenceNode = this;\n    return nodeObject(textureNode);\n  }\n  grad(gradNodeX, gradNodeY) {\n    const textureNode = this.clone();\n    textureNode.gradNode = [nodeObject(gradNodeX), nodeObject(gradNodeY)];\n    textureNode.referenceNode = this;\n    return nodeObject(textureNode);\n  }\n  depth(depthNode) {\n    const textureNode = this.clone();\n    textureNode.depthNode = nodeObject(depthNode);\n    textureNode.referenceNode = this;\n    return nodeObject(textureNode);\n  }\n\n  // --\n\n  serialize(data) {\n    super.serialize(data);\n    data.value = this.value.toJSON(data.meta).uuid;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.value = data.meta.textures[data.value];\n  }\n  update() {\n    const texture = this.value;\n    if (texture.matrixAutoUpdate === true) {\n      texture.updateMatrix();\n    }\n  }\n  clone() {\n    const newNode = new this.constructor(this.value, this.uvNode, this.levelNode);\n    newNode.sampler = this.sampler;\n    return newNode;\n  }\n}\nexport default TextureNode;\nexport const texture = nodeProxy(TextureNode);\nexport const textureLoad = (...params) => texture(...params).setSampler(false);\n\n//export const textureLevel = ( value, uv, level ) => texture( value, uv ).level( level );\n\nexport const sampler = aTexture => (aTexture.isNode === true ? aTexture : texture(aTexture)).convert('sampler');\naddNodeElement('texture', texture);\n//addNodeElement( 'textureLevel', textureLevel );\n\naddNodeClass('TextureNode', TextureNode);","map":{"version":3,"names":["UniformNode","uniform","uv","textureSize","colorSpaceToLinear","expression","addNodeClass","maxMipLevel","addNodeElement","nodeProxy","vec3","nodeObject","NodeUpdateType","TextureNode","constructor","value","uvNode","levelNode","isTextureNode","compareNode","depthNode","gradNode","sampler","updateMatrix","updateType","NONE","referenceNode","_value","setUpdateMatrix","getUniformHash","uuid","getNodeType","isDepthTexture","getInputType","getDefaultUV","channel","updateReference","getTransformedUV","texture","matrix","mul","xy","FRAME","setupUV","builder","isFlipY","isRenderTargetTexture","isFramebufferTexture","setY","y","oneMinus","setup","properties","getNodeProperties","context","forceUVContext","getUV","getTextureLevel","generateUV","build","generateSnippet","textureProperty","uvSnippet","levelSnippet","depthSnippet","compareSnippet","gradSnippet","snippet","generateTextureLevel","generateTextureGrad","generateTextureCompare","generateTextureLoad","generateTexture","generate","output","isTexture","Error","isReference","nodeData","getDataFromNode","propertyName","undefined","nodeVar","getVarFromNode","getPropertyName","addLineFlowCode","tempWrite","nodeType","needsColorSpaceToLinear","colorSpace","format","setSampler","getSampler","textureNode","clone","blur","level","size","compare","grad","gradNodeX","gradNodeY","depth","serialize","data","toJSON","meta","deserialize","textures","update","matrixAutoUpdate","newNode","textureLoad","params","aTexture","isNode","convert"],"sources":["D:/dumps/online-learning-platform-main/Frontend/node_modules/three/examples/jsm/nodes/accessors/TextureNode.js"],"sourcesContent":["import UniformNode, { uniform } from '../core/UniformNode.js';\nimport { uv } from './UVNode.js';\nimport { textureSize } from './TextureSizeNode.js';\nimport { colorSpaceToLinear } from '../display/ColorSpaceNode.js';\nimport { expression } from '../code/ExpressionNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { maxMipLevel } from '../utils/MaxMipLevelNode.js';\nimport { addNodeElement, nodeProxy, vec3, nodeObject } from '../shadernode/ShaderNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\n\nclass TextureNode extends UniformNode {\n\n\tconstructor( value, uvNode = null, levelNode = null ) {\n\n\t\tsuper( value );\n\n\t\tthis.isTextureNode = true;\n\n\t\tthis.uvNode = uvNode;\n\t\tthis.levelNode = levelNode;\n\t\tthis.compareNode = null;\n\t\tthis.depthNode = null;\n\t\tthis.gradNode = null;\n\n\t\tthis.sampler = true;\n\t\tthis.updateMatrix = false;\n\t\tthis.updateType = NodeUpdateType.NONE;\n\n\t\tthis.referenceNode = null;\n\n\t\tthis._value = value;\n\n\t\tthis.setUpdateMatrix( uvNode === null );\n\n\t}\n\n\tset value( value ) {\n\n\t\tif ( this.referenceNode ) {\n\n\t\t\tthis.referenceNode.value = value;\n\n\t\t} else {\n\n\t\t\tthis._value = value;\n\n\t\t}\n\n\t}\n\n\tget value() {\n\n\t\treturn this.referenceNode ? this.referenceNode.value : this._value;\n\n\t}\n\n\tgetUniformHash( /*builder*/ ) {\n\n\t\treturn this.value.uuid;\n\n\t}\n\n\tgetNodeType( /*builder*/ ) {\n\n\t\tif ( this.value.isDepthTexture === true ) return 'float';\n\n\t\treturn 'vec4';\n\n\t}\n\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'texture';\n\n\t}\n\n\tgetDefaultUV() {\n\n\t\treturn uv( this.value.channel );\n\n\t}\n\n\tupdateReference( /*state*/ ) {\n\n\t\treturn this.value;\n\n\t}\n\n\tgetTransformedUV( uvNode ) {\n\n\t\tconst texture = this.value;\n\n\t\treturn uniform( texture.matrix ).mul( vec3( uvNode, 1 ) ).xy;\n\n\t}\n\n\tsetUpdateMatrix( value ) {\n\n\t\tthis.updateMatrix = value;\n\t\tthis.updateType = value ? NodeUpdateType.FRAME : NodeUpdateType.NONE;\n\n\t\treturn this;\n\n\t}\n\n\tsetupUV( builder, uvNode ) {\n\n\t\tconst texture = this.value;\n\n\t\tif ( builder.isFlipY() && ( texture.isRenderTargetTexture === true || texture.isFramebufferTexture === true || texture.isDepthTexture === true ) ) {\n\n\t\t\tuvNode = uvNode.setY( uvNode.y.oneMinus() );\n\n\t\t}\n\n\t\treturn uvNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\t//\n\n\t\tlet uvNode = this.uvNode;\n\n\t\tif ( ( uvNode === null || builder.context.forceUVContext === true ) && builder.context.getUV ) {\n\n\t\t\tuvNode = builder.context.getUV( this );\n\n\t\t}\n\n\t\tif ( ! uvNode ) uvNode = this.getDefaultUV();\n\n\t\tif ( this.updateMatrix === true ) {\n\n\t\t\tuvNode = this.getTransformedUV( uvNode );\n\n\t\t}\n\n\t\tuvNode = this.setupUV( builder, uvNode );\n\n\t\t//\n\n\t\tlet levelNode = this.levelNode;\n\n\t\tif ( levelNode === null && builder.context.getTextureLevel ) {\n\n\t\t\tlevelNode = builder.context.getTextureLevel( this );\n\n\t\t}\n\n\t\t//\n\n\t\tproperties.uvNode = uvNode;\n\t\tproperties.levelNode = levelNode;\n\t\tproperties.compareNode = this.compareNode;\n\t\tproperties.gradNode = this.gradNode;\n\t\tproperties.depthNode = this.depthNode;\n\n\t}\n\n\tgenerateUV( builder, uvNode ) {\n\n\t\treturn uvNode.build( builder, this.sampler === true ? 'vec2' : 'ivec2' );\n\n\t}\n\n\tgenerateSnippet( builder, textureProperty, uvSnippet, levelSnippet, depthSnippet, compareSnippet, gradSnippet ) {\n\n\t\tconst texture = this.value;\n\n\t\tlet snippet;\n\n\t\tif ( levelSnippet ) {\n\n\t\t\tsnippet = builder.generateTextureLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet );\n\n\t\t} else if ( gradSnippet ) {\n\n\t\t\tsnippet = builder.generateTextureGrad( texture, textureProperty, uvSnippet, gradSnippet, depthSnippet );\n\n\t\t} else if ( compareSnippet ) {\n\n\t\t\tsnippet = builder.generateTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, depthSnippet );\n\n\t\t} else if ( this.sampler === false ) {\n\n\t\t\tsnippet = builder.generateTextureLoad( texture, textureProperty, uvSnippet, depthSnippet );\n\n\t\t} else {\n\n\t\t\tsnippet = builder.generateTexture( texture, textureProperty, uvSnippet, depthSnippet );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tconst texture = this.value;\n\n\t\tif ( ! texture || texture.isTexture !== true ) {\n\n\t\t\tthrow new Error( 'TextureNode: Need a three.js texture.' );\n\n\t\t}\n\n\t\tconst textureProperty = super.generate( builder, 'property' );\n\n\t\tif ( output === 'sampler' ) {\n\n\t\t\treturn textureProperty + '_sampler';\n\n\t\t} else if ( builder.isReference( output ) ) {\n\n\t\t\treturn textureProperty;\n\n\t\t} else {\n\n\t\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t\tlet propertyName = nodeData.propertyName;\n\n\t\t\tif ( propertyName === undefined ) {\n\n\t\t\t\tconst { uvNode, levelNode, compareNode, depthNode, gradNode } = properties;\n\n\t\t\t\tconst uvSnippet = this.generateUV( builder, uvNode );\n\t\t\t\tconst levelSnippet = levelNode ? levelNode.build( builder, 'float' ) : null;\n\t\t\t\tconst depthSnippet = depthNode ? depthNode.build( builder, 'int' ) : null;\n\t\t\t\tconst compareSnippet = compareNode ? compareNode.build( builder, 'float' ) : null;\n\t\t\t\tconst gradSnippet = gradNode ? [ gradNode[ 0 ].build( builder, 'vec2' ), gradNode[ 1 ].build( builder, 'vec2' ) ] : null;\n\n\t\t\t\tconst nodeVar = builder.getVarFromNode( this );\n\n\t\t\t\tpropertyName = builder.getPropertyName( nodeVar );\n\n\t\t\t\tconst snippet = this.generateSnippet( builder, textureProperty, uvSnippet, levelSnippet, depthSnippet, compareSnippet, gradSnippet );\n\n\t\t\t\tbuilder.addLineFlowCode( `${propertyName} = ${snippet}` );\n\n\t\t\t\tif ( builder.context.tempWrite !== false ) {\n\n\t\t\t\t\tnodeData.snippet = snippet;\n\t\t\t\t\tnodeData.propertyName = propertyName;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlet snippet = propertyName;\n\t\t\tconst nodeType = this.getNodeType( builder );\n\n\t\t\tif ( builder.needsColorSpaceToLinear( texture ) ) {\n\n\t\t\t\tsnippet = colorSpaceToLinear( expression( snippet, nodeType ), texture.colorSpace ).setup( builder ).build( builder, nodeType );\n\n\t\t\t}\n\n\t\t\treturn builder.format( snippet, nodeType, output );\n\n\t\t}\n\n\t}\n\n\tsetSampler( value ) {\n\n\t\tthis.sampler = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetSampler() {\n\n\t\treturn this.sampler;\n\n\t}\n\n\t// @TODO: Move to TSL\n\n\tuv( uvNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.uvNode = uvNode;\n\t\ttextureNode.referenceNode = this;\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\tblur( levelNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.levelNode = levelNode.mul( maxMipLevel( textureNode ) );\n\t\ttextureNode.referenceNode = this;\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\tlevel( levelNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.levelNode = levelNode;\n\t\ttextureNode.referenceNode = this;\n\n\t\treturn textureNode;\n\n\t}\n\n\tsize( levelNode ) {\n\n\t\treturn textureSize( this, levelNode );\n\n\t}\n\n\tcompare( compareNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.compareNode = nodeObject( compareNode );\n\t\ttextureNode.referenceNode = this;\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\tgrad( gradNodeX, gradNodeY ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.gradNode = [ nodeObject( gradNodeX ), nodeObject( gradNodeY ) ];\n\n\t\ttextureNode.referenceNode = this;\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\tdepth( depthNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.depthNode = nodeObject( depthNode );\n\t\ttextureNode.referenceNode = this;\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\t// --\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.value = this.value.toJSON( data.meta ).uuid;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.value = data.meta.textures[ data.value ];\n\n\t}\n\n\tupdate() {\n\n\t\tconst texture = this.value;\n\n\t\tif ( texture.matrixAutoUpdate === true ) {\n\n\t\t\ttexture.updateMatrix();\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\tconst newNode = new this.constructor( this.value, this.uvNode, this.levelNode );\n\t\tnewNode.sampler = this.sampler;\n\n\t\treturn newNode;\n\n\t}\n\n}\n\nexport default TextureNode;\n\nexport const texture = nodeProxy( TextureNode );\nexport const textureLoad = ( ...params ) => texture( ...params ).setSampler( false );\n\n//export const textureLevel = ( value, uv, level ) => texture( value, uv ).level( level );\n\nexport const sampler = ( aTexture ) => ( aTexture.isNode === true ? aTexture : texture( aTexture ) ).convert( 'sampler' );\n\naddNodeElement( 'texture', texture );\n//addNodeElement( 'textureLevel', textureLevel );\n\naddNodeClass( 'TextureNode', TextureNode );\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}