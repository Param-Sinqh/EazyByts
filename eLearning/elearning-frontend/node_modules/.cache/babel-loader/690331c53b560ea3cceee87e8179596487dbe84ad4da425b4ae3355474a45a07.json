{"ast":null,"code":"import { tslFn, int, float, vec2, vec3, vec4, If } from '../shadernode/ShaderNode.js';\nimport { cos, sin, abs, max, exp2, log2, clamp, fract, mix, floor, normalize, cross, all } from '../math/MathNode.js';\nimport { mul } from '../math/OperatorNode.js';\nimport { cond } from '../math/CondNode.js';\nimport { loop, Break } from '../utils/LoopNode.js';\n\n// These defines must match with PMREMGenerator\n\nconst cubeUV_r0 = float(1.0);\nconst cubeUV_m0 = float(-2.0);\nconst cubeUV_r1 = float(0.8);\nconst cubeUV_m1 = float(-1.0);\nconst cubeUV_r4 = float(0.4);\nconst cubeUV_m4 = float(2.0);\nconst cubeUV_r5 = float(0.305);\nconst cubeUV_m5 = float(3.0);\nconst cubeUV_r6 = float(0.21);\nconst cubeUV_m6 = float(4.0);\nconst cubeUV_minMipLevel = float(4.0);\nconst cubeUV_minTileSize = float(16.0);\n\n// These shader functions convert between the UV coordinates of a single face of\n// a cubemap, the 0-5 integer index of a cube face, and the direction vector for\n// sampling a textureCube (not generally normalized ).\n\nconst getFace = tslFn(([direction]) => {\n  const absDirection = vec3(abs(direction)).toVar();\n  const face = float(-1.0).toVar();\n  If(absDirection.x.greaterThan(absDirection.z), () => {\n    If(absDirection.x.greaterThan(absDirection.y), () => {\n      face.assign(cond(direction.x.greaterThan(0.0), 0.0, 3.0));\n    }).else(() => {\n      face.assign(cond(direction.y.greaterThan(0.0), 1.0, 4.0));\n    });\n  }).else(() => {\n    If(absDirection.z.greaterThan(absDirection.y), () => {\n      face.assign(cond(direction.z.greaterThan(0.0), 2.0, 5.0));\n    }).else(() => {\n      face.assign(cond(direction.y.greaterThan(0.0), 1.0, 4.0));\n    });\n  });\n  return face;\n}).setLayout({\n  name: 'getFace',\n  type: 'float',\n  inputs: [{\n    name: 'direction',\n    type: 'vec3'\n  }]\n});\n\n// RH coordinate system; PMREM face-indexing convention\nconst getUV = tslFn(([direction, face]) => {\n  const uv = vec2().toVar();\n  If(face.equal(0.0), () => {\n    uv.assign(vec2(direction.z, direction.y).div(abs(direction.x))); // pos x\n  }).elseif(face.equal(1.0), () => {\n    uv.assign(vec2(direction.x.negate(), direction.z.negate()).div(abs(direction.y))); // pos y\n  }).elseif(face.equal(2.0), () => {\n    uv.assign(vec2(direction.x.negate(), direction.y).div(abs(direction.z))); // pos z\n  }).elseif(face.equal(3.0), () => {\n    uv.assign(vec2(direction.z.negate(), direction.y).div(abs(direction.x))); // neg x\n  }).elseif(face.equal(4.0), () => {\n    uv.assign(vec2(direction.x.negate(), direction.z).div(abs(direction.y))); // neg y\n  }).else(() => {\n    uv.assign(vec2(direction.x, direction.y).div(abs(direction.z))); // neg z\n  });\n\n  return mul(0.5, uv.add(1.0));\n}).setLayout({\n  name: 'getUV',\n  type: 'vec2',\n  inputs: [{\n    name: 'direction',\n    type: 'vec3'\n  }, {\n    name: 'face',\n    type: 'float'\n  }]\n});\nconst roughnessToMip = tslFn(([roughness]) => {\n  const mip = float(0.0).toVar();\n  If(roughness.greaterThanEqual(cubeUV_r1), () => {\n    mip.assign(cubeUV_r0.sub(roughness).mul(cubeUV_m1.sub(cubeUV_m0)).div(cubeUV_r0.sub(cubeUV_r1)).add(cubeUV_m0));\n  }).elseif(roughness.greaterThanEqual(cubeUV_r4), () => {\n    mip.assign(cubeUV_r1.sub(roughness).mul(cubeUV_m4.sub(cubeUV_m1)).div(cubeUV_r1.sub(cubeUV_r4)).add(cubeUV_m1));\n  }).elseif(roughness.greaterThanEqual(cubeUV_r5), () => {\n    mip.assign(cubeUV_r4.sub(roughness).mul(cubeUV_m5.sub(cubeUV_m4)).div(cubeUV_r4.sub(cubeUV_r5)).add(cubeUV_m4));\n  }).elseif(roughness.greaterThanEqual(cubeUV_r6), () => {\n    mip.assign(cubeUV_r5.sub(roughness).mul(cubeUV_m6.sub(cubeUV_m5)).div(cubeUV_r5.sub(cubeUV_r6)).add(cubeUV_m5));\n  }).else(() => {\n    mip.assign(float(-2.0).mul(log2(mul(1.16, roughness)))); // 1.16 = 1.79^0.25\n  });\n\n  return mip;\n}).setLayout({\n  name: 'roughnessToMip',\n  type: 'float',\n  inputs: [{\n    name: 'roughness',\n    type: 'float'\n  }]\n});\n\n// RH coordinate system; PMREM face-indexing convention\nexport const getDirection = tslFn(([uv_immutable, face]) => {\n  const uv = uv_immutable.toVar();\n  uv.assign(mul(2.0, uv).sub(1.0));\n  const direction = vec3(uv, 1.0).toVar();\n  If(face.equal(0.0), () => {\n    direction.assign(direction.zyx); // ( 1, v, u ) pos x\n  }).elseif(face.equal(1.0), () => {\n    direction.assign(direction.xzy);\n    direction.xz.mulAssign(-1.0); // ( -u, 1, -v ) pos y\n  }).elseif(face.equal(2.0), () => {\n    direction.x.mulAssign(-1.0); // ( -u, v, 1 ) pos z\n  }).elseif(face.equal(3.0), () => {\n    direction.assign(direction.zyx);\n    direction.xz.mulAssign(-1.0); // ( -1, v, -u ) neg x\n  }).elseif(face.equal(4.0), () => {\n    direction.assign(direction.xzy);\n    direction.xy.mulAssign(-1.0); // ( -u, -1, v ) neg y\n  }).elseif(face.equal(5.0), () => {\n    direction.z.mulAssign(-1.0); // ( u, v, -1 ) neg zS\n  });\n\n  return direction;\n}).setLayout({\n  name: 'getDirection',\n  type: 'vec3',\n  inputs: [{\n    name: 'uv',\n    type: 'vec2'\n  }, {\n    name: 'face',\n    type: 'float'\n  }]\n});\n\n//\n\nexport const textureCubeUV = tslFn(([envMap, sampleDir_immutable, roughness_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP]) => {\n  const roughness = float(roughness_immutable);\n  const sampleDir = vec3(sampleDir_immutable);\n  const mip = clamp(roughnessToMip(roughness), cubeUV_m0, CUBEUV_MAX_MIP);\n  const mipF = fract(mip);\n  const mipInt = floor(mip);\n  const color0 = vec3(bilinearCubeUV(envMap, sampleDir, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP)).toVar();\n  If(mipF.notEqual(0.0), () => {\n    const color1 = vec3(bilinearCubeUV(envMap, sampleDir, mipInt.add(1.0), CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP)).toVar();\n    color0.assign(mix(color0, color1, mipF));\n  });\n  return color0;\n});\nconst bilinearCubeUV = tslFn(([envMap, direction_immutable, mipInt_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP]) => {\n  const mipInt = float(mipInt_immutable).toVar();\n  const direction = vec3(direction_immutable);\n  const face = float(getFace(direction)).toVar();\n  const filterInt = float(max(cubeUV_minMipLevel.sub(mipInt), 0.0)).toVar();\n  mipInt.assign(max(mipInt, cubeUV_minMipLevel));\n  const faceSize = float(exp2(mipInt)).toVar();\n  const uv = vec2(getUV(direction, face).mul(faceSize.sub(2.0)).add(1.0)).toVar();\n  If(face.greaterThan(2.0), () => {\n    uv.y.addAssign(faceSize);\n    face.subAssign(3.0);\n  });\n  uv.x.addAssign(face.mul(faceSize));\n  uv.x.addAssign(filterInt.mul(mul(3.0, cubeUV_minTileSize)));\n  uv.y.addAssign(mul(4.0, exp2(CUBEUV_MAX_MIP).sub(faceSize)));\n  uv.x.mulAssign(CUBEUV_TEXEL_WIDTH);\n  uv.y.mulAssign(CUBEUV_TEXEL_HEIGHT);\n  return envMap.uv(uv).grad(vec2(), vec2()); // disable anisotropic filtering\n});\n\nconst getSample = tslFn(({\n  envMap,\n  mipInt,\n  outputDirection,\n  theta,\n  axis,\n  CUBEUV_TEXEL_WIDTH,\n  CUBEUV_TEXEL_HEIGHT,\n  CUBEUV_MAX_MIP\n}) => {\n  const cosTheta = cos(theta);\n\n  // Rodrigues' axis-angle rotation\n  const sampleDirection = outputDirection.mul(cosTheta).add(axis.cross(outputDirection).mul(sin(theta))).add(axis.mul(axis.dot(outputDirection).mul(cosTheta.oneMinus())));\n  return bilinearCubeUV(envMap, sampleDirection, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP);\n});\nexport const blur = tslFn(({\n  n,\n  latitudinal,\n  poleAxis,\n  outputDirection,\n  weights,\n  samples,\n  dTheta,\n  mipInt,\n  envMap,\n  CUBEUV_TEXEL_WIDTH,\n  CUBEUV_TEXEL_HEIGHT,\n  CUBEUV_MAX_MIP\n}) => {\n  const axis = vec3(cond(latitudinal, poleAxis, cross(poleAxis, outputDirection))).toVar();\n  If(all(axis.equals(vec3(0.0))), () => {\n    axis.assign(vec3(outputDirection.z, 0.0, outputDirection.x.negate()));\n  });\n  axis.assign(normalize(axis));\n  const gl_FragColor = vec3().toVar();\n  gl_FragColor.addAssign(weights.element(int(0)).mul(getSample({\n    theta: 0.0,\n    axis,\n    outputDirection,\n    mipInt,\n    envMap,\n    CUBEUV_TEXEL_WIDTH,\n    CUBEUV_TEXEL_HEIGHT,\n    CUBEUV_MAX_MIP\n  })));\n  loop({\n    start: int(1),\n    end: n\n  }, ({\n    i\n  }) => {\n    If(i.greaterThanEqual(samples), () => {\n      Break();\n    });\n    const theta = float(dTheta.mul(float(i))).toVar();\n    gl_FragColor.addAssign(weights.element(i).mul(getSample({\n      theta: theta.mul(-1.0),\n      axis,\n      outputDirection,\n      mipInt,\n      envMap,\n      CUBEUV_TEXEL_WIDTH,\n      CUBEUV_TEXEL_HEIGHT,\n      CUBEUV_MAX_MIP\n    })));\n    gl_FragColor.addAssign(weights.element(i).mul(getSample({\n      theta,\n      axis,\n      outputDirection,\n      mipInt,\n      envMap,\n      CUBEUV_TEXEL_WIDTH,\n      CUBEUV_TEXEL_HEIGHT,\n      CUBEUV_MAX_MIP\n    })));\n  });\n  return vec4(gl_FragColor, 1);\n});","map":{"version":3,"names":["tslFn","int","float","vec2","vec3","vec4","If","cos","sin","abs","max","exp2","log2","clamp","fract","mix","floor","normalize","cross","all","mul","cond","loop","Break","cubeUV_r0","cubeUV_m0","cubeUV_r1","cubeUV_m1","cubeUV_r4","cubeUV_m4","cubeUV_r5","cubeUV_m5","cubeUV_r6","cubeUV_m6","cubeUV_minMipLevel","cubeUV_minTileSize","getFace","direction","absDirection","toVar","face","x","greaterThan","z","y","assign","else","setLayout","name","type","inputs","getUV","uv","equal","div","elseif","negate","add","roughnessToMip","roughness","mip","greaterThanEqual","sub","getDirection","uv_immutable","zyx","xzy","xz","mulAssign","xy","textureCubeUV","envMap","sampleDir_immutable","roughness_immutable","CUBEUV_TEXEL_WIDTH","CUBEUV_TEXEL_HEIGHT","CUBEUV_MAX_MIP","sampleDir","mipF","mipInt","color0","bilinearCubeUV","notEqual","color1","direction_immutable","mipInt_immutable","filterInt","faceSize","addAssign","subAssign","grad","getSample","outputDirection","theta","axis","cosTheta","sampleDirection","dot","oneMinus","blur","n","latitudinal","poleAxis","weights","samples","dTheta","equals","gl_FragColor","element","start","end","i"],"sources":["D:/dumps/online-learning-platform-main/Frontend/node_modules/three/examples/jsm/nodes/pmrem/PMREMUtils.js"],"sourcesContent":["import { tslFn, int, float, vec2, vec3, vec4, If } from '../shadernode/ShaderNode.js';\nimport { cos, sin, abs, max, exp2, log2, clamp, fract, mix, floor, normalize, cross, all } from '../math/MathNode.js';\nimport { mul } from '../math/OperatorNode.js';\nimport { cond } from '../math/CondNode.js';\nimport { loop, Break } from '../utils/LoopNode.js';\n\n// These defines must match with PMREMGenerator\n\nconst cubeUV_r0 = float( 1.0 );\nconst cubeUV_m0 = float( - 2.0 );\nconst cubeUV_r1 = float( 0.8 );\nconst cubeUV_m1 = float( - 1.0 );\nconst cubeUV_r4 = float( 0.4 );\nconst cubeUV_m4 = float( 2.0 );\nconst cubeUV_r5 = float( 0.305 );\nconst cubeUV_m5 = float( 3.0 );\nconst cubeUV_r6 = float( 0.21 );\nconst cubeUV_m6 = float( 4.0 );\n\nconst cubeUV_minMipLevel = float( 4.0 );\nconst cubeUV_minTileSize = float( 16.0 );\n\n// These shader functions convert between the UV coordinates of a single face of\n// a cubemap, the 0-5 integer index of a cube face, and the direction vector for\n// sampling a textureCube (not generally normalized ).\n\nconst getFace = tslFn( ( [ direction ] ) => {\n\n\tconst absDirection = vec3( abs( direction ) ).toVar();\n\tconst face = float( - 1.0 ).toVar();\n\n\tIf( absDirection.x.greaterThan( absDirection.z ), () => {\n\n\t\tIf( absDirection.x.greaterThan( absDirection.y ), () => {\n\n\t\t\tface.assign( cond( direction.x.greaterThan( 0.0 ), 0.0, 3.0 ) );\n\n\t\t} ).else( () => {\n\n\t\t\tface.assign( cond( direction.y.greaterThan( 0.0 ), 1.0, 4.0 ) );\n\n\t\t} );\n\n\t} ).else( () => {\n\n\t\tIf( absDirection.z.greaterThan( absDirection.y ), () => {\n\n\t\t\tface.assign( cond( direction.z.greaterThan( 0.0 ), 2.0, 5.0 ) );\n\n\t\t} ).else( () => {\n\n\t\t\tface.assign( cond( direction.y.greaterThan( 0.0 ), 1.0, 4.0 ) );\n\n\t\t} );\n\n\t} );\n\n\treturn face;\n\n} ).setLayout( {\n\tname: 'getFace',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'direction', type: 'vec3' }\n\t]\n} );\n\n// RH coordinate system; PMREM face-indexing convention\nconst getUV = tslFn( ( [ direction, face ] ) => {\n\n\tconst uv = vec2().toVar();\n\n\tIf( face.equal( 0.0 ), () => {\n\n\t\tuv.assign( vec2( direction.z, direction.y ).div( abs( direction.x ) ) ); // pos x\n\n\t} ).elseif( face.equal( 1.0 ), () => {\n\n\t\tuv.assign( vec2( direction.x.negate(), direction.z.negate() ).div( abs( direction.y ) ) ); // pos y\n\n\t} ).elseif( face.equal( 2.0 ), () => {\n\n\t\tuv.assign( vec2( direction.x.negate(), direction.y ).div( abs( direction.z ) ) ); // pos z\n\n\t} ).elseif( face.equal( 3.0 ), () => {\n\n\t\tuv.assign( vec2( direction.z.negate(), direction.y ).div( abs( direction.x ) ) ); // neg x\n\n\t} ).elseif( face.equal( 4.0 ), () => {\n\n\t\tuv.assign( vec2( direction.x.negate(), direction.z ).div( abs( direction.y ) ) ); // neg y\n\n\t} ).else( () => {\n\n\t\tuv.assign( vec2( direction.x, direction.y ).div( abs( direction.z ) ) ); // neg z\n\n\t} );\n\n\treturn mul( 0.5, uv.add( 1.0 ) );\n\n} ).setLayout( {\n\tname: 'getUV',\n\ttype: 'vec2',\n\tinputs: [\n\t\t{ name: 'direction', type: 'vec3' },\n\t\t{ name: 'face', type: 'float' }\n\t]\n} );\n\nconst roughnessToMip = tslFn( ( [ roughness ] ) => {\n\n\tconst mip = float( 0.0 ).toVar();\n\n\tIf( roughness.greaterThanEqual( cubeUV_r1 ), () => {\n\n\t\tmip.assign( cubeUV_r0.sub( roughness ).mul( cubeUV_m1.sub( cubeUV_m0 ) ).div( cubeUV_r0.sub( cubeUV_r1 ) ).add( cubeUV_m0 ) );\n\n\t} ).elseif( roughness.greaterThanEqual( cubeUV_r4 ), () => {\n\n\t\tmip.assign( cubeUV_r1.sub( roughness ).mul( cubeUV_m4.sub( cubeUV_m1 ) ).div( cubeUV_r1.sub( cubeUV_r4 ) ).add( cubeUV_m1 ) );\n\n\t} ).elseif( roughness.greaterThanEqual( cubeUV_r5 ), () => {\n\n\t\tmip.assign( cubeUV_r4.sub( roughness ).mul( cubeUV_m5.sub( cubeUV_m4 ) ).div( cubeUV_r4.sub( cubeUV_r5 ) ).add( cubeUV_m4 ) );\n\n\t} ).elseif( roughness.greaterThanEqual( cubeUV_r6 ), () => {\n\n\t\tmip.assign( cubeUV_r5.sub( roughness ).mul( cubeUV_m6.sub( cubeUV_m5 ) ).div( cubeUV_r5.sub( cubeUV_r6 ) ).add( cubeUV_m5 ) );\n\n\t} ).else( () => {\n\n\t\tmip.assign( float( - 2.0 ).mul( log2( mul( 1.16, roughness ) ) ) ); // 1.16 = 1.79^0.25\n\n\t} );\n\n\treturn mip;\n\n} ).setLayout( {\n\tname: 'roughnessToMip',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'roughness', type: 'float' }\n\t]\n} );\n\n// RH coordinate system; PMREM face-indexing convention\nexport const getDirection = tslFn( ( [ uv_immutable, face ] ) => {\n\n\tconst uv = uv_immutable.toVar();\n\tuv.assign( mul( 2.0, uv ).sub( 1.0 ) );\n\tconst direction = vec3( uv, 1.0 ).toVar();\n\n\tIf( face.equal( 0.0 ), () => {\n\n\t\tdirection.assign( direction.zyx ); // ( 1, v, u ) pos x\n\n\t} ).elseif( face.equal( 1.0 ), () => {\n\n\t\tdirection.assign( direction.xzy );\n\t\tdirection.xz.mulAssign( - 1.0 ); // ( -u, 1, -v ) pos y\n\n\t} ).elseif( face.equal( 2.0 ), () => {\n\n\t\tdirection.x.mulAssign( - 1.0 ); // ( -u, v, 1 ) pos z\n\n\t} ).elseif( face.equal( 3.0 ), () => {\n\n\t\tdirection.assign( direction.zyx );\n\t\tdirection.xz.mulAssign( - 1.0 ); // ( -1, v, -u ) neg x\n\n\t} ).elseif( face.equal( 4.0 ), () => {\n\n\t\tdirection.assign( direction.xzy );\n\t\tdirection.xy.mulAssign( - 1.0 ); // ( -u, -1, v ) neg y\n\n\t} ).elseif( face.equal( 5.0 ), () => {\n\n\t\tdirection.z.mulAssign( - 1.0 ); // ( u, v, -1 ) neg zS\n\n\t} );\n\n\treturn direction;\n\n} ).setLayout( {\n\tname: 'getDirection',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'uv', type: 'vec2' },\n\t\t{ name: 'face', type: 'float' }\n\t]\n} );\n\n//\n\nexport const textureCubeUV = tslFn( ( [ envMap, sampleDir_immutable, roughness_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ] ) => {\n\n\tconst roughness = float( roughness_immutable );\n\tconst sampleDir = vec3( sampleDir_immutable );\n\n\tconst mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\tconst mipF = fract( mip );\n\tconst mipInt = floor( mip );\n\tconst color0 = vec3( bilinearCubeUV( envMap, sampleDir, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ) ).toVar();\n\n\tIf( mipF.notEqual( 0.0 ), () => {\n\n\t\tconst color1 = vec3( bilinearCubeUV( envMap, sampleDir, mipInt.add( 1.0 ), CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ) ).toVar();\n\n\t\tcolor0.assign( mix( color0, color1, mipF ) );\n\n\t} );\n\n\treturn color0;\n\n} );\n\nconst bilinearCubeUV = tslFn( ( [ envMap, direction_immutable, mipInt_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ] ) => {\n\n\tconst mipInt = float( mipInt_immutable ).toVar();\n\tconst direction = vec3( direction_immutable );\n\tconst face = float( getFace( direction ) ).toVar();\n\tconst filterInt = float( max( cubeUV_minMipLevel.sub( mipInt ), 0.0 ) ).toVar();\n\tmipInt.assign( max( mipInt, cubeUV_minMipLevel ) );\n\tconst faceSize = float( exp2( mipInt ) ).toVar();\n\tconst uv = vec2( getUV( direction, face ).mul( faceSize.sub( 2.0 ) ).add( 1.0 ) ).toVar();\n\n\tIf( face.greaterThan( 2.0 ), () => {\n\n\t\tuv.y.addAssign( faceSize );\n\t\tface.subAssign( 3.0 );\n\n\t} );\n\n\tuv.x.addAssign( face.mul( faceSize ) );\n\tuv.x.addAssign( filterInt.mul( mul( 3.0, cubeUV_minTileSize ) ) );\n\tuv.y.addAssign( mul( 4.0, exp2( CUBEUV_MAX_MIP ).sub( faceSize ) ) );\n\tuv.x.mulAssign( CUBEUV_TEXEL_WIDTH );\n\tuv.y.mulAssign( CUBEUV_TEXEL_HEIGHT );\n\n\treturn envMap.uv( uv ).grad( vec2(), vec2() ); // disable anisotropic filtering\n\n} );\n\nconst getSample = tslFn( ( { envMap, mipInt, outputDirection, theta, axis, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) => {\n\n\tconst cosTheta = cos( theta );\n\n\t// Rodrigues' axis-angle rotation\n\tconst sampleDirection = outputDirection.mul( cosTheta )\n\t\t.add( axis.cross( outputDirection ).mul( sin( theta ) ) )\n\t\t.add( axis.mul( axis.dot( outputDirection ).mul( cosTheta.oneMinus() ) ) );\n\n\treturn bilinearCubeUV( envMap, sampleDirection, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP );\n\n} );\n\nexport const blur = tslFn( ( { n, latitudinal, poleAxis, outputDirection, weights, samples, dTheta, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) => {\n\n\tconst axis = vec3( cond( latitudinal, poleAxis, cross( poleAxis, outputDirection ) ) ).toVar();\n\n\tIf( all( axis.equals( vec3( 0.0 ) ) ), () => {\n\n\t\taxis.assign( vec3( outputDirection.z, 0.0, outputDirection.x.negate() ) );\n\n\t} );\n\n\taxis.assign( normalize( axis ) );\n\n\tconst gl_FragColor = vec3().toVar();\n\tgl_FragColor.addAssign( weights.element( int( 0 ) ).mul( getSample( { theta: 0.0, axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) ) );\n\n\tloop( { start: int( 1 ), end: n }, ( { i } ) => {\n\n\t\tIf( i.greaterThanEqual( samples ), () => {\n\n\t\t\tBreak();\n\n\t\t} );\n\n\t\tconst theta = float( dTheta.mul( float( i ) ) ).toVar();\n\t\tgl_FragColor.addAssign( weights.element( i ).mul( getSample( { theta: theta.mul( - 1.0 ), axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) ) );\n\t\tgl_FragColor.addAssign( weights.element( i ).mul( getSample( { theta, axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) ) );\n\n\t} );\n\n\treturn vec4( gl_FragColor, 1 );\n\n} );\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}