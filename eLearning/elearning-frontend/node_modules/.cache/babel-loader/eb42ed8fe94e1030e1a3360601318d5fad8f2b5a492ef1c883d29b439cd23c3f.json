{"ast":null,"code":"import TempNode from '../core/TempNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { uv } from '../accessors/UVNode.js';\nimport { normalView } from '../accessors/NormalNode.js';\nimport { positionView } from '../accessors/PositionNode.js';\nimport { faceDirection } from './FrontFacingNode.js';\nimport { addNodeElement, tslFn, nodeProxy, float, vec2 } from '../shadernode/ShaderNode.js';\n\n// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen\n// https://mmikk.github.io/papers3d/mm_sfgrad_bump.pdf\n\nconst dHdxy_fwd = tslFn(({\n  textureNode,\n  bumpScale\n}) => {\n  // It's used to preserve the same TextureNode instance\n  const sampleTexture = callback => textureNode.cache().context({\n    getUV: texNode => callback(texNode.uvNode || uv()),\n    forceUVContext: true\n  });\n  const Hll = float(sampleTexture(uvNode => uvNode));\n  return vec2(float(sampleTexture(uvNode => uvNode.add(uvNode.dFdx()))).sub(Hll), float(sampleTexture(uvNode => uvNode.add(uvNode.dFdy()))).sub(Hll)).mul(bumpScale);\n});\n\n// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\nconst perturbNormalArb = tslFn(inputs => {\n  const {\n    surf_pos,\n    surf_norm,\n    dHdxy\n  } = inputs;\n\n  // normalize is done to ensure that the bump map looks the same regardless of the texture's scale\n  const vSigmaX = surf_pos.dFdx().normalize();\n  const vSigmaY = surf_pos.dFdy().normalize();\n  const vN = surf_norm; // normalized\n\n  const R1 = vSigmaY.cross(vN);\n  const R2 = vN.cross(vSigmaX);\n  const fDet = vSigmaX.dot(R1).mul(faceDirection);\n  const vGrad = fDet.sign().mul(dHdxy.x.mul(R1).add(dHdxy.y.mul(R2)));\n  return fDet.abs().mul(surf_norm).sub(vGrad).normalize();\n});\nclass BumpMapNode extends TempNode {\n  constructor(textureNode, scaleNode = null) {\n    super('vec3');\n    this.textureNode = textureNode;\n    this.scaleNode = scaleNode;\n  }\n  setup() {\n    const bumpScale = this.scaleNode !== null ? this.scaleNode : 1;\n    const dHdxy = dHdxy_fwd({\n      textureNode: this.textureNode,\n      bumpScale\n    });\n    return perturbNormalArb({\n      surf_pos: positionView,\n      surf_norm: normalView,\n      dHdxy\n    });\n  }\n}\nexport default BumpMapNode;\nexport const bumpMap = nodeProxy(BumpMapNode);\naddNodeElement('bumpMap', bumpMap);\naddNodeClass('BumpMapNode', BumpMapNode);","map":{"version":3,"names":["TempNode","addNodeClass","uv","normalView","positionView","faceDirection","addNodeElement","tslFn","nodeProxy","float","vec2","dHdxy_fwd","textureNode","bumpScale","sampleTexture","callback","cache","context","getUV","texNode","uvNode","forceUVContext","Hll","add","dFdx","sub","dFdy","mul","perturbNormalArb","inputs","surf_pos","surf_norm","dHdxy","vSigmaX","normalize","vSigmaY","vN","R1","cross","R2","fDet","dot","vGrad","sign","x","y","abs","BumpMapNode","constructor","scaleNode","setup","bumpMap"],"sources":["D:/dumps/online-learning-platform-main/Frontend/node_modules/three/examples/jsm/nodes/display/BumpMapNode.js"],"sourcesContent":["import TempNode from '../core/TempNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { uv } from '../accessors/UVNode.js';\nimport { normalView } from '../accessors/NormalNode.js';\nimport { positionView } from '../accessors/PositionNode.js';\nimport { faceDirection } from './FrontFacingNode.js';\nimport { addNodeElement, tslFn, nodeProxy, float, vec2 } from '../shadernode/ShaderNode.js';\n\n// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen\n// https://mmikk.github.io/papers3d/mm_sfgrad_bump.pdf\n\nconst dHdxy_fwd = tslFn( ( { textureNode, bumpScale } ) => {\n\n\t// It's used to preserve the same TextureNode instance\n\tconst sampleTexture = ( callback ) => textureNode.cache().context( { getUV: ( texNode ) => callback( texNode.uvNode || uv() ), forceUVContext: true } );\n\n\tconst Hll = float( sampleTexture( ( uvNode ) => uvNode ) );\n\n\treturn vec2(\n\t\tfloat( sampleTexture( ( uvNode ) => uvNode.add( uvNode.dFdx() ) ) ).sub( Hll ),\n\t\tfloat( sampleTexture( ( uvNode ) => uvNode.add( uvNode.dFdy() ) ) ).sub( Hll )\n\t).mul( bumpScale );\n\n} );\n\n// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\nconst perturbNormalArb = tslFn( ( inputs ) => {\n\n\tconst { surf_pos, surf_norm, dHdxy } = inputs;\n\n\t// normalize is done to ensure that the bump map looks the same regardless of the texture's scale\n\tconst vSigmaX = surf_pos.dFdx().normalize();\n\tconst vSigmaY = surf_pos.dFdy().normalize();\n\tconst vN = surf_norm; // normalized\n\n\tconst R1 = vSigmaY.cross( vN );\n\tconst R2 = vN.cross( vSigmaX );\n\n\tconst fDet = vSigmaX.dot( R1 ).mul( faceDirection );\n\n\tconst vGrad = fDet.sign().mul( dHdxy.x.mul( R1 ).add( dHdxy.y.mul( R2 ) ) );\n\n\treturn fDet.abs().mul( surf_norm ).sub( vGrad ).normalize();\n\n} );\n\nclass BumpMapNode extends TempNode {\n\n\tconstructor( textureNode, scaleNode = null ) {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.textureNode = textureNode;\n\t\tthis.scaleNode = scaleNode;\n\n\t}\n\n\tsetup() {\n\n\t\tconst bumpScale = this.scaleNode !== null ? this.scaleNode : 1;\n\t\tconst dHdxy = dHdxy_fwd( { textureNode: this.textureNode, bumpScale } );\n\n\t\treturn perturbNormalArb( {\n\t\t\tsurf_pos: positionView,\n\t\t\tsurf_norm: normalView,\n\t\t\tdHdxy\n\t\t} );\n\n\t}\n\n}\n\nexport default BumpMapNode;\n\nexport const bumpMap = nodeProxy( BumpMapNode );\n\naddNodeElement( 'bumpMap', bumpMap );\n\naddNodeClass( 'BumpMapNode', BumpMapNode );\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}