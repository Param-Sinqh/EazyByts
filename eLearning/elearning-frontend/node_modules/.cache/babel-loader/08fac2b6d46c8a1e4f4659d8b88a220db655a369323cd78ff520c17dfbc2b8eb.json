{"ast":null,"code":"import { addNodeClass } from '../core/Node.js';\nimport TempNode from '../core/TempNode.js';\nimport { addNodeElement, nodeProxy } from '../shadernode/ShaderNode.js';\nimport { vectorComponents } from '../core/constants.js';\nclass AssignNode extends TempNode {\n  constructor(targetNode, sourceNode) {\n    super();\n    this.targetNode = targetNode;\n    this.sourceNode = sourceNode;\n  }\n  hasDependencies() {\n    return false;\n  }\n  getNodeType(builder, output) {\n    return output !== 'void' ? this.targetNode.getNodeType(builder) : 'void';\n  }\n  needsSplitAssign(builder) {\n    const {\n      targetNode\n    } = this;\n    if (builder.isAvailable('swizzleAssign') === false && targetNode.isSplitNode && targetNode.components.length > 1) {\n      const targetLength = builder.getTypeLength(targetNode.node.getNodeType(builder));\n      const assignDiferentVector = vectorComponents.join('').slice(0, targetLength) !== targetNode.components;\n      return assignDiferentVector;\n    }\n    return false;\n  }\n  generate(builder, output) {\n    const {\n      targetNode,\n      sourceNode\n    } = this;\n    const needsSplitAssign = this.needsSplitAssign(builder);\n    const targetType = targetNode.getNodeType(builder);\n    const target = targetNode.context({\n      assign: true\n    }).build(builder);\n    const source = sourceNode.build(builder, targetType);\n    const sourceType = sourceNode.getNodeType(builder);\n    const nodeData = builder.getDataFromNode(this);\n\n    //\n\n    let snippet;\n    if (nodeData.initialized === true) {\n      if (output !== 'void') {\n        snippet = target;\n      }\n    } else if (needsSplitAssign) {\n      const sourceVar = builder.getVarFromNode(this, null, targetType);\n      const sourceProperty = builder.getPropertyName(sourceVar);\n      builder.addLineFlowCode(`${sourceProperty} = ${source}`);\n      const targetRoot = targetNode.node.context({\n        assign: true\n      }).build(builder);\n      for (let i = 0; i < targetNode.components.length; i++) {\n        const component = targetNode.components[i];\n        builder.addLineFlowCode(`${targetRoot}.${component} = ${sourceProperty}[ ${i} ]`);\n      }\n      if (output !== 'void') {\n        snippet = target;\n      }\n    } else {\n      snippet = `${target} = ${source}`;\n      if (output === 'void' || sourceType === 'void') {\n        builder.addLineFlowCode(snippet);\n        if (output !== 'void') {\n          snippet = target;\n        }\n      }\n    }\n    nodeData.initialized = true;\n    return builder.format(snippet, targetType, output);\n  }\n}\nexport default AssignNode;\nexport const assign = nodeProxy(AssignNode);\naddNodeClass('AssignNode', AssignNode);\naddNodeElement('assign', assign);","map":{"version":3,"names":["addNodeClass","TempNode","addNodeElement","nodeProxy","vectorComponents","AssignNode","constructor","targetNode","sourceNode","hasDependencies","getNodeType","builder","output","needsSplitAssign","isAvailable","isSplitNode","components","length","targetLength","getTypeLength","node","assignDiferentVector","join","slice","generate","targetType","target","context","assign","build","source","sourceType","nodeData","getDataFromNode","snippet","initialized","sourceVar","getVarFromNode","sourceProperty","getPropertyName","addLineFlowCode","targetRoot","i","component","format"],"sources":["D:/dumps/online-learning-platform-main/Frontend/node_modules/three/examples/jsm/nodes/core/AssignNode.js"],"sourcesContent":["import { addNodeClass } from '../core/Node.js';\nimport TempNode from '../core/TempNode.js';\nimport { addNodeElement, nodeProxy } from '../shadernode/ShaderNode.js';\nimport { vectorComponents } from '../core/constants.js';\n\nclass AssignNode extends TempNode {\n\n\tconstructor( targetNode, sourceNode ) {\n\n\t\tsuper();\n\n\t\tthis.targetNode = targetNode;\n\t\tthis.sourceNode = sourceNode;\n\n\t}\n\n\thasDependencies() {\n\n\t\treturn false;\n\n\t}\n\n\tgetNodeType( builder, output ) {\n\n\t\treturn output !== 'void' ? this.targetNode.getNodeType( builder ) : 'void';\n\n\t}\n\n\tneedsSplitAssign( builder ) {\n\n\t\tconst { targetNode } = this;\n\n\t\tif ( builder.isAvailable( 'swizzleAssign' ) === false && targetNode.isSplitNode && targetNode.components.length > 1 ) {\n\n\t\t\tconst targetLength = builder.getTypeLength( targetNode.node.getNodeType( builder ) );\n\t\t\tconst assignDiferentVector = vectorComponents.join( '' ).slice( 0, targetLength ) !== targetNode.components;\n\n\t\t\treturn assignDiferentVector;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst { targetNode, sourceNode } = this;\n\n\t\tconst needsSplitAssign = this.needsSplitAssign( builder );\n\n\t\tconst targetType = targetNode.getNodeType( builder );\n\n\t\tconst target = targetNode.context( { assign: true } ).build( builder );\n\t\tconst source = sourceNode.build( builder, targetType );\n\n\t\tconst sourceType = sourceNode.getNodeType( builder );\n\n\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t//\n\n\t\tlet snippet;\n\n\t\tif ( nodeData.initialized === true ) {\n\n\t\t\tif ( output !== 'void' ) {\n\n\t\t\t\tsnippet = target;\n\n\t\t\t}\n\n\t\t} else if ( needsSplitAssign ) {\n\n\t\t\tconst sourceVar = builder.getVarFromNode( this, null, targetType );\n\t\t\tconst sourceProperty = builder.getPropertyName( sourceVar );\n\n\t\t\tbuilder.addLineFlowCode( `${ sourceProperty } = ${ source }` );\n\n\t\t\tconst targetRoot = targetNode.node.context( { assign: true } ).build( builder );\n\n\t\t\tfor ( let i = 0; i < targetNode.components.length; i ++ ) {\n\n\t\t\t\tconst component = targetNode.components[ i ];\n\n\t\t\t\tbuilder.addLineFlowCode( `${ targetRoot }.${ component } = ${ sourceProperty }[ ${ i } ]` );\n\n\t\t\t}\n\n\t\t\tif ( output !== 'void' ) {\n\n\t\t\t\tsnippet = target;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tsnippet = `${ target } = ${ source }`;\n\n\t\t\tif ( output === 'void' || sourceType === 'void' ) {\n\n\t\t\t\tbuilder.addLineFlowCode( snippet );\n\n\t\t\t\tif ( output !== 'void' ) {\n\n\t\t\t\t\tsnippet = target;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tnodeData.initialized = true;\n\n\t\treturn builder.format( snippet, targetType, output );\n\n\t}\n\n}\n\nexport default AssignNode;\n\nexport const assign = nodeProxy( AssignNode );\n\naddNodeClass( 'AssignNode', AssignNode );\n\naddNodeElement( 'assign', assign );\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}