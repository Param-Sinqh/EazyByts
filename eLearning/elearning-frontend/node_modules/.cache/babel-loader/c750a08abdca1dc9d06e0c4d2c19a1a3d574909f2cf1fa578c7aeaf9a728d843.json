{"ast":null,"code":"import Node, { addNodeClass } from '../core/Node.js';\nimport { expression } from '../code/ExpressionNode.js';\nimport { bypass } from '../core/BypassNode.js';\nimport { context } from '../core/ContextNode.js';\nimport { addNodeElement, nodeObject, nodeArray } from '../shadernode/ShaderNode.js';\nclass LoopNode extends Node {\n  constructor(params = []) {\n    super();\n    this.params = params;\n  }\n  getVarName(index) {\n    return String.fromCharCode('i'.charCodeAt() + index);\n  }\n  getProperties(builder) {\n    const properties = builder.getNodeProperties(this);\n    if (properties.stackNode !== undefined) return properties;\n\n    //\n\n    const inputs = {};\n    for (let i = 0, l = this.params.length - 1; i < l; i++) {\n      const param = this.params[i];\n      const name = param.isNode !== true && param.name || this.getVarName(i);\n      const type = param.isNode !== true && param.type || 'int';\n      inputs[name] = expression(name, type);\n    }\n    properties.returnsNode = this.params[this.params.length - 1](inputs, builder.addStack(), builder);\n    properties.stackNode = builder.removeStack();\n    return properties;\n  }\n  getNodeType(builder) {\n    const {\n      returnsNode\n    } = this.getProperties(builder);\n    return returnsNode ? returnsNode.getNodeType(builder) : 'void';\n  }\n  setup(builder) {\n    // setup properties\n\n    this.getProperties(builder);\n  }\n  generate(builder) {\n    const properties = this.getProperties(builder);\n    const contextData = {\n      tempWrite: false\n    };\n    const params = this.params;\n    const stackNode = properties.stackNode;\n    for (let i = 0, l = params.length - 1; i < l; i++) {\n      const param = params[i];\n      let start = null,\n        end = null,\n        name = null,\n        type = null,\n        condition = null,\n        update = null;\n      if (param.isNode) {\n        type = 'int';\n        name = this.getVarName(i);\n        start = '0';\n        end = param.build(builder, type);\n        condition = '<';\n      } else {\n        type = param.type || 'int';\n        name = param.name || this.getVarName(i);\n        start = param.start;\n        end = param.end;\n        condition = param.condition;\n        update = param.update;\n        if (typeof start === 'number') start = start.toString();else if (start && start.isNode) start = start.build(builder, type);\n        if (typeof end === 'number') end = end.toString();else if (end && end.isNode) end = end.build(builder, type);\n        if (start !== undefined && end === undefined) {\n          start = start + ' - 1';\n          end = '0';\n          condition = '>=';\n        } else if (end !== undefined && start === undefined) {\n          start = '0';\n          condition = '<';\n        }\n        if (condition === undefined) {\n          if (Number(start) > Number(end)) {\n            condition = '>=';\n          } else {\n            condition = '<';\n          }\n        }\n      }\n      const internalParam = {\n        start,\n        end,\n        condition\n      };\n\n      //\n\n      const startSnippet = internalParam.start;\n      const endSnippet = internalParam.end;\n      let declarationSnippet = '';\n      let conditionalSnippet = '';\n      let updateSnippet = '';\n      if (!update) {\n        if (type === 'int' || type === 'uint') {\n          if (condition.includes('<')) update = '++';else update = '--';\n        } else {\n          if (condition.includes('<')) update = '+= 1.';else update = '-= 1.';\n        }\n      }\n      declarationSnippet += builder.getVar(type, name) + ' = ' + startSnippet;\n      conditionalSnippet += name + ' ' + condition + ' ' + endSnippet;\n      updateSnippet += name + ' ' + update;\n      const forSnippet = `for ( ${declarationSnippet}; ${conditionalSnippet}; ${updateSnippet} )`;\n      builder.addFlowCode((i === 0 ? '\\n' : '') + builder.tab + forSnippet + ' {\\n\\n').addFlowTab();\n    }\n    const stackSnippet = context(stackNode, contextData).build(builder, 'void');\n    const returnsSnippet = properties.returnsNode ? properties.returnsNode.build(builder) : '';\n    builder.removeFlowTab().addFlowCode('\\n' + builder.tab + stackSnippet);\n    for (let i = 0, l = this.params.length - 1; i < l; i++) {\n      builder.addFlowCode((i === 0 ? '' : builder.tab) + '}\\n\\n').removeFlowTab();\n    }\n    builder.addFlowTab();\n    return returnsSnippet;\n  }\n}\nexport default LoopNode;\nexport const loop = (...params) => nodeObject(new LoopNode(nodeArray(params, 'int'))).append();\nexport const Continue = () => expression('continue').append();\nexport const Break = () => expression('break').append();\naddNodeElement('loop', (returns, ...params) => bypass(returns, loop(...params)));\naddNodeClass('LoopNode', LoopNode);","map":{"version":3,"names":["Node","addNodeClass","expression","bypass","context","addNodeElement","nodeObject","nodeArray","LoopNode","constructor","params","getVarName","index","String","fromCharCode","charCodeAt","getProperties","builder","properties","getNodeProperties","stackNode","undefined","inputs","i","l","length","param","name","isNode","type","returnsNode","addStack","removeStack","getNodeType","setup","generate","contextData","tempWrite","start","end","condition","update","build","toString","Number","internalParam","startSnippet","endSnippet","declarationSnippet","conditionalSnippet","updateSnippet","includes","getVar","forSnippet","addFlowCode","tab","addFlowTab","stackSnippet","returnsSnippet","removeFlowTab","loop","append","Continue","Break","returns"],"sources":["D:/dumps/online-learning-platform-main/Frontend/node_modules/three/examples/jsm/nodes/utils/LoopNode.js"],"sourcesContent":["import Node, { addNodeClass } from '../core/Node.js';\nimport { expression } from '../code/ExpressionNode.js';\nimport { bypass } from '../core/BypassNode.js';\nimport { context } from '../core/ContextNode.js';\nimport { addNodeElement, nodeObject, nodeArray } from '../shadernode/ShaderNode.js';\n\nclass LoopNode extends Node {\n\n\tconstructor( params = [] ) {\n\n\t\tsuper();\n\n\t\tthis.params = params;\n\n\t}\n\n\tgetVarName( index ) {\n\n\t\treturn String.fromCharCode( 'i'.charCodeAt() + index );\n\n\t}\n\n\tgetProperties( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tif ( properties.stackNode !== undefined ) return properties;\n\n\t\t//\n\n\t\tconst inputs = {};\n\n\t\tfor ( let i = 0, l = this.params.length - 1; i < l; i ++ ) {\n\n\t\t\tconst param = this.params[ i ];\n\n\t\t\tconst name = ( param.isNode !== true && param.name ) || this.getVarName( i );\n\t\t\tconst type = ( param.isNode !== true && param.type ) || 'int';\n\n\t\t\tinputs[ name ] = expression( name, type );\n\n\t\t}\n\n\t\tproperties.returnsNode = this.params[ this.params.length - 1 ]( inputs, builder.addStack(), builder );\n\t\tproperties.stackNode = builder.removeStack();\n\n\t\treturn properties;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tconst { returnsNode } = this.getProperties( builder );\n\n\t\treturn returnsNode ? returnsNode.getNodeType( builder ) : 'void';\n\n\t}\n\n\tsetup( builder ) {\n\n\t\t// setup properties\n\n\t\tthis.getProperties( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst properties = this.getProperties( builder );\n\n\t\tconst contextData = { tempWrite: false };\n\n\t\tconst params = this.params;\n\t\tconst stackNode = properties.stackNode;\n\n\t\tfor ( let i = 0, l = params.length - 1; i < l; i ++ ) {\n\n\t\t\tconst param = params[ i ];\n\n\t\t\tlet start = null, end = null, name = null, type = null, condition = null, update = null;\n\n\t\t\tif ( param.isNode ) {\n\n\t\t\t\ttype = 'int';\n\t\t\t\tname = this.getVarName( i );\n\t\t\t\tstart = '0';\n\t\t\t\tend = param.build( builder, type );\n\t\t\t\tcondition = '<';\n\n\t\t\t} else {\n\n\t\t\t\ttype = param.type || 'int';\n\t\t\t\tname = param.name || this.getVarName( i );\n\t\t\t\tstart = param.start;\n\t\t\t\tend = param.end;\n\t\t\t\tcondition = param.condition;\n\t\t\t\tupdate = param.update;\n\n\t\t\t\tif ( typeof start === 'number' ) start = start.toString();\n\t\t\t\telse if ( start && start.isNode ) start = start.build( builder, type );\n\n\t\t\t\tif ( typeof end === 'number' ) end = end.toString();\n\t\t\t\telse if ( end && end.isNode ) end = end.build( builder, type );\n\n\t\t\t\tif ( start !== undefined && end === undefined ) {\n\n\t\t\t\t\tstart = start + ' - 1';\n\t\t\t\t\tend = '0';\n\t\t\t\t\tcondition = '>=';\n\n\t\t\t\t} else if ( end !== undefined && start === undefined ) {\n\n\t\t\t\t\tstart = '0';\n\t\t\t\t\tcondition = '<';\n\n\t\t\t\t}\n\n\t\t\t\tif ( condition === undefined ) {\n\n\t\t\t\t\tif ( Number( start ) > Number( end ) ) {\n\n\t\t\t\t\t\tcondition = '>=';\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcondition = '<';\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst internalParam = { start, end, condition };\n\n\t\t\t//\n\n\t\t\tconst startSnippet = internalParam.start;\n\t\t\tconst endSnippet = internalParam.end;\n\n\t\t\tlet declarationSnippet = '';\n\t\t\tlet conditionalSnippet = '';\n\t\t\tlet updateSnippet = '';\n\n\t\t\tif ( ! update ) {\n\n\t\t\t\tif ( type === 'int' || type === 'uint' ) {\n\n\t\t\t\t\tif ( condition.includes( '<' ) ) update = '++';\n\t\t\t\t\telse update = '--';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( condition.includes( '<' ) ) update = '+= 1.';\n\t\t\t\t\telse update = '-= 1.';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tdeclarationSnippet += builder.getVar( type, name ) + ' = ' + startSnippet;\n\n\t\t\tconditionalSnippet += name + ' ' + condition + ' ' + endSnippet;\n\t\t\tupdateSnippet += name + ' ' + update;\n\n\t\t\tconst forSnippet = `for ( ${ declarationSnippet }; ${ conditionalSnippet }; ${ updateSnippet } )`;\n\n\t\t\tbuilder.addFlowCode( ( i === 0 ? '\\n' : '' ) + builder.tab + forSnippet + ' {\\n\\n' ).addFlowTab();\n\n\t\t}\n\n\t\tconst stackSnippet = context( stackNode, contextData ).build( builder, 'void' );\n\n\t\tconst returnsSnippet = properties.returnsNode ? properties.returnsNode.build( builder ) : '';\n\n\t\tbuilder.removeFlowTab().addFlowCode( '\\n' + builder.tab + stackSnippet );\n\n\t\tfor ( let i = 0, l = this.params.length - 1; i < l; i ++ ) {\n\n\t\t\tbuilder.addFlowCode( ( i === 0 ? '' : builder.tab ) + '}\\n\\n' ).removeFlowTab();\n\n\t\t}\n\n\t\tbuilder.addFlowTab();\n\n\t\treturn returnsSnippet;\n\n\t}\n\n}\n\nexport default LoopNode;\n\nexport const loop = ( ...params ) => nodeObject( new LoopNode( nodeArray( params, 'int' ) ) ).append();\nexport const Continue = () => expression( 'continue' ).append();\nexport const Break = () => expression( 'break' ).append();\n\naddNodeElement( 'loop', ( returns, ...params ) => bypass( returns, loop( ...params ) ) );\n\naddNodeClass( 'LoopNode', LoopNode );\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}