{"ast":null,"code":"import NodeUniform from './NodeUniform.js';\nimport NodeAttribute from './NodeAttribute.js';\nimport NodeVarying from './NodeVarying.js';\nimport NodeVar from './NodeVar.js';\nimport NodeCode from './NodeCode.js';\nimport NodeKeywords from './NodeKeywords.js';\nimport NodeCache from './NodeCache.js';\nimport ParameterNode from './ParameterNode.js';\nimport FunctionNode from '../code/FunctionNode.js';\nimport { createNodeMaterialFromType, default as NodeMaterial } from '../materials/NodeMaterial.js';\nimport { NodeUpdateType, defaultBuildStages, shaderStages } from './constants.js';\nimport { FloatNodeUniform, Vector2NodeUniform, Vector3NodeUniform, Vector4NodeUniform, ColorNodeUniform, Matrix3NodeUniform, Matrix4NodeUniform } from '../../renderers/common/nodes/NodeUniform.js';\nimport { REVISION, RenderTarget, Color, Vector2, Vector3, Vector4, IntType, UnsignedIntType, Float16BufferAttribute } from 'three';\nimport { stack } from './StackNode.js';\nimport { getCurrentStack, setCurrentStack } from '../shadernode/ShaderNode.js';\nimport CubeRenderTarget from '../../renderers/common/CubeRenderTarget.js';\nimport ChainMap from '../../renderers/common/ChainMap.js';\nimport PMREMGenerator from '../../renderers/common/extras/PMREMGenerator.js';\nconst uniformsGroupCache = new ChainMap();\nconst typeFromLength = new Map([[2, 'vec2'], [3, 'vec3'], [4, 'vec4'], [9, 'mat3'], [16, 'mat4']]);\nconst typeFromArray = new Map([[Int8Array, 'int'], [Int16Array, 'int'], [Int32Array, 'int'], [Uint8Array, 'uint'], [Uint16Array, 'uint'], [Uint32Array, 'uint'], [Float32Array, 'float']]);\nconst toFloat = value => {\n  value = Number(value);\n  return value + (value % 1 ? '' : '.0');\n};\nclass NodeBuilder {\n  constructor(object, renderer, parser, scene = null, material = null) {\n    this.object = object;\n    this.material = material || object && object.material || null;\n    this.geometry = object && object.geometry || null;\n    this.renderer = renderer;\n    this.parser = parser;\n    this.scene = scene;\n    this.nodes = [];\n    this.updateNodes = [];\n    this.updateBeforeNodes = [];\n    this.hashNodes = {};\n    this.lightsNode = null;\n    this.environmentNode = null;\n    this.fogNode = null;\n    this.clippingContext = null;\n    this.vertexShader = null;\n    this.fragmentShader = null;\n    this.computeShader = null;\n    this.flowNodes = {\n      vertex: [],\n      fragment: [],\n      compute: []\n    };\n    this.flowCode = {\n      vertex: '',\n      fragment: '',\n      compute: ''\n    };\n    this.uniforms = {\n      vertex: [],\n      fragment: [],\n      compute: [],\n      index: 0\n    };\n    this.structs = {\n      vertex: [],\n      fragment: [],\n      compute: [],\n      index: 0\n    };\n    this.bindings = {\n      vertex: [],\n      fragment: [],\n      compute: []\n    };\n    this.bindingsOffset = {\n      vertex: 0,\n      fragment: 0,\n      compute: 0\n    };\n    this.bindingsArray = null;\n    this.attributes = [];\n    this.bufferAttributes = [];\n    this.varyings = [];\n    this.codes = {};\n    this.vars = {};\n    this.flow = {\n      code: ''\n    };\n    this.chaining = [];\n    this.stack = stack();\n    this.stacks = [];\n    this.tab = '\\t';\n    this.currentFunctionNode = null;\n    this.context = {\n      keywords: new NodeKeywords(),\n      material: this.material\n    };\n    this.cache = new NodeCache();\n    this.globalCache = this.cache;\n    this.flowsData = new WeakMap();\n    this.shaderStage = null;\n    this.buildStage = null;\n  }\n  createRenderTarget(width, height, options) {\n    return new RenderTarget(width, height, options);\n  }\n  createCubeRenderTarget(size, options) {\n    return new CubeRenderTarget(size, options);\n  }\n  createPMREMGenerator() {\n    // TODO: Move Materials.js to outside of the Nodes.js in order to remove this function and improve tree-shaking support\n\n    return new PMREMGenerator(this.renderer);\n  }\n  includes(node) {\n    return this.nodes.includes(node);\n  }\n  _getSharedBindings(bindings) {\n    const shared = [];\n    for (const binding of bindings) {\n      if (binding.shared === true) {\n        // nodes is the chainmap key\n        const nodes = binding.getNodes();\n        let sharedBinding = uniformsGroupCache.get(nodes);\n        if (sharedBinding === undefined) {\n          uniformsGroupCache.set(nodes, binding);\n          sharedBinding = binding;\n        }\n        shared.push(sharedBinding);\n      } else {\n        shared.push(binding);\n      }\n    }\n    return shared;\n  }\n  getBindings() {\n    let bindingsArray = this.bindingsArray;\n    if (bindingsArray === null) {\n      const bindings = this.bindings;\n      this.bindingsArray = bindingsArray = this._getSharedBindings(this.material !== null ? [...bindings.vertex, ...bindings.fragment] : bindings.compute);\n    }\n    return bindingsArray;\n  }\n  setHashNode(node, hash) {\n    this.hashNodes[hash] = node;\n  }\n  addNode(node) {\n    if (this.nodes.includes(node) === false) {\n      this.nodes.push(node);\n      this.setHashNode(node, node.getHash(this));\n    }\n  }\n  buildUpdateNodes() {\n    for (const node of this.nodes) {\n      const updateType = node.getUpdateType();\n      const updateBeforeType = node.getUpdateBeforeType();\n      if (updateType !== NodeUpdateType.NONE) {\n        this.updateNodes.push(node.getSelf());\n      }\n      if (updateBeforeType !== NodeUpdateType.NONE) {\n        this.updateBeforeNodes.push(node);\n      }\n    }\n  }\n  get currentNode() {\n    return this.chaining[this.chaining.length - 1];\n  }\n  addChain(node) {\n    /*\n    if ( this.chaining.indexOf( node ) !== - 1 ) {\n    \t\tconsole.warn( 'Recursive node: ', node );\n    \t}\n    */\n\n    this.chaining.push(node);\n  }\n  removeChain(node) {\n    const lastChain = this.chaining.pop();\n    if (lastChain !== node) {\n      throw new Error('NodeBuilder: Invalid node chaining!');\n    }\n  }\n  getMethod(method) {\n    return method;\n  }\n  getNodeFromHash(hash) {\n    return this.hashNodes[hash];\n  }\n  addFlow(shaderStage, node) {\n    this.flowNodes[shaderStage].push(node);\n    return node;\n  }\n  setContext(context) {\n    this.context = context;\n  }\n  getContext() {\n    return this.context;\n  }\n  setCache(cache) {\n    this.cache = cache;\n  }\n  getCache() {\n    return this.cache;\n  }\n  isAvailable( /*name*/\n  ) {\n    return false;\n  }\n  getVertexIndex() {\n    console.warn('Abstract function.');\n  }\n  getInstanceIndex() {\n    console.warn('Abstract function.');\n  }\n  getFrontFacing() {\n    console.warn('Abstract function.');\n  }\n  getFragCoord() {\n    console.warn('Abstract function.');\n  }\n  isFlipY() {\n    return false;\n  }\n  generateTexture( /* texture, textureProperty, uvSnippet */\n  ) {\n    console.warn('Abstract function.');\n  }\n  generateTextureLod( /* texture, textureProperty, uvSnippet, levelSnippet */\n  ) {\n    console.warn('Abstract function.');\n  }\n  generateConst(type, value = null) {\n    if (value === null) {\n      if (type === 'float' || type === 'int' || type === 'uint') value = 0;else if (type === 'bool') value = false;else if (type === 'color') value = new Color();else if (type === 'vec2') value = new Vector2();else if (type === 'vec3') value = new Vector3();else if (type === 'vec4') value = new Vector4();\n    }\n    if (type === 'float') return toFloat(value);\n    if (type === 'int') return `${Math.round(value)}`;\n    if (type === 'uint') return value >= 0 ? `${Math.round(value)}u` : '0u';\n    if (type === 'bool') return value ? 'true' : 'false';\n    if (type === 'color') return `${this.getType('vec3')}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;\n    const typeLength = this.getTypeLength(type);\n    const componentType = this.getComponentType(type);\n    const generateConst = value => this.generateConst(componentType, value);\n    if (typeLength === 2) {\n      return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)} )`;\n    } else if (typeLength === 3) {\n      return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)}, ${generateConst(value.z)} )`;\n    } else if (typeLength === 4) {\n      return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)}, ${generateConst(value.z)}, ${generateConst(value.w)} )`;\n    } else if (typeLength > 4 && value && (value.isMatrix3 || value.isMatrix4)) {\n      return `${this.getType(type)}( ${value.elements.map(generateConst).join(', ')} )`;\n    } else if (typeLength > 4) {\n      return `${this.getType(type)}()`;\n    }\n    throw new Error(`NodeBuilder: Type '${type}' not found in generate constant attempt.`);\n  }\n  getType(type) {\n    if (type === 'color') return 'vec3';\n    return type;\n  }\n  hasGeometryAttribute(name) {\n    return this.geometry && this.geometry.getAttribute(name) !== undefined;\n  }\n  getAttribute(name, type) {\n    const attributes = this.attributes;\n\n    // find attribute\n\n    for (const attribute of attributes) {\n      if (attribute.name === name) {\n        return attribute;\n      }\n    }\n\n    // create a new if no exist\n\n    const attribute = new NodeAttribute(name, type);\n    attributes.push(attribute);\n    return attribute;\n  }\n  getPropertyName(node /*, shaderStage*/) {\n    return node.name;\n  }\n  isVector(type) {\n    return /vec\\d/.test(type);\n  }\n  isMatrix(type) {\n    return /mat\\d/.test(type);\n  }\n  isReference(type) {\n    return type === 'void' || type === 'property' || type === 'sampler' || type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D';\n  }\n  needsColorSpaceToLinear( /*texture*/\n  ) {\n    return false;\n  }\n  getComponentTypeFromTexture(texture) {\n    const type = texture.type;\n    if (texture.isDataTexture) {\n      if (type === IntType) return 'int';\n      if (type === UnsignedIntType) return 'uint';\n    }\n    return 'float';\n  }\n  getElementType(type) {\n    if (type === 'mat2') return 'vec2';\n    if (type === 'mat3') return 'vec3';\n    if (type === 'mat4') return 'vec4';\n    return this.getComponentType(type);\n  }\n  getComponentType(type) {\n    type = this.getVectorType(type);\n    if (type === 'float' || type === 'bool' || type === 'int' || type === 'uint') return type;\n    const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type);\n    if (componentType === null) return null;\n    if (componentType[1] === 'b') return 'bool';\n    if (componentType[1] === 'i') return 'int';\n    if (componentType[1] === 'u') return 'uint';\n    return 'float';\n  }\n  getVectorType(type) {\n    if (type === 'color') return 'vec3';\n    if (type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D') return 'vec4';\n    return type;\n  }\n  getTypeFromLength(length, componentType = 'float') {\n    if (length === 1) return componentType;\n    const baseType = typeFromLength.get(length);\n    const prefix = componentType === 'float' ? '' : componentType[0];\n    return prefix + baseType;\n  }\n  getTypeFromArray(array) {\n    return typeFromArray.get(array.constructor);\n  }\n  getTypeFromAttribute(attribute) {\n    let dataAttribute = attribute;\n    if (attribute.isInterleavedBufferAttribute) dataAttribute = attribute.data;\n    const array = dataAttribute.array;\n    const itemSize = attribute.itemSize;\n    const normalized = attribute.normalized;\n    let arrayType;\n    if (!(attribute instanceof Float16BufferAttribute) && normalized !== true) {\n      arrayType = this.getTypeFromArray(array);\n    }\n    return this.getTypeFromLength(itemSize, arrayType);\n  }\n  getTypeLength(type) {\n    const vecType = this.getVectorType(type);\n    const vecNum = /vec([2-4])/.exec(vecType);\n    if (vecNum !== null) return Number(vecNum[1]);\n    if (vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint') return 1;\n    if (/mat2/.test(type) === true) return 4;\n    if (/mat3/.test(type) === true) return 9;\n    if (/mat4/.test(type) === true) return 16;\n    return 0;\n  }\n  getVectorFromMatrix(type) {\n    return type.replace('mat', 'vec');\n  }\n  changeComponentType(type, newComponentType) {\n    return this.getTypeFromLength(this.getTypeLength(type), newComponentType);\n  }\n  getIntegerType(type) {\n    const componentType = this.getComponentType(type);\n    if (componentType === 'int' || componentType === 'uint') return type;\n    return this.changeComponentType(type, 'int');\n  }\n  addStack() {\n    this.stack = stack(this.stack);\n    this.stacks.push(getCurrentStack() || this.stack);\n    setCurrentStack(this.stack);\n    return this.stack;\n  }\n  removeStack() {\n    const lastStack = this.stack;\n    this.stack = lastStack.parent;\n    setCurrentStack(this.stacks.pop());\n    return lastStack;\n  }\n  getDataFromNode(node, shaderStage = this.shaderStage, cache = null) {\n    cache = cache === null ? node.isGlobal(this) ? this.globalCache : this.cache : cache;\n    let nodeData = cache.getNodeData(node);\n    if (nodeData === undefined) {\n      nodeData = {};\n      cache.setNodeData(node, nodeData);\n    }\n    if (nodeData[shaderStage] === undefined) nodeData[shaderStage] = {};\n    return nodeData[shaderStage];\n  }\n  getNodeProperties(node, shaderStage = 'any') {\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    return nodeData.properties || (nodeData.properties = {\n      outputNode: null\n    });\n  }\n  getBufferAttributeFromNode(node, type) {\n    const nodeData = this.getDataFromNode(node);\n    let bufferAttribute = nodeData.bufferAttribute;\n    if (bufferAttribute === undefined) {\n      const index = this.uniforms.index++;\n      bufferAttribute = new NodeAttribute('nodeAttribute' + index, type, node);\n      this.bufferAttributes.push(bufferAttribute);\n      nodeData.bufferAttribute = bufferAttribute;\n    }\n    return bufferAttribute;\n  }\n  getStructTypeFromNode(node, shaderStage = this.shaderStage) {\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    if (nodeData.structType === undefined) {\n      const index = this.structs.index++;\n      node.name = `StructType${index}`;\n      this.structs[shaderStage].push(node);\n      nodeData.structType = node;\n    }\n    return node;\n  }\n  getUniformFromNode(node, type, shaderStage = this.shaderStage, name = null) {\n    const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);\n    let nodeUniform = nodeData.uniform;\n    if (nodeUniform === undefined) {\n      const index = this.uniforms.index++;\n      nodeUniform = new NodeUniform(name || 'nodeUniform' + index, type, node);\n      this.uniforms[shaderStage].push(nodeUniform);\n      nodeData.uniform = nodeUniform;\n    }\n    return nodeUniform;\n  }\n  getVarFromNode(node, name = null, type = node.getNodeType(this), shaderStage = this.shaderStage) {\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    let nodeVar = nodeData.variable;\n    if (nodeVar === undefined) {\n      const vars = this.vars[shaderStage] || (this.vars[shaderStage] = []);\n      if (name === null) name = 'nodeVar' + vars.length;\n      nodeVar = new NodeVar(name, type);\n      vars.push(nodeVar);\n      nodeData.variable = nodeVar;\n    }\n    return nodeVar;\n  }\n  getVaryingFromNode(node, name = null, type = node.getNodeType(this)) {\n    const nodeData = this.getDataFromNode(node, 'any');\n    let nodeVarying = nodeData.varying;\n    if (nodeVarying === undefined) {\n      const varyings = this.varyings;\n      const index = varyings.length;\n      if (name === null) name = 'nodeVarying' + index;\n      nodeVarying = new NodeVarying(name, type);\n      varyings.push(nodeVarying);\n      nodeData.varying = nodeVarying;\n    }\n    return nodeVarying;\n  }\n  getCodeFromNode(node, type, shaderStage = this.shaderStage) {\n    const nodeData = this.getDataFromNode(node);\n    let nodeCode = nodeData.code;\n    if (nodeCode === undefined) {\n      const codes = this.codes[shaderStage] || (this.codes[shaderStage] = []);\n      const index = codes.length;\n      nodeCode = new NodeCode('nodeCode' + index, type);\n      codes.push(nodeCode);\n      nodeData.code = nodeCode;\n    }\n    return nodeCode;\n  }\n  addLineFlowCode(code) {\n    if (code === '') return this;\n    code = this.tab + code;\n    if (!/;\\s*$/.test(code)) {\n      code = code + ';\\n';\n    }\n    this.flow.code += code;\n    return this;\n  }\n  addFlowCode(code) {\n    this.flow.code += code;\n    return this;\n  }\n  addFlowTab() {\n    this.tab += '\\t';\n    return this;\n  }\n  removeFlowTab() {\n    this.tab = this.tab.slice(0, -1);\n    return this;\n  }\n  getFlowData(node /*, shaderStage*/) {\n    return this.flowsData.get(node);\n  }\n  flowNode(node) {\n    const output = node.getNodeType(this);\n    const flowData = this.flowChildNode(node, output);\n    this.flowsData.set(node, flowData);\n    return flowData;\n  }\n  buildFunctionNode(shaderNode) {\n    const fn = new FunctionNode();\n    const previous = this.currentFunctionNode;\n    this.currentFunctionNode = fn;\n    fn.code = this.buildFunctionCode(shaderNode);\n    this.currentFunctionNode = previous;\n    return fn;\n  }\n  flowShaderNode(shaderNode) {\n    const layout = shaderNode.layout;\n    let inputs;\n    if (shaderNode.isArrayInput) {\n      inputs = [];\n      for (const input of layout.inputs) {\n        inputs.push(new ParameterNode(input.type, input.name));\n      }\n    } else {\n      inputs = {};\n      for (const input of layout.inputs) {\n        inputs[input.name] = new ParameterNode(input.type, input.name);\n      }\n    }\n\n    //\n\n    shaderNode.layout = null;\n    const callNode = shaderNode.call(inputs);\n    const flowData = this.flowStagesNode(callNode, layout.type);\n    shaderNode.layout = layout;\n    return flowData;\n  }\n  flowStagesNode(node, output = null) {\n    const previousFlow = this.flow;\n    const previousVars = this.vars;\n    const previousCache = this.cache;\n    const previousBuildStage = this.buildStage;\n    const previousStack = this.stack;\n    const flow = {\n      code: ''\n    };\n    this.flow = flow;\n    this.vars = {};\n    this.cache = new NodeCache();\n    this.stack = stack();\n    for (const buildStage of defaultBuildStages) {\n      this.setBuildStage(buildStage);\n      flow.result = node.build(this, output);\n    }\n    flow.vars = this.getVars(this.shaderStage);\n    this.flow = previousFlow;\n    this.vars = previousVars;\n    this.cache = previousCache;\n    this.stack = previousStack;\n    this.setBuildStage(previousBuildStage);\n    return flow;\n  }\n  getFunctionOperator() {\n    return null;\n  }\n  flowChildNode(node, output = null) {\n    const previousFlow = this.flow;\n    const flow = {\n      code: ''\n    };\n    this.flow = flow;\n    flow.result = node.build(this, output);\n    this.flow = previousFlow;\n    return flow;\n  }\n  flowNodeFromShaderStage(shaderStage, node, output = null, propertyName = null) {\n    const previousShaderStage = this.shaderStage;\n    this.setShaderStage(shaderStage);\n    const flowData = this.flowChildNode(node, output);\n    if (propertyName !== null) {\n      flowData.code += `${this.tab + propertyName} = ${flowData.result};\\n`;\n    }\n    this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;\n    this.setShaderStage(previousShaderStage);\n    return flowData;\n  }\n  getAttributesArray() {\n    return this.attributes.concat(this.bufferAttributes);\n  }\n  getAttributes( /*shaderStage*/\n  ) {\n    console.warn('Abstract function.');\n  }\n  getVaryings( /*shaderStage*/\n  ) {\n    console.warn('Abstract function.');\n  }\n  getVar(type, name) {\n    return `${this.getType(type)} ${name}`;\n  }\n  getVars(shaderStage) {\n    let snippet = '';\n    const vars = this.vars[shaderStage];\n    if (vars !== undefined) {\n      for (const variable of vars) {\n        snippet += `${this.getVar(variable.type, variable.name)}; `;\n      }\n    }\n    return snippet;\n  }\n  getUniforms( /*shaderStage*/\n  ) {\n    console.warn('Abstract function.');\n  }\n  getCodes(shaderStage) {\n    const codes = this.codes[shaderStage];\n    let code = '';\n    if (codes !== undefined) {\n      for (const nodeCode of codes) {\n        code += nodeCode.code + '\\n';\n      }\n    }\n    return code;\n  }\n  getHash() {\n    return this.vertexShader + this.fragmentShader + this.computeShader;\n  }\n  setShaderStage(shaderStage) {\n    this.shaderStage = shaderStage;\n  }\n  getShaderStage() {\n    return this.shaderStage;\n  }\n  setBuildStage(buildStage) {\n    this.buildStage = buildStage;\n  }\n  getBuildStage() {\n    return this.buildStage;\n  }\n  buildCode() {\n    console.warn('Abstract function.');\n  }\n  build() {\n    const {\n      object,\n      material\n    } = this;\n    if (material !== null) {\n      NodeMaterial.fromMaterial(material).build(this);\n    } else {\n      this.addFlow('compute', object);\n    }\n\n    // setup() -> stage 1: create possible new nodes and returns an output reference node\n    // analyze()   -> stage 2: analyze nodes to possible optimization and validation\n    // generate()  -> stage 3: generate shader\n\n    for (const buildStage of defaultBuildStages) {\n      this.setBuildStage(buildStage);\n      if (this.context.vertex && this.context.vertex.isNode) {\n        this.flowNodeFromShaderStage('vertex', this.context.vertex);\n      }\n      for (const shaderStage of shaderStages) {\n        this.setShaderStage(shaderStage);\n        const flowNodes = this.flowNodes[shaderStage];\n        for (const node of flowNodes) {\n          if (buildStage === 'generate') {\n            this.flowNode(node);\n          } else {\n            node.build(this);\n          }\n        }\n      }\n    }\n    this.setBuildStage(null);\n    this.setShaderStage(null);\n\n    // stage 4: build code for a specific output\n\n    this.buildCode();\n    this.buildUpdateNodes();\n    return this;\n  }\n  getNodeUniform(uniformNode, type) {\n    if (type === 'float') return new FloatNodeUniform(uniformNode);\n    if (type === 'vec2') return new Vector2NodeUniform(uniformNode);\n    if (type === 'vec3') return new Vector3NodeUniform(uniformNode);\n    if (type === 'vec4') return new Vector4NodeUniform(uniformNode);\n    if (type === 'color') return new ColorNodeUniform(uniformNode);\n    if (type === 'mat3') return new Matrix3NodeUniform(uniformNode);\n    if (type === 'mat4') return new Matrix4NodeUniform(uniformNode);\n    throw new Error(`Uniform \"${type}\" not declared.`);\n  }\n  createNodeMaterial(type = 'NodeMaterial') {\n    // TODO: Move Materials.js to outside of the Nodes.js in order to remove this function and improve tree-shaking support\n\n    return createNodeMaterialFromType(type);\n  }\n  format(snippet, fromType, toType) {\n    fromType = this.getVectorType(fromType);\n    toType = this.getVectorType(toType);\n    if (fromType === toType || toType === null || this.isReference(toType)) {\n      return snippet;\n    }\n    const fromTypeLength = this.getTypeLength(fromType);\n    const toTypeLength = this.getTypeLength(toType);\n    if (fromTypeLength > 4) {\n      // fromType is matrix-like\n\n      // @TODO: ignore for now\n\n      return snippet;\n    }\n    if (toTypeLength > 4 || toTypeLength === 0) {\n      // toType is matrix-like or unknown\n\n      // @TODO: ignore for now\n\n      return snippet;\n    }\n    if (fromTypeLength === toTypeLength) {\n      return `${this.getType(toType)}( ${snippet} )`;\n    }\n    if (fromTypeLength > toTypeLength) {\n      return this.format(`${snippet}.${'xyz'.slice(0, toTypeLength)}`, this.getTypeFromLength(toTypeLength, this.getComponentType(fromType)), toType);\n    }\n    if (toTypeLength === 4 && fromTypeLength > 1) {\n      // toType is vec4-like\n\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec3')}, 1.0 )`;\n    }\n    if (fromTypeLength === 2) {\n      // fromType is vec2-like and toType is vec3-like\n\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec2')}, 0.0 )`;\n    }\n    if (fromTypeLength === 1 && toTypeLength > 1 && fromType[0] !== toType[0]) {\n      // fromType is float-like\n\n      // convert a number value to vector type, e.g:\n      // vec3( 1u ) -> vec3( float( 1u ) )\n\n      snippet = `${this.getType(this.getComponentType(toType))}( ${snippet} )`;\n    }\n    return `${this.getType(toType)}( ${snippet} )`; // fromType is float-like\n  }\n\n  getSignature() {\n    return `// Three.js r${REVISION} - NodeMaterial System\\n`;\n  }\n}\nexport default NodeBuilder;","map":{"version":3,"names":["NodeUniform","NodeAttribute","NodeVarying","NodeVar","NodeCode","NodeKeywords","NodeCache","ParameterNode","FunctionNode","createNodeMaterialFromType","default","NodeMaterial","NodeUpdateType","defaultBuildStages","shaderStages","FloatNodeUniform","Vector2NodeUniform","Vector3NodeUniform","Vector4NodeUniform","ColorNodeUniform","Matrix3NodeUniform","Matrix4NodeUniform","REVISION","RenderTarget","Color","Vector2","Vector3","Vector4","IntType","UnsignedIntType","Float16BufferAttribute","stack","getCurrentStack","setCurrentStack","CubeRenderTarget","ChainMap","PMREMGenerator","uniformsGroupCache","typeFromLength","Map","typeFromArray","Int8Array","Int16Array","Int32Array","Uint8Array","Uint16Array","Uint32Array","Float32Array","toFloat","value","Number","NodeBuilder","constructor","object","renderer","parser","scene","material","geometry","nodes","updateNodes","updateBeforeNodes","hashNodes","lightsNode","environmentNode","fogNode","clippingContext","vertexShader","fragmentShader","computeShader","flowNodes","vertex","fragment","compute","flowCode","uniforms","index","structs","bindings","bindingsOffset","bindingsArray","attributes","bufferAttributes","varyings","codes","vars","flow","code","chaining","stacks","tab","currentFunctionNode","context","keywords","cache","globalCache","flowsData","WeakMap","shaderStage","buildStage","createRenderTarget","width","height","options","createCubeRenderTarget","size","createPMREMGenerator","includes","node","_getSharedBindings","shared","binding","getNodes","sharedBinding","get","undefined","set","push","getBindings","setHashNode","hash","addNode","getHash","buildUpdateNodes","updateType","getUpdateType","updateBeforeType","getUpdateBeforeType","NONE","getSelf","currentNode","length","addChain","removeChain","lastChain","pop","Error","getMethod","method","getNodeFromHash","addFlow","setContext","getContext","setCache","getCache","isAvailable","getVertexIndex","console","warn","getInstanceIndex","getFrontFacing","getFragCoord","isFlipY","generateTexture","generateTextureLod","generateConst","type","Math","round","getType","r","g","b","typeLength","getTypeLength","componentType","getComponentType","x","y","z","w","isMatrix3","isMatrix4","elements","map","join","hasGeometryAttribute","name","getAttribute","attribute","getPropertyName","isVector","test","isMatrix","isReference","needsColorSpaceToLinear","getComponentTypeFromTexture","texture","isDataTexture","getElementType","getVectorType","exec","getTypeFromLength","baseType","prefix","getTypeFromArray","array","getTypeFromAttribute","dataAttribute","isInterleavedBufferAttribute","data","itemSize","normalized","arrayType","vecType","vecNum","getVectorFromMatrix","replace","changeComponentType","newComponentType","getIntegerType","addStack","removeStack","lastStack","parent","getDataFromNode","isGlobal","nodeData","getNodeData","setNodeData","getNodeProperties","properties","outputNode","getBufferAttributeFromNode","bufferAttribute","getStructTypeFromNode","structType","getUniformFromNode","nodeUniform","uniform","getVarFromNode","getNodeType","nodeVar","variable","getVaryingFromNode","nodeVarying","varying","getCodeFromNode","nodeCode","addLineFlowCode","addFlowCode","addFlowTab","removeFlowTab","slice","getFlowData","flowNode","output","flowData","flowChildNode","buildFunctionNode","shaderNode","fn","previous","buildFunctionCode","flowShaderNode","layout","inputs","isArrayInput","input","callNode","call","flowStagesNode","previousFlow","previousVars","previousCache","previousBuildStage","previousStack","setBuildStage","result","build","getVars","getFunctionOperator","flowNodeFromShaderStage","propertyName","previousShaderStage","setShaderStage","getAttributesArray","concat","getAttributes","getVaryings","getVar","snippet","getUniforms","getCodes","getShaderStage","getBuildStage","buildCode","fromMaterial","isNode","getNodeUniform","uniformNode","createNodeMaterial","format","fromType","toType","fromTypeLength","toTypeLength","getSignature"],"sources":["D:/dumps/online-learning-platform-main/Frontend/node_modules/three/examples/jsm/nodes/core/NodeBuilder.js"],"sourcesContent":["import NodeUniform from './NodeUniform.js';\nimport NodeAttribute from './NodeAttribute.js';\nimport NodeVarying from './NodeVarying.js';\nimport NodeVar from './NodeVar.js';\nimport NodeCode from './NodeCode.js';\nimport NodeKeywords from './NodeKeywords.js';\nimport NodeCache from './NodeCache.js';\nimport ParameterNode from './ParameterNode.js';\nimport FunctionNode from '../code/FunctionNode.js';\nimport { createNodeMaterialFromType, default as NodeMaterial } from '../materials/NodeMaterial.js';\nimport { NodeUpdateType, defaultBuildStages, shaderStages } from './constants.js';\n\nimport {\n\tFloatNodeUniform, Vector2NodeUniform, Vector3NodeUniform, Vector4NodeUniform,\n\tColorNodeUniform, Matrix3NodeUniform, Matrix4NodeUniform\n} from '../../renderers/common/nodes/NodeUniform.js';\n\nimport { REVISION, RenderTarget, Color, Vector2, Vector3, Vector4, IntType, UnsignedIntType, Float16BufferAttribute } from 'three';\n\nimport { stack } from './StackNode.js';\nimport { getCurrentStack, setCurrentStack } from '../shadernode/ShaderNode.js';\n\nimport CubeRenderTarget from '../../renderers/common/CubeRenderTarget.js';\nimport ChainMap from '../../renderers/common/ChainMap.js';\n\nimport PMREMGenerator from '../../renderers/common/extras/PMREMGenerator.js';\n\nconst uniformsGroupCache = new ChainMap();\n\nconst typeFromLength = new Map( [\n\t[ 2, 'vec2' ],\n\t[ 3, 'vec3' ],\n\t[ 4, 'vec4' ],\n\t[ 9, 'mat3' ],\n\t[ 16, 'mat4' ]\n] );\n\nconst typeFromArray = new Map( [\n\t[ Int8Array, 'int' ],\n\t[ Int16Array, 'int' ],\n\t[ Int32Array, 'int' ],\n\t[ Uint8Array, 'uint' ],\n\t[ Uint16Array, 'uint' ],\n\t[ Uint32Array, 'uint' ],\n\t[ Float32Array, 'float' ]\n] );\n\nconst toFloat = ( value ) => {\n\n\tvalue = Number( value );\n\n\treturn value + ( value % 1 ? '' : '.0' );\n\n};\n\nclass NodeBuilder {\n\n\tconstructor( object, renderer, parser, scene = null, material = null ) {\n\n\t\tthis.object = object;\n\t\tthis.material = material || ( object && object.material ) || null;\n\t\tthis.geometry = ( object && object.geometry ) || null;\n\t\tthis.renderer = renderer;\n\t\tthis.parser = parser;\n\t\tthis.scene = scene;\n\n\t\tthis.nodes = [];\n\t\tthis.updateNodes = [];\n\t\tthis.updateBeforeNodes = [];\n\t\tthis.hashNodes = {};\n\n\t\tthis.lightsNode = null;\n\t\tthis.environmentNode = null;\n\t\tthis.fogNode = null;\n\n\t\tthis.clippingContext = null;\n\n\t\tthis.vertexShader = null;\n\t\tthis.fragmentShader = null;\n\t\tthis.computeShader = null;\n\n\t\tthis.flowNodes = { vertex: [], fragment: [], compute: [] };\n\t\tthis.flowCode = { vertex: '', fragment: '', compute: '' };\n\t\tthis.uniforms = { vertex: [], fragment: [], compute: [], index: 0 };\n\t\tthis.structs = { vertex: [], fragment: [], compute: [], index: 0 };\n\t\tthis.bindings = { vertex: [], fragment: [], compute: [] };\n\t\tthis.bindingsOffset = { vertex: 0, fragment: 0, compute: 0 };\n\t\tthis.bindingsArray = null;\n\t\tthis.attributes = [];\n\t\tthis.bufferAttributes = [];\n\t\tthis.varyings = [];\n\t\tthis.codes = {};\n\t\tthis.vars = {};\n\t\tthis.flow = { code: '' };\n\t\tthis.chaining = [];\n\t\tthis.stack = stack();\n\t\tthis.stacks = [];\n\t\tthis.tab = '\\t';\n\n\t\tthis.currentFunctionNode = null;\n\n\t\tthis.context = {\n\t\t\tkeywords: new NodeKeywords(),\n\t\t\tmaterial: this.material\n\t\t};\n\n\t\tthis.cache = new NodeCache();\n\t\tthis.globalCache = this.cache;\n\n\t\tthis.flowsData = new WeakMap();\n\n\t\tthis.shaderStage = null;\n\t\tthis.buildStage = null;\n\n\t}\n\n\tcreateRenderTarget( width, height, options ) {\n\n\t\treturn new RenderTarget( width, height, options );\n\n\t}\n\n\tcreateCubeRenderTarget( size, options ) {\n\n\t\treturn new CubeRenderTarget( size, options );\n\n\t}\n\n\tcreatePMREMGenerator() {\n\n\t\t// TODO: Move Materials.js to outside of the Nodes.js in order to remove this function and improve tree-shaking support\n\n\t\treturn new PMREMGenerator( this.renderer );\n\n\t}\n\n\tincludes( node ) {\n\n\t\treturn this.nodes.includes( node );\n\n\t}\n\n\t_getSharedBindings( bindings ) {\n\n\t\tconst shared = [];\n\n\t\tfor ( const binding of bindings ) {\n\n\t\t\tif ( binding.shared === true ) {\n\n\t\t\t\t// nodes is the chainmap key\n\t\t\t\tconst nodes = binding.getNodes();\n\n\t\t\t\tlet sharedBinding = uniformsGroupCache.get( nodes );\n\n\t\t\t\tif ( sharedBinding === undefined ) {\n\n\t\t\t\t\tuniformsGroupCache.set( nodes, binding );\n\n\t\t\t\t\tsharedBinding = binding;\n\n\t\t\t\t}\n\n\t\t\t\tshared.push( sharedBinding );\n\n\t\t\t} else {\n\n\t\t\t\tshared.push( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn shared;\n\n\t}\n\n\tgetBindings() {\n\n\t\tlet bindingsArray = this.bindingsArray;\n\n\t\tif ( bindingsArray === null ) {\n\n\t\t\tconst bindings = this.bindings;\n\n\t\t\tthis.bindingsArray = bindingsArray = this._getSharedBindings( ( this.material !== null ) ? [ ...bindings.vertex, ...bindings.fragment ] : bindings.compute );\n\n\t\t}\n\n\t\treturn bindingsArray;\n\n\t}\n\n\tsetHashNode( node, hash ) {\n\n\t\tthis.hashNodes[ hash ] = node;\n\n\t}\n\n\taddNode( node ) {\n\n\t\tif ( this.nodes.includes( node ) === false ) {\n\n\t\t\tthis.nodes.push( node );\n\n\t\t\tthis.setHashNode( node, node.getHash( this ) );\n\n\t\t}\n\n\t}\n\n\tbuildUpdateNodes() {\n\n\t\tfor ( const node of this.nodes ) {\n\n\t\t\tconst updateType = node.getUpdateType();\n\t\t\tconst updateBeforeType = node.getUpdateBeforeType();\n\n\t\t\tif ( updateType !== NodeUpdateType.NONE ) {\n\n\t\t\t\tthis.updateNodes.push( node.getSelf() );\n\n\t\t\t}\n\n\t\t\tif ( updateBeforeType !== NodeUpdateType.NONE ) {\n\n\t\t\t\tthis.updateBeforeNodes.push( node );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tget currentNode() {\n\n\t\treturn this.chaining[ this.chaining.length - 1 ];\n\n\t}\n\n\taddChain( node ) {\n\n\t\t/*\n\t\tif ( this.chaining.indexOf( node ) !== - 1 ) {\n\n\t\t\tconsole.warn( 'Recursive node: ', node );\n\n\t\t}\n\t\t*/\n\n\t\tthis.chaining.push( node );\n\n\t}\n\n\tremoveChain( node ) {\n\n\t\tconst lastChain = this.chaining.pop();\n\n\t\tif ( lastChain !== node ) {\n\n\t\t\tthrow new Error( 'NodeBuilder: Invalid node chaining!' );\n\n\t\t}\n\n\t}\n\n\tgetMethod( method ) {\n\n\t\treturn method;\n\n\t}\n\n\tgetNodeFromHash( hash ) {\n\n\t\treturn this.hashNodes[ hash ];\n\n\t}\n\n\taddFlow( shaderStage, node ) {\n\n\t\tthis.flowNodes[ shaderStage ].push( node );\n\n\t\treturn node;\n\n\t}\n\n\tsetContext( context ) {\n\n\t\tthis.context = context;\n\n\t}\n\n\tgetContext() {\n\n\t\treturn this.context;\n\n\t}\n\n\tsetCache( cache ) {\n\n\t\tthis.cache = cache;\n\n\t}\n\n\tgetCache() {\n\n\t\treturn this.cache;\n\n\t}\n\n\tisAvailable( /*name*/ ) {\n\n\t\treturn false;\n\n\t}\n\n\tgetVertexIndex() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetInstanceIndex() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetFrontFacing() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetFragCoord() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tisFlipY() {\n\n\t\treturn false;\n\n\t}\n\n\tgenerateTexture( /* texture, textureProperty, uvSnippet */ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgenerateTextureLod( /* texture, textureProperty, uvSnippet, levelSnippet */ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgenerateConst( type, value = null ) {\n\n\t\tif ( value === null ) {\n\n\t\t\tif ( type === 'float' || type === 'int' || type === 'uint' ) value = 0;\n\t\t\telse if ( type === 'bool' ) value = false;\n\t\t\telse if ( type === 'color' ) value = new Color();\n\t\t\telse if ( type === 'vec2' ) value = new Vector2();\n\t\t\telse if ( type === 'vec3' ) value = new Vector3();\n\t\t\telse if ( type === 'vec4' ) value = new Vector4();\n\n\t\t}\n\n\t\tif ( type === 'float' ) return toFloat( value );\n\t\tif ( type === 'int' ) return `${ Math.round( value ) }`;\n\t\tif ( type === 'uint' ) return value >= 0 ? `${ Math.round( value ) }u` : '0u';\n\t\tif ( type === 'bool' ) return value ? 'true' : 'false';\n\t\tif ( type === 'color' ) return `${ this.getType( 'vec3' ) }( ${ toFloat( value.r ) }, ${ toFloat( value.g ) }, ${ toFloat( value.b ) } )`;\n\n\t\tconst typeLength = this.getTypeLength( type );\n\n\t\tconst componentType = this.getComponentType( type );\n\n\t\tconst generateConst = value => this.generateConst( componentType, value );\n\n\t\tif ( typeLength === 2 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) } )`;\n\n\t\t} else if ( typeLength === 3 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) }, ${ generateConst( value.z ) } )`;\n\n\t\t} else if ( typeLength === 4 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) }, ${ generateConst( value.z ) }, ${ generateConst( value.w ) } )`;\n\n\t\t} else if ( typeLength > 4 && value && ( value.isMatrix3 || value.isMatrix4 ) ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ value.elements.map( generateConst ).join( ', ' ) } )`;\n\n\t\t} else if ( typeLength > 4 ) {\n\n\t\t\treturn `${ this.getType( type ) }()`;\n\n\t\t}\n\n\t\tthrow new Error( `NodeBuilder: Type '${type}' not found in generate constant attempt.` );\n\n\t}\n\n\tgetType( type ) {\n\n\t\tif ( type === 'color' ) return 'vec3';\n\n\t\treturn type;\n\n\t}\n\n\thasGeometryAttribute( name ) {\n\n\t\treturn this.geometry && this.geometry.getAttribute( name ) !== undefined;\n\n\t}\n\n\tgetAttribute( name, type ) {\n\n\t\tconst attributes = this.attributes;\n\n\t\t// find attribute\n\n\t\tfor ( const attribute of attributes ) {\n\n\t\t\tif ( attribute.name === name ) {\n\n\t\t\t\treturn attribute;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// create a new if no exist\n\n\t\tconst attribute = new NodeAttribute( name, type );\n\n\t\tattributes.push( attribute );\n\n\t\treturn attribute;\n\n\t}\n\n\tgetPropertyName( node/*, shaderStage*/ ) {\n\n\t\treturn node.name;\n\n\t}\n\n\tisVector( type ) {\n\n\t\treturn /vec\\d/.test( type );\n\n\t}\n\n\tisMatrix( type ) {\n\n\t\treturn /mat\\d/.test( type );\n\n\t}\n\n\tisReference( type ) {\n\n\t\treturn type === 'void' || type === 'property' || type === 'sampler' || type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D';\n\n\t}\n\n\tneedsColorSpaceToLinear( /*texture*/ ) {\n\n\t\treturn false;\n\n\t}\n\n\tgetComponentTypeFromTexture( texture ) {\n\n\t\tconst type = texture.type;\n\n\t\tif ( texture.isDataTexture ) {\n\n\t\t\tif ( type === IntType ) return 'int';\n\t\t\tif ( type === UnsignedIntType ) return 'uint';\n\n\t\t}\n\n\t\treturn 'float';\n\n\t}\n\n\tgetElementType( type ) {\n\n\t\tif ( type === 'mat2' ) return 'vec2';\n\t\tif ( type === 'mat3' ) return 'vec3';\n\t\tif ( type === 'mat4' ) return 'vec4';\n\n\t\treturn this.getComponentType( type );\n\n\t}\n\n\tgetComponentType( type ) {\n\n\t\ttype = this.getVectorType( type );\n\n\t\tif ( type === 'float' || type === 'bool' || type === 'int' || type === 'uint' ) return type;\n\n\t\tconst componentType = /(b|i|u|)(vec|mat)([2-4])/.exec( type );\n\n\t\tif ( componentType === null ) return null;\n\n\t\tif ( componentType[ 1 ] === 'b' ) return 'bool';\n\t\tif ( componentType[ 1 ] === 'i' ) return 'int';\n\t\tif ( componentType[ 1 ] === 'u' ) return 'uint';\n\n\t\treturn 'float';\n\n\t}\n\n\tgetVectorType( type ) {\n\n\t\tif ( type === 'color' ) return 'vec3';\n\t\tif ( type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D' ) return 'vec4';\n\n\t\treturn type;\n\n\t}\n\n\tgetTypeFromLength( length, componentType = 'float' ) {\n\n\t\tif ( length === 1 ) return componentType;\n\n\t\tconst baseType = typeFromLength.get( length );\n\t\tconst prefix = componentType === 'float' ? '' : componentType[ 0 ];\n\n\t\treturn prefix + baseType;\n\n\t}\n\n\tgetTypeFromArray( array ) {\n\n\t\treturn typeFromArray.get( array.constructor );\n\n\t}\n\n\tgetTypeFromAttribute( attribute ) {\n\n\t\tlet dataAttribute = attribute;\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) dataAttribute = attribute.data;\n\n\t\tconst array = dataAttribute.array;\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst normalized = attribute.normalized;\n\n\t\tlet arrayType;\n\n\t\tif ( ! ( attribute instanceof Float16BufferAttribute ) && normalized !== true ) {\n\n\t\t\tarrayType = this.getTypeFromArray( array );\n\n\t\t}\n\n\t\treturn this.getTypeFromLength( itemSize, arrayType );\n\n\t}\n\n\tgetTypeLength( type ) {\n\n\t\tconst vecType = this.getVectorType( type );\n\t\tconst vecNum = /vec([2-4])/.exec( vecType );\n\n\t\tif ( vecNum !== null ) return Number( vecNum[ 1 ] );\n\t\tif ( vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint' ) return 1;\n\t\tif ( /mat2/.test( type ) === true ) return 4;\n\t\tif ( /mat3/.test( type ) === true ) return 9;\n\t\tif ( /mat4/.test( type ) === true ) return 16;\n\n\t\treturn 0;\n\n\t}\n\n\tgetVectorFromMatrix( type ) {\n\n\t\treturn type.replace( 'mat', 'vec' );\n\n\t}\n\n\tchangeComponentType( type, newComponentType ) {\n\n\t\treturn this.getTypeFromLength( this.getTypeLength( type ), newComponentType );\n\n\t}\n\n\tgetIntegerType( type ) {\n\n\t\tconst componentType = this.getComponentType( type );\n\n\t\tif ( componentType === 'int' || componentType === 'uint' ) return type;\n\n\t\treturn this.changeComponentType( type, 'int' );\n\n\t}\n\n\taddStack() {\n\n\t\tthis.stack = stack( this.stack );\n\n\t\tthis.stacks.push( getCurrentStack() || this.stack );\n\t\tsetCurrentStack( this.stack );\n\n\t\treturn this.stack;\n\n\t}\n\n\tremoveStack() {\n\n\t\tconst lastStack = this.stack;\n\t\tthis.stack = lastStack.parent;\n\n\t\tsetCurrentStack( this.stacks.pop() );\n\n\t\treturn lastStack;\n\n\t}\n\n\tgetDataFromNode( node, shaderStage = this.shaderStage, cache = null ) {\n\n\t\tcache = cache === null ? ( node.isGlobal( this ) ? this.globalCache : this.cache ) : cache;\n\n\t\tlet nodeData = cache.getNodeData( node );\n\n\t\tif ( nodeData === undefined ) {\n\n\t\t\tnodeData = {};\n\n\t\t\tcache.setNodeData( node, nodeData );\n\n\t\t}\n\n\t\tif ( nodeData[ shaderStage ] === undefined ) nodeData[ shaderStage ] = {};\n\n\t\treturn nodeData[ shaderStage ];\n\n\t}\n\n\tgetNodeProperties( node, shaderStage = 'any' ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\treturn nodeData.properties || ( nodeData.properties = { outputNode: null } );\n\n\t}\n\n\tgetBufferAttributeFromNode( node, type ) {\n\n\t\tconst nodeData = this.getDataFromNode( node );\n\n\t\tlet bufferAttribute = nodeData.bufferAttribute;\n\n\t\tif ( bufferAttribute === undefined ) {\n\n\t\t\tconst index = this.uniforms.index ++;\n\n\t\t\tbufferAttribute = new NodeAttribute( 'nodeAttribute' + index, type, node );\n\n\t\t\tthis.bufferAttributes.push( bufferAttribute );\n\n\t\t\tnodeData.bufferAttribute = bufferAttribute;\n\n\t\t}\n\n\t\treturn bufferAttribute;\n\n\t}\n\n\tgetStructTypeFromNode( node, shaderStage = this.shaderStage ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\tif ( nodeData.structType === undefined ) {\n\n\t\t\tconst index = this.structs.index ++;\n\n\t\t\tnode.name = `StructType${ index }`;\n\t\t\tthis.structs[ shaderStage ].push( node );\n\n\t\t\tnodeData.structType = node;\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\tgetUniformFromNode( node, type, shaderStage = this.shaderStage, name = null ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );\n\n\t\tlet nodeUniform = nodeData.uniform;\n\n\t\tif ( nodeUniform === undefined ) {\n\n\t\t\tconst index = this.uniforms.index ++;\n\n\t\t\tnodeUniform = new NodeUniform( name || ( 'nodeUniform' + index ), type, node );\n\n\t\t\tthis.uniforms[ shaderStage ].push( nodeUniform );\n\n\t\t\tnodeData.uniform = nodeUniform;\n\n\t\t}\n\n\t\treturn nodeUniform;\n\n\t}\n\n\tgetVarFromNode( node, name = null, type = node.getNodeType( this ), shaderStage = this.shaderStage ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\tlet nodeVar = nodeData.variable;\n\n\t\tif ( nodeVar === undefined ) {\n\n\t\t\tconst vars = this.vars[ shaderStage ] || ( this.vars[ shaderStage ] = [] );\n\n\t\t\tif ( name === null ) name = 'nodeVar' + vars.length;\n\n\t\t\tnodeVar = new NodeVar( name, type );\n\n\t\t\tvars.push( nodeVar );\n\n\t\t\tnodeData.variable = nodeVar;\n\n\t\t}\n\n\t\treturn nodeVar;\n\n\t}\n\n\tgetVaryingFromNode( node, name = null, type = node.getNodeType( this ) ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, 'any' );\n\n\t\tlet nodeVarying = nodeData.varying;\n\n\t\tif ( nodeVarying === undefined ) {\n\n\t\t\tconst varyings = this.varyings;\n\t\t\tconst index = varyings.length;\n\n\t\t\tif ( name === null ) name = 'nodeVarying' + index;\n\n\t\t\tnodeVarying = new NodeVarying( name, type );\n\n\t\t\tvaryings.push( nodeVarying );\n\n\t\t\tnodeData.varying = nodeVarying;\n\n\t\t}\n\n\t\treturn nodeVarying;\n\n\t}\n\n\tgetCodeFromNode( node, type, shaderStage = this.shaderStage ) {\n\n\t\tconst nodeData = this.getDataFromNode( node );\n\n\t\tlet nodeCode = nodeData.code;\n\n\t\tif ( nodeCode === undefined ) {\n\n\t\t\tconst codes = this.codes[ shaderStage ] || ( this.codes[ shaderStage ] = [] );\n\t\t\tconst index = codes.length;\n\n\t\t\tnodeCode = new NodeCode( 'nodeCode' + index, type );\n\n\t\t\tcodes.push( nodeCode );\n\n\t\t\tnodeData.code = nodeCode;\n\n\t\t}\n\n\t\treturn nodeCode;\n\n\t}\n\n\taddLineFlowCode( code ) {\n\n\t\tif ( code === '' ) return this;\n\n\t\tcode = this.tab + code;\n\n\t\tif ( ! /;\\s*$/.test( code ) ) {\n\n\t\t\tcode = code + ';\\n';\n\n\t\t}\n\n\t\tthis.flow.code += code;\n\n\t\treturn this;\n\n\t}\n\n\taddFlowCode( code ) {\n\n\t\tthis.flow.code += code;\n\n\t\treturn this;\n\n\t}\n\n\taddFlowTab() {\n\n\t\tthis.tab += '\\t';\n\n\t\treturn this;\n\n\t}\n\n\tremoveFlowTab() {\n\n\t\tthis.tab = this.tab.slice( 0, - 1 );\n\n\t\treturn this;\n\n\t}\n\n\tgetFlowData( node/*, shaderStage*/ ) {\n\n\t\treturn this.flowsData.get( node );\n\n\t}\n\n\tflowNode( node ) {\n\n\t\tconst output = node.getNodeType( this );\n\n\t\tconst flowData = this.flowChildNode( node, output );\n\n\t\tthis.flowsData.set( node, flowData );\n\n\t\treturn flowData;\n\n\t}\n\n\tbuildFunctionNode( shaderNode ) {\n\n\t\tconst fn = new FunctionNode();\n\n\t\tconst previous = this.currentFunctionNode;\n\n\t\tthis.currentFunctionNode = fn;\n\n\t\tfn.code = this.buildFunctionCode( shaderNode );\n\n\t\tthis.currentFunctionNode = previous;\n\n\t\treturn fn;\n\n\t}\n\n\tflowShaderNode( shaderNode ) {\n\n\t\tconst layout = shaderNode.layout;\n\n\t\tlet inputs;\n\n\t\tif ( shaderNode.isArrayInput ) {\n\n\t\t\tinputs = [];\n\n\t\t\tfor ( const input of layout.inputs ) {\n\n\t\t\t\tinputs.push( new ParameterNode( input.type, input.name ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tinputs = {};\n\n\t\t\tfor ( const input of layout.inputs ) {\n\n\t\t\t\tinputs[ input.name ] = new ParameterNode( input.type, input.name );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tshaderNode.layout = null;\n\n\t\tconst callNode = shaderNode.call( inputs );\n\t\tconst flowData = this.flowStagesNode( callNode, layout.type );\n\n\t\tshaderNode.layout = layout;\n\n\t\treturn flowData;\n\n\t}\n\n\tflowStagesNode( node, output = null ) {\n\n\t\tconst previousFlow = this.flow;\n\t\tconst previousVars = this.vars;\n\t\tconst previousCache = this.cache;\n\t\tconst previousBuildStage = this.buildStage;\n\t\tconst previousStack = this.stack;\n\n\t\tconst flow = {\n\t\t\tcode: ''\n\t\t};\n\n\t\tthis.flow = flow;\n\t\tthis.vars = {};\n\t\tthis.cache = new NodeCache();\n\t\tthis.stack = stack();\n\n\t\tfor ( const buildStage of defaultBuildStages ) {\n\n\t\t\tthis.setBuildStage( buildStage );\n\n\t\t\tflow.result = node.build( this, output );\n\n\t\t}\n\n\t\tflow.vars = this.getVars( this.shaderStage );\n\n\t\tthis.flow = previousFlow;\n\t\tthis.vars = previousVars;\n\t\tthis.cache = previousCache;\n\t\tthis.stack = previousStack;\n\n\t\tthis.setBuildStage( previousBuildStage );\n\n\t\treturn flow;\n\n\t}\n\n\tgetFunctionOperator() {\n\n\t\treturn null;\n\n\t}\n\n\tflowChildNode( node, output = null ) {\n\n\t\tconst previousFlow = this.flow;\n\n\t\tconst flow = {\n\t\t\tcode: ''\n\t\t};\n\n\t\tthis.flow = flow;\n\n\t\tflow.result = node.build( this, output );\n\n\t\tthis.flow = previousFlow;\n\n\t\treturn flow;\n\n\t}\n\n\tflowNodeFromShaderStage( shaderStage, node, output = null, propertyName = null ) {\n\n\t\tconst previousShaderStage = this.shaderStage;\n\n\t\tthis.setShaderStage( shaderStage );\n\n\t\tconst flowData = this.flowChildNode( node, output );\n\n\t\tif ( propertyName !== null ) {\n\n\t\t\tflowData.code += `${ this.tab + propertyName } = ${ flowData.result };\\n`;\n\n\t\t}\n\n\t\tthis.flowCode[ shaderStage ] = this.flowCode[ shaderStage ] + flowData.code;\n\n\t\tthis.setShaderStage( previousShaderStage );\n\n\t\treturn flowData;\n\n\t}\n\n\tgetAttributesArray() {\n\n\t\treturn this.attributes.concat( this.bufferAttributes );\n\n\t}\n\n\tgetAttributes( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetVaryings( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetVar( type, name ) {\n\n\t\treturn `${ this.getType( type ) } ${ name }`;\n\n\t}\n\n\tgetVars( shaderStage ) {\n\n\t\tlet snippet = '';\n\n\t\tconst vars = this.vars[ shaderStage ];\n\n\t\tif ( vars !== undefined ) {\n\n\t\t\tfor ( const variable of vars ) {\n\n\t\t\t\tsnippet += `${ this.getVar( variable.type, variable.name ) }; `;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tgetUniforms( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetCodes( shaderStage ) {\n\n\t\tconst codes = this.codes[ shaderStage ];\n\n\t\tlet code = '';\n\n\t\tif ( codes !== undefined ) {\n\n\t\t\tfor ( const nodeCode of codes ) {\n\n\t\t\t\tcode += nodeCode.code + '\\n';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn code;\n\n\t}\n\n\tgetHash() {\n\n\t\treturn this.vertexShader + this.fragmentShader + this.computeShader;\n\n\t}\n\n\tsetShaderStage( shaderStage ) {\n\n\t\tthis.shaderStage = shaderStage;\n\n\t}\n\n\tgetShaderStage() {\n\n\t\treturn this.shaderStage;\n\n\t}\n\n\tsetBuildStage( buildStage ) {\n\n\t\tthis.buildStage = buildStage;\n\n\t}\n\n\tgetBuildStage() {\n\n\t\treturn this.buildStage;\n\n\t}\n\n\tbuildCode() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tbuild() {\n\n\t\tconst { object, material } = this;\n\n\n\t\tif ( material !== null ) {\n\n\t\t\tNodeMaterial.fromMaterial( material ).build( this );\n\n\t\t} else {\n\n\t\t\tthis.addFlow( 'compute', object );\n\n\t\t}\n\n\t\t// setup() -> stage 1: create possible new nodes and returns an output reference node\n\t\t// analyze()   -> stage 2: analyze nodes to possible optimization and validation\n\t\t// generate()  -> stage 3: generate shader\n\n\t\tfor ( const buildStage of defaultBuildStages ) {\n\n\t\t\tthis.setBuildStage( buildStage );\n\n\t\t\tif ( this.context.vertex && this.context.vertex.isNode ) {\n\n\t\t\t\tthis.flowNodeFromShaderStage( 'vertex', this.context.vertex );\n\n\t\t\t}\n\n\t\t\tfor ( const shaderStage of shaderStages ) {\n\n\t\t\t\tthis.setShaderStage( shaderStage );\n\n\t\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\n\n\t\t\t\tfor ( const node of flowNodes ) {\n\n\t\t\t\t\tif ( buildStage === 'generate' ) {\n\n\t\t\t\t\t\tthis.flowNode( node );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnode.build( this );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setBuildStage( null );\n\t\tthis.setShaderStage( null );\n\n\t\t// stage 4: build code for a specific output\n\n\t\tthis.buildCode();\n\t\tthis.buildUpdateNodes();\n\n\t\treturn this;\n\n\t}\n\n\tgetNodeUniform( uniformNode, type ) {\n\n\t\tif ( type === 'float' ) return new FloatNodeUniform( uniformNode );\n\t\tif ( type === 'vec2' ) return new Vector2NodeUniform( uniformNode );\n\t\tif ( type === 'vec3' ) return new Vector3NodeUniform( uniformNode );\n\t\tif ( type === 'vec4' ) return new Vector4NodeUniform( uniformNode );\n\t\tif ( type === 'color' ) return new ColorNodeUniform( uniformNode );\n\t\tif ( type === 'mat3' ) return new Matrix3NodeUniform( uniformNode );\n\t\tif ( type === 'mat4' ) return new Matrix4NodeUniform( uniformNode );\n\n\t\tthrow new Error( `Uniform \"${type}\" not declared.` );\n\n\t}\n\n\tcreateNodeMaterial( type = 'NodeMaterial' ) {\n\n\t\t// TODO: Move Materials.js to outside of the Nodes.js in order to remove this function and improve tree-shaking support\n\n\t\treturn createNodeMaterialFromType( type );\n\n\t}\n\n\tformat( snippet, fromType, toType ) {\n\n\t\tfromType = this.getVectorType( fromType );\n\t\ttoType = this.getVectorType( toType );\n\n\t\tif ( fromType === toType || toType === null || this.isReference( toType ) ) {\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tconst fromTypeLength = this.getTypeLength( fromType );\n\t\tconst toTypeLength = this.getTypeLength( toType );\n\n\t\tif ( fromTypeLength > 4 ) { // fromType is matrix-like\n\n\t\t\t// @TODO: ignore for now\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tif ( toTypeLength > 4 || toTypeLength === 0 ) { // toType is matrix-like or unknown\n\n\t\t\t// @TODO: ignore for now\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tif ( fromTypeLength === toTypeLength ) {\n\n\t\t\treturn `${ this.getType( toType ) }( ${ snippet } )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength > toTypeLength ) {\n\n\t\t\treturn this.format( `${ snippet }.${ 'xyz'.slice( 0, toTypeLength ) }`, this.getTypeFromLength( toTypeLength, this.getComponentType( fromType ) ), toType );\n\n\t\t}\n\n\t\tif ( toTypeLength === 4 && fromTypeLength > 1 ) { // toType is vec4-like\n\n\t\t\treturn `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec3' ) }, 1.0 )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength === 2 ) { // fromType is vec2-like and toType is vec3-like\n\n\t\t\treturn `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec2' ) }, 0.0 )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength === 1 && toTypeLength > 1 && fromType[ 0 ] !== toType[ 0 ] ) { // fromType is float-like\n\n\t\t\t// convert a number value to vector type, e.g:\n\t\t\t// vec3( 1u ) -> vec3( float( 1u ) )\n\n\t\t\tsnippet = `${ this.getType( this.getComponentType( toType ) ) }( ${ snippet } )`;\n\n\t\t}\n\n\t\treturn `${ this.getType( toType ) }( ${ snippet } )`; // fromType is float-like\n\n\t}\n\n\tgetSignature() {\n\n\t\treturn `// Three.js r${ REVISION } - NodeMaterial System\\n`;\n\n\t}\n\n}\n\nexport default NodeBuilder;\n"],"mappings":"AAAA,OAAOA,WAAW,MAAM,kBAAkB;AAC1C,OAAOC,aAAa,MAAM,oBAAoB;AAC9C,OAAOC,WAAW,MAAM,kBAAkB;AAC1C,OAAOC,OAAO,MAAM,cAAc;AAClC,OAAOC,QAAQ,MAAM,eAAe;AACpC,OAAOC,YAAY,MAAM,mBAAmB;AAC5C,OAAOC,SAAS,MAAM,gBAAgB;AACtC,OAAOC,aAAa,MAAM,oBAAoB;AAC9C,OAAOC,YAAY,MAAM,yBAAyB;AAClD,SAASC,0BAA0B,EAAEC,OAAO,IAAIC,YAAY,QAAQ,8BAA8B;AAClG,SAASC,cAAc,EAAEC,kBAAkB,EAAEC,YAAY,QAAQ,gBAAgB;AAEjF,SACCC,gBAAgB,EAAEC,kBAAkB,EAAEC,kBAAkB,EAAEC,kBAAkB,EAC5EC,gBAAgB,EAAEC,kBAAkB,EAAEC,kBAAkB,QAClD,6CAA6C;AAEpD,SAASC,QAAQ,EAAEC,YAAY,EAAEC,KAAK,EAAEC,OAAO,EAAEC,OAAO,EAAEC,OAAO,EAAEC,OAAO,EAAEC,eAAe,EAAEC,sBAAsB,QAAQ,OAAO;AAElI,SAASC,KAAK,QAAQ,gBAAgB;AACtC,SAASC,eAAe,EAAEC,eAAe,QAAQ,6BAA6B;AAE9E,OAAOC,gBAAgB,MAAM,4CAA4C;AACzE,OAAOC,QAAQ,MAAM,oCAAoC;AAEzD,OAAOC,cAAc,MAAM,iDAAiD;AAE5E,MAAMC,kBAAkB,GAAG,IAAIF,QAAQ,CAAC,CAAC;AAEzC,MAAMG,cAAc,GAAG,IAAIC,GAAG,CAAE,CAC/B,CAAE,CAAC,EAAE,MAAM,CAAE,EACb,CAAE,CAAC,EAAE,MAAM,CAAE,EACb,CAAE,CAAC,EAAE,MAAM,CAAE,EACb,CAAE,CAAC,EAAE,MAAM,CAAE,EACb,CAAE,EAAE,EAAE,MAAM,CAAE,CACb,CAAC;AAEH,MAAMC,aAAa,GAAG,IAAID,GAAG,CAAE,CAC9B,CAAEE,SAAS,EAAE,KAAK,CAAE,EACpB,CAAEC,UAAU,EAAE,KAAK,CAAE,EACrB,CAAEC,UAAU,EAAE,KAAK,CAAE,EACrB,CAAEC,UAAU,EAAE,MAAM,CAAE,EACtB,CAAEC,WAAW,EAAE,MAAM,CAAE,EACvB,CAAEC,WAAW,EAAE,MAAM,CAAE,EACvB,CAAEC,YAAY,EAAE,OAAO,CAAE,CACxB,CAAC;AAEH,MAAMC,OAAO,GAAKC,KAAK,IAAM;EAE5BA,KAAK,GAAGC,MAAM,CAAED,KAAM,CAAC;EAEvB,OAAOA,KAAK,IAAKA,KAAK,GAAG,CAAC,GAAG,EAAE,GAAG,IAAI,CAAE;AAEzC,CAAC;AAED,MAAME,WAAW,CAAC;EAEjBC,WAAWA,CAAEC,MAAM,EAAEC,QAAQ,EAAEC,MAAM,EAAEC,KAAK,GAAG,IAAI,EAAEC,QAAQ,GAAG,IAAI,EAAG;IAEtE,IAAI,CAACJ,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACI,QAAQ,GAAGA,QAAQ,IAAMJ,MAAM,IAAIA,MAAM,CAACI,QAAU,IAAI,IAAI;IACjE,IAAI,CAACC,QAAQ,GAAKL,MAAM,IAAIA,MAAM,CAACK,QAAQ,IAAM,IAAI;IACrD,IAAI,CAACJ,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,KAAK,GAAGA,KAAK;IAElB,IAAI,CAACG,KAAK,GAAG,EAAE;IACf,IAAI,CAACC,WAAW,GAAG,EAAE;IACrB,IAAI,CAACC,iBAAiB,GAAG,EAAE;IAC3B,IAAI,CAACC,SAAS,GAAG,CAAC,CAAC;IAEnB,IAAI,CAACC,UAAU,GAAG,IAAI;IACtB,IAAI,CAACC,eAAe,GAAG,IAAI;IAC3B,IAAI,CAACC,OAAO,GAAG,IAAI;IAEnB,IAAI,CAACC,eAAe,GAAG,IAAI;IAE3B,IAAI,CAACC,YAAY,GAAG,IAAI;IACxB,IAAI,CAACC,cAAc,GAAG,IAAI;IAC1B,IAAI,CAACC,aAAa,GAAG,IAAI;IAEzB,IAAI,CAACC,SAAS,GAAG;MAAEC,MAAM,EAAE,EAAE;MAAEC,QAAQ,EAAE,EAAE;MAAEC,OAAO,EAAE;IAAG,CAAC;IAC1D,IAAI,CAACC,QAAQ,GAAG;MAAEH,MAAM,EAAE,EAAE;MAAEC,QAAQ,EAAE,EAAE;MAAEC,OAAO,EAAE;IAAG,CAAC;IACzD,IAAI,CAACE,QAAQ,GAAG;MAAEJ,MAAM,EAAE,EAAE;MAAEC,QAAQ,EAAE,EAAE;MAAEC,OAAO,EAAE,EAAE;MAAEG,KAAK,EAAE;IAAE,CAAC;IACnE,IAAI,CAACC,OAAO,GAAG;MAAEN,MAAM,EAAE,EAAE;MAAEC,QAAQ,EAAE,EAAE;MAAEC,OAAO,EAAE,EAAE;MAAEG,KAAK,EAAE;IAAE,CAAC;IAClE,IAAI,CAACE,QAAQ,GAAG;MAAEP,MAAM,EAAE,EAAE;MAAEC,QAAQ,EAAE,EAAE;MAAEC,OAAO,EAAE;IAAG,CAAC;IACzD,IAAI,CAACM,cAAc,GAAG;MAAER,MAAM,EAAE,CAAC;MAAEC,QAAQ,EAAE,CAAC;MAAEC,OAAO,EAAE;IAAE,CAAC;IAC5D,IAAI,CAACO,aAAa,GAAG,IAAI;IACzB,IAAI,CAACC,UAAU,GAAG,EAAE;IACpB,IAAI,CAACC,gBAAgB,GAAG,EAAE;IAC1B,IAAI,CAACC,QAAQ,GAAG,EAAE;IAClB,IAAI,CAACC,KAAK,GAAG,CAAC,CAAC;IACf,IAAI,CAACC,IAAI,GAAG,CAAC,CAAC;IACd,IAAI,CAACC,IAAI,GAAG;MAAEC,IAAI,EAAE;IAAG,CAAC;IACxB,IAAI,CAACC,QAAQ,GAAG,EAAE;IAClB,IAAI,CAACzD,KAAK,GAAGA,KAAK,CAAC,CAAC;IACpB,IAAI,CAAC0D,MAAM,GAAG,EAAE;IAChB,IAAI,CAACC,GAAG,GAAG,IAAI;IAEf,IAAI,CAACC,mBAAmB,GAAG,IAAI;IAE/B,IAAI,CAACC,OAAO,GAAG;MACdC,QAAQ,EAAE,IAAIxF,YAAY,CAAC,CAAC;MAC5BoD,QAAQ,EAAE,IAAI,CAACA;IAChB,CAAC;IAED,IAAI,CAACqC,KAAK,GAAG,IAAIxF,SAAS,CAAC,CAAC;IAC5B,IAAI,CAACyF,WAAW,GAAG,IAAI,CAACD,KAAK;IAE7B,IAAI,CAACE,SAAS,GAAG,IAAIC,OAAO,CAAC,CAAC;IAE9B,IAAI,CAACC,WAAW,GAAG,IAAI;IACvB,IAAI,CAACC,UAAU,GAAG,IAAI;EAEvB;EAEAC,kBAAkBA,CAAEC,KAAK,EAAEC,MAAM,EAAEC,OAAO,EAAG;IAE5C,OAAO,IAAIhF,YAAY,CAAE8E,KAAK,EAAEC,MAAM,EAAEC,OAAQ,CAAC;EAElD;EAEAC,sBAAsBA,CAAEC,IAAI,EAAEF,OAAO,EAAG;IAEvC,OAAO,IAAIrE,gBAAgB,CAAEuE,IAAI,EAAEF,OAAQ,CAAC;EAE7C;EAEAG,oBAAoBA,CAAA,EAAG;IAEtB;;IAEA,OAAO,IAAItE,cAAc,CAAE,IAAI,CAACkB,QAAS,CAAC;EAE3C;EAEAqD,QAAQA,CAAEC,IAAI,EAAG;IAEhB,OAAO,IAAI,CAACjD,KAAK,CAACgD,QAAQ,CAAEC,IAAK,CAAC;EAEnC;EAEAC,kBAAkBA,CAAE/B,QAAQ,EAAG;IAE9B,MAAMgC,MAAM,GAAG,EAAE;IAEjB,KAAM,MAAMC,OAAO,IAAIjC,QAAQ,EAAG;MAEjC,IAAKiC,OAAO,CAACD,MAAM,KAAK,IAAI,EAAG;QAE9B;QACA,MAAMnD,KAAK,GAAGoD,OAAO,CAACC,QAAQ,CAAC,CAAC;QAEhC,IAAIC,aAAa,GAAG5E,kBAAkB,CAAC6E,GAAG,CAAEvD,KAAM,CAAC;QAEnD,IAAKsD,aAAa,KAAKE,SAAS,EAAG;UAElC9E,kBAAkB,CAAC+E,GAAG,CAAEzD,KAAK,EAAEoD,OAAQ,CAAC;UAExCE,aAAa,GAAGF,OAAO;QAExB;QAEAD,MAAM,CAACO,IAAI,CAAEJ,aAAc,CAAC;MAE7B,CAAC,MAAM;QAENH,MAAM,CAACO,IAAI,CAAEN,OAAQ,CAAC;MAEvB;IAED;IAEA,OAAOD,MAAM;EAEd;EAEAQ,WAAWA,CAAA,EAAG;IAEb,IAAItC,aAAa,GAAG,IAAI,CAACA,aAAa;IAEtC,IAAKA,aAAa,KAAK,IAAI,EAAG;MAE7B,MAAMF,QAAQ,GAAG,IAAI,CAACA,QAAQ;MAE9B,IAAI,CAACE,aAAa,GAAGA,aAAa,GAAG,IAAI,CAAC6B,kBAAkB,CAAI,IAAI,CAACpD,QAAQ,KAAK,IAAI,GAAK,CAAE,GAAGqB,QAAQ,CAACP,MAAM,EAAE,GAAGO,QAAQ,CAACN,QAAQ,CAAE,GAAGM,QAAQ,CAACL,OAAQ,CAAC;IAE7J;IAEA,OAAOO,aAAa;EAErB;EAEAuC,WAAWA,CAAEX,IAAI,EAAEY,IAAI,EAAG;IAEzB,IAAI,CAAC1D,SAAS,CAAE0D,IAAI,CAAE,GAAGZ,IAAI;EAE9B;EAEAa,OAAOA,CAAEb,IAAI,EAAG;IAEf,IAAK,IAAI,CAACjD,KAAK,CAACgD,QAAQ,CAAEC,IAAK,CAAC,KAAK,KAAK,EAAG;MAE5C,IAAI,CAACjD,KAAK,CAAC0D,IAAI,CAAET,IAAK,CAAC;MAEvB,IAAI,CAACW,WAAW,CAAEX,IAAI,EAAEA,IAAI,CAACc,OAAO,CAAE,IAAK,CAAE,CAAC;IAE/C;EAED;EAEAC,gBAAgBA,CAAA,EAAG;IAElB,KAAM,MAAMf,IAAI,IAAI,IAAI,CAACjD,KAAK,EAAG;MAEhC,MAAMiE,UAAU,GAAGhB,IAAI,CAACiB,aAAa,CAAC,CAAC;MACvC,MAAMC,gBAAgB,GAAGlB,IAAI,CAACmB,mBAAmB,CAAC,CAAC;MAEnD,IAAKH,UAAU,KAAKhH,cAAc,CAACoH,IAAI,EAAG;QAEzC,IAAI,CAACpE,WAAW,CAACyD,IAAI,CAAET,IAAI,CAACqB,OAAO,CAAC,CAAE,CAAC;MAExC;MAEA,IAAKH,gBAAgB,KAAKlH,cAAc,CAACoH,IAAI,EAAG;QAE/C,IAAI,CAACnE,iBAAiB,CAACwD,IAAI,CAAET,IAAK,CAAC;MAEpC;IAED;EAED;EAEA,IAAIsB,WAAWA,CAAA,EAAG;IAEjB,OAAO,IAAI,CAAC1C,QAAQ,CAAE,IAAI,CAACA,QAAQ,CAAC2C,MAAM,GAAG,CAAC,CAAE;EAEjD;EAEAC,QAAQA,CAAExB,IAAI,EAAG;IAEhB;AACF;AACA;AACA;AACA;;IAIE,IAAI,CAACpB,QAAQ,CAAC6B,IAAI,CAAET,IAAK,CAAC;EAE3B;EAEAyB,WAAWA,CAAEzB,IAAI,EAAG;IAEnB,MAAM0B,SAAS,GAAG,IAAI,CAAC9C,QAAQ,CAAC+C,GAAG,CAAC,CAAC;IAErC,IAAKD,SAAS,KAAK1B,IAAI,EAAG;MAEzB,MAAM,IAAI4B,KAAK,CAAE,qCAAsC,CAAC;IAEzD;EAED;EAEAC,SAASA,CAAEC,MAAM,EAAG;IAEnB,OAAOA,MAAM;EAEd;EAEAC,eAAeA,CAAEnB,IAAI,EAAG;IAEvB,OAAO,IAAI,CAAC1D,SAAS,CAAE0D,IAAI,CAAE;EAE9B;EAEAoB,OAAOA,CAAE1C,WAAW,EAAEU,IAAI,EAAG;IAE5B,IAAI,CAACtC,SAAS,CAAE4B,WAAW,CAAE,CAACmB,IAAI,CAAET,IAAK,CAAC;IAE1C,OAAOA,IAAI;EAEZ;EAEAiC,UAAUA,CAAEjD,OAAO,EAAG;IAErB,IAAI,CAACA,OAAO,GAAGA,OAAO;EAEvB;EAEAkD,UAAUA,CAAA,EAAG;IAEZ,OAAO,IAAI,CAAClD,OAAO;EAEpB;EAEAmD,QAAQA,CAAEjD,KAAK,EAAG;IAEjB,IAAI,CAACA,KAAK,GAAGA,KAAK;EAEnB;EAEAkD,QAAQA,CAAA,EAAG;IAEV,OAAO,IAAI,CAAClD,KAAK;EAElB;EAEAmD,WAAWA,CAAA,CAAE;EAAA,EAAW;IAEvB,OAAO,KAAK;EAEb;EAEAC,cAAcA,CAAA,EAAG;IAEhBC,OAAO,CAACC,IAAI,CAAE,oBAAqB,CAAC;EAErC;EAEAC,gBAAgBA,CAAA,EAAG;IAElBF,OAAO,CAACC,IAAI,CAAE,oBAAqB,CAAC;EAErC;EAEAE,cAAcA,CAAA,EAAG;IAEhBH,OAAO,CAACC,IAAI,CAAE,oBAAqB,CAAC;EAErC;EAEAG,YAAYA,CAAA,EAAG;IAEdJ,OAAO,CAACC,IAAI,CAAE,oBAAqB,CAAC;EAErC;EAEAI,OAAOA,CAAA,EAAG;IAET,OAAO,KAAK;EAEb;EAEAC,eAAeA,CAAA,CAAE;EAAA,EAA4C;IAE5DN,OAAO,CAACC,IAAI,CAAE,oBAAqB,CAAC;EAErC;EAEAM,kBAAkBA,CAAA,CAAE;EAAA,EAA0D;IAE7EP,OAAO,CAACC,IAAI,CAAE,oBAAqB,CAAC;EAErC;EAEAO,aAAaA,CAAEC,IAAI,EAAE3G,KAAK,GAAG,IAAI,EAAG;IAEnC,IAAKA,KAAK,KAAK,IAAI,EAAG;MAErB,IAAK2G,IAAI,KAAK,OAAO,IAAIA,IAAI,KAAK,KAAK,IAAIA,IAAI,KAAK,MAAM,EAAG3G,KAAK,GAAG,CAAC,CAAC,KAClE,IAAK2G,IAAI,KAAK,MAAM,EAAG3G,KAAK,GAAG,KAAK,CAAC,KACrC,IAAK2G,IAAI,KAAK,OAAO,EAAG3G,KAAK,GAAG,IAAIzB,KAAK,CAAC,CAAC,CAAC,KAC5C,IAAKoI,IAAI,KAAK,MAAM,EAAG3G,KAAK,GAAG,IAAIxB,OAAO,CAAC,CAAC,CAAC,KAC7C,IAAKmI,IAAI,KAAK,MAAM,EAAG3G,KAAK,GAAG,IAAIvB,OAAO,CAAC,CAAC,CAAC,KAC7C,IAAKkI,IAAI,KAAK,MAAM,EAAG3G,KAAK,GAAG,IAAItB,OAAO,CAAC,CAAC;IAElD;IAEA,IAAKiI,IAAI,KAAK,OAAO,EAAG,OAAO5G,OAAO,CAAEC,KAAM,CAAC;IAC/C,IAAK2G,IAAI,KAAK,KAAK,EAAG,OAAQ,GAAGC,IAAI,CAACC,KAAK,CAAE7G,KAAM,CAAG,EAAC;IACvD,IAAK2G,IAAI,KAAK,MAAM,EAAG,OAAO3G,KAAK,IAAI,CAAC,GAAI,GAAG4G,IAAI,CAACC,KAAK,CAAE7G,KAAM,CAAG,GAAE,GAAG,IAAI;IAC7E,IAAK2G,IAAI,KAAK,MAAM,EAAG,OAAO3G,KAAK,GAAG,MAAM,GAAG,OAAO;IACtD,IAAK2G,IAAI,KAAK,OAAO,EAAG,OAAQ,GAAG,IAAI,CAACG,OAAO,CAAE,MAAO,CAAG,KAAK/G,OAAO,CAAEC,KAAK,CAAC+G,CAAE,CAAG,KAAKhH,OAAO,CAAEC,KAAK,CAACgH,CAAE,CAAG,KAAKjH,OAAO,CAAEC,KAAK,CAACiH,CAAE,CAAG,IAAG;IAEzI,MAAMC,UAAU,GAAG,IAAI,CAACC,aAAa,CAAER,IAAK,CAAC;IAE7C,MAAMS,aAAa,GAAG,IAAI,CAACC,gBAAgB,CAAEV,IAAK,CAAC;IAEnD,MAAMD,aAAa,GAAG1G,KAAK,IAAI,IAAI,CAAC0G,aAAa,CAAEU,aAAa,EAAEpH,KAAM,CAAC;IAEzE,IAAKkH,UAAU,KAAK,CAAC,EAAG;MAEvB,OAAQ,GAAG,IAAI,CAACJ,OAAO,CAAEH,IAAK,CAAG,KAAKD,aAAa,CAAE1G,KAAK,CAACsH,CAAE,CAAG,KAAKZ,aAAa,CAAE1G,KAAK,CAACuH,CAAE,CAAG,IAAG;IAEnG,CAAC,MAAM,IAAKL,UAAU,KAAK,CAAC,EAAG;MAE9B,OAAQ,GAAG,IAAI,CAACJ,OAAO,CAAEH,IAAK,CAAG,KAAKD,aAAa,CAAE1G,KAAK,CAACsH,CAAE,CAAG,KAAKZ,aAAa,CAAE1G,KAAK,CAACuH,CAAE,CAAG,KAAKb,aAAa,CAAE1G,KAAK,CAACwH,CAAE,CAAG,IAAG;IAElI,CAAC,MAAM,IAAKN,UAAU,KAAK,CAAC,EAAG;MAE9B,OAAQ,GAAG,IAAI,CAACJ,OAAO,CAAEH,IAAK,CAAG,KAAKD,aAAa,CAAE1G,KAAK,CAACsH,CAAE,CAAG,KAAKZ,aAAa,CAAE1G,KAAK,CAACuH,CAAE,CAAG,KAAKb,aAAa,CAAE1G,KAAK,CAACwH,CAAE,CAAG,KAAKd,aAAa,CAAE1G,KAAK,CAACyH,CAAE,CAAG,IAAG;IAEjK,CAAC,MAAM,IAAKP,UAAU,GAAG,CAAC,IAAIlH,KAAK,KAAMA,KAAK,CAAC0H,SAAS,IAAI1H,KAAK,CAAC2H,SAAS,CAAE,EAAG;MAE/E,OAAQ,GAAG,IAAI,CAACb,OAAO,CAAEH,IAAK,CAAG,KAAK3G,KAAK,CAAC4H,QAAQ,CAACC,GAAG,CAAEnB,aAAc,CAAC,CAACoB,IAAI,CAAE,IAAK,CAAG,IAAG;IAE5F,CAAC,MAAM,IAAKZ,UAAU,GAAG,CAAC,EAAG;MAE5B,OAAQ,GAAG,IAAI,CAACJ,OAAO,CAAEH,IAAK,CAAG,IAAG;IAErC;IAEA,MAAM,IAAIpB,KAAK,CAAG,sBAAqBoB,IAAK,2CAA2C,CAAC;EAEzF;EAEAG,OAAOA,CAAEH,IAAI,EAAG;IAEf,IAAKA,IAAI,KAAK,OAAO,EAAG,OAAO,MAAM;IAErC,OAAOA,IAAI;EAEZ;EAEAoB,oBAAoBA,CAAEC,IAAI,EAAG;IAE5B,OAAO,IAAI,CAACvH,QAAQ,IAAI,IAAI,CAACA,QAAQ,CAACwH,YAAY,CAAED,IAAK,CAAC,KAAK9D,SAAS;EAEzE;EAEA+D,YAAYA,CAAED,IAAI,EAAErB,IAAI,EAAG;IAE1B,MAAM3E,UAAU,GAAG,IAAI,CAACA,UAAU;;IAElC;;IAEA,KAAM,MAAMkG,SAAS,IAAIlG,UAAU,EAAG;MAErC,IAAKkG,SAAS,CAACF,IAAI,KAAKA,IAAI,EAAG;QAE9B,OAAOE,SAAS;MAEjB;IAED;;IAEA;;IAEA,MAAMA,SAAS,GAAG,IAAIlL,aAAa,CAAEgL,IAAI,EAAErB,IAAK,CAAC;IAEjD3E,UAAU,CAACoC,IAAI,CAAE8D,SAAU,CAAC;IAE5B,OAAOA,SAAS;EAEjB;EAEAC,eAAeA,CAAExE,IAAI,oBAAoB;IAExC,OAAOA,IAAI,CAACqE,IAAI;EAEjB;EAEAI,QAAQA,CAAEzB,IAAI,EAAG;IAEhB,OAAO,OAAO,CAAC0B,IAAI,CAAE1B,IAAK,CAAC;EAE5B;EAEA2B,QAAQA,CAAE3B,IAAI,EAAG;IAEhB,OAAO,OAAO,CAAC0B,IAAI,CAAE1B,IAAK,CAAC;EAE5B;EAEA4B,WAAWA,CAAE5B,IAAI,EAAG;IAEnB,OAAOA,IAAI,KAAK,MAAM,IAAIA,IAAI,KAAK,UAAU,IAAIA,IAAI,KAAK,SAAS,IAAIA,IAAI,KAAK,SAAS,IAAIA,IAAI,KAAK,aAAa,IAAIA,IAAI,KAAK,gBAAgB,IAAIA,IAAI,KAAK,WAAW;EAEzK;EAEA6B,uBAAuBA,CAAA,CAAE;EAAA,EAAc;IAEtC,OAAO,KAAK;EAEb;EAEAC,2BAA2BA,CAAEC,OAAO,EAAG;IAEtC,MAAM/B,IAAI,GAAG+B,OAAO,CAAC/B,IAAI;IAEzB,IAAK+B,OAAO,CAACC,aAAa,EAAG;MAE5B,IAAKhC,IAAI,KAAKhI,OAAO,EAAG,OAAO,KAAK;MACpC,IAAKgI,IAAI,KAAK/H,eAAe,EAAG,OAAO,MAAM;IAE9C;IAEA,OAAO,OAAO;EAEf;EAEAgK,cAAcA,CAAEjC,IAAI,EAAG;IAEtB,IAAKA,IAAI,KAAK,MAAM,EAAG,OAAO,MAAM;IACpC,IAAKA,IAAI,KAAK,MAAM,EAAG,OAAO,MAAM;IACpC,IAAKA,IAAI,KAAK,MAAM,EAAG,OAAO,MAAM;IAEpC,OAAO,IAAI,CAACU,gBAAgB,CAAEV,IAAK,CAAC;EAErC;EAEAU,gBAAgBA,CAAEV,IAAI,EAAG;IAExBA,IAAI,GAAG,IAAI,CAACkC,aAAa,CAAElC,IAAK,CAAC;IAEjC,IAAKA,IAAI,KAAK,OAAO,IAAIA,IAAI,KAAK,MAAM,IAAIA,IAAI,KAAK,KAAK,IAAIA,IAAI,KAAK,MAAM,EAAG,OAAOA,IAAI;IAE3F,MAAMS,aAAa,GAAG,0BAA0B,CAAC0B,IAAI,CAAEnC,IAAK,CAAC;IAE7D,IAAKS,aAAa,KAAK,IAAI,EAAG,OAAO,IAAI;IAEzC,IAAKA,aAAa,CAAE,CAAC,CAAE,KAAK,GAAG,EAAG,OAAO,MAAM;IAC/C,IAAKA,aAAa,CAAE,CAAC,CAAE,KAAK,GAAG,EAAG,OAAO,KAAK;IAC9C,IAAKA,aAAa,CAAE,CAAC,CAAE,KAAK,GAAG,EAAG,OAAO,MAAM;IAE/C,OAAO,OAAO;EAEf;EAEAyB,aAAaA,CAAElC,IAAI,EAAG;IAErB,IAAKA,IAAI,KAAK,OAAO,EAAG,OAAO,MAAM;IACrC,IAAKA,IAAI,KAAK,SAAS,IAAIA,IAAI,KAAK,aAAa,IAAIA,IAAI,KAAK,gBAAgB,IAAIA,IAAI,KAAK,WAAW,EAAG,OAAO,MAAM;IAEtH,OAAOA,IAAI;EAEZ;EAEAoC,iBAAiBA,CAAE7D,MAAM,EAAEkC,aAAa,GAAG,OAAO,EAAG;IAEpD,IAAKlC,MAAM,KAAK,CAAC,EAAG,OAAOkC,aAAa;IAExC,MAAM4B,QAAQ,GAAG3J,cAAc,CAAC4E,GAAG,CAAEiB,MAAO,CAAC;IAC7C,MAAM+D,MAAM,GAAG7B,aAAa,KAAK,OAAO,GAAG,EAAE,GAAGA,aAAa,CAAE,CAAC,CAAE;IAElE,OAAO6B,MAAM,GAAGD,QAAQ;EAEzB;EAEAE,gBAAgBA,CAAEC,KAAK,EAAG;IAEzB,OAAO5J,aAAa,CAAC0E,GAAG,CAAEkF,KAAK,CAAChJ,WAAY,CAAC;EAE9C;EAEAiJ,oBAAoBA,CAAElB,SAAS,EAAG;IAEjC,IAAImB,aAAa,GAAGnB,SAAS;IAE7B,IAAKA,SAAS,CAACoB,4BAA4B,EAAGD,aAAa,GAAGnB,SAAS,CAACqB,IAAI;IAE5E,MAAMJ,KAAK,GAAGE,aAAa,CAACF,KAAK;IACjC,MAAMK,QAAQ,GAAGtB,SAAS,CAACsB,QAAQ;IACnC,MAAMC,UAAU,GAAGvB,SAAS,CAACuB,UAAU;IAEvC,IAAIC,SAAS;IAEb,IAAK,EAAIxB,SAAS,YAAYrJ,sBAAsB,CAAE,IAAI4K,UAAU,KAAK,IAAI,EAAG;MAE/EC,SAAS,GAAG,IAAI,CAACR,gBAAgB,CAAEC,KAAM,CAAC;IAE3C;IAEA,OAAO,IAAI,CAACJ,iBAAiB,CAAES,QAAQ,EAAEE,SAAU,CAAC;EAErD;EAEAvC,aAAaA,CAAER,IAAI,EAAG;IAErB,MAAMgD,OAAO,GAAG,IAAI,CAACd,aAAa,CAAElC,IAAK,CAAC;IAC1C,MAAMiD,MAAM,GAAG,YAAY,CAACd,IAAI,CAAEa,OAAQ,CAAC;IAE3C,IAAKC,MAAM,KAAK,IAAI,EAAG,OAAO3J,MAAM,CAAE2J,MAAM,CAAE,CAAC,CAAG,CAAC;IACnD,IAAKD,OAAO,KAAK,OAAO,IAAIA,OAAO,KAAK,MAAM,IAAIA,OAAO,KAAK,KAAK,IAAIA,OAAO,KAAK,MAAM,EAAG,OAAO,CAAC;IACpG,IAAK,MAAM,CAACtB,IAAI,CAAE1B,IAAK,CAAC,KAAK,IAAI,EAAG,OAAO,CAAC;IAC5C,IAAK,MAAM,CAAC0B,IAAI,CAAE1B,IAAK,CAAC,KAAK,IAAI,EAAG,OAAO,CAAC;IAC5C,IAAK,MAAM,CAAC0B,IAAI,CAAE1B,IAAK,CAAC,KAAK,IAAI,EAAG,OAAO,EAAE;IAE7C,OAAO,CAAC;EAET;EAEAkD,mBAAmBA,CAAElD,IAAI,EAAG;IAE3B,OAAOA,IAAI,CAACmD,OAAO,CAAE,KAAK,EAAE,KAAM,CAAC;EAEpC;EAEAC,mBAAmBA,CAAEpD,IAAI,EAAEqD,gBAAgB,EAAG;IAE7C,OAAO,IAAI,CAACjB,iBAAiB,CAAE,IAAI,CAAC5B,aAAa,CAAER,IAAK,CAAC,EAAEqD,gBAAiB,CAAC;EAE9E;EAEAC,cAAcA,CAAEtD,IAAI,EAAG;IAEtB,MAAMS,aAAa,GAAG,IAAI,CAACC,gBAAgB,CAAEV,IAAK,CAAC;IAEnD,IAAKS,aAAa,KAAK,KAAK,IAAIA,aAAa,KAAK,MAAM,EAAG,OAAOT,IAAI;IAEtE,OAAO,IAAI,CAACoD,mBAAmB,CAAEpD,IAAI,EAAE,KAAM,CAAC;EAE/C;EAEAuD,QAAQA,CAAA,EAAG;IAEV,IAAI,CAACpL,KAAK,GAAGA,KAAK,CAAE,IAAI,CAACA,KAAM,CAAC;IAEhC,IAAI,CAAC0D,MAAM,CAAC4B,IAAI,CAAErF,eAAe,CAAC,CAAC,IAAI,IAAI,CAACD,KAAM,CAAC;IACnDE,eAAe,CAAE,IAAI,CAACF,KAAM,CAAC;IAE7B,OAAO,IAAI,CAACA,KAAK;EAElB;EAEAqL,WAAWA,CAAA,EAAG;IAEb,MAAMC,SAAS,GAAG,IAAI,CAACtL,KAAK;IAC5B,IAAI,CAACA,KAAK,GAAGsL,SAAS,CAACC,MAAM;IAE7BrL,eAAe,CAAE,IAAI,CAACwD,MAAM,CAAC8C,GAAG,CAAC,CAAE,CAAC;IAEpC,OAAO8E,SAAS;EAEjB;EAEAE,eAAeA,CAAE3G,IAAI,EAAEV,WAAW,GAAG,IAAI,CAACA,WAAW,EAAEJ,KAAK,GAAG,IAAI,EAAG;IAErEA,KAAK,GAAGA,KAAK,KAAK,IAAI,GAAKc,IAAI,CAAC4G,QAAQ,CAAE,IAAK,CAAC,GAAG,IAAI,CAACzH,WAAW,GAAG,IAAI,CAACD,KAAK,GAAKA,KAAK;IAE1F,IAAI2H,QAAQ,GAAG3H,KAAK,CAAC4H,WAAW,CAAE9G,IAAK,CAAC;IAExC,IAAK6G,QAAQ,KAAKtG,SAAS,EAAG;MAE7BsG,QAAQ,GAAG,CAAC,CAAC;MAEb3H,KAAK,CAAC6H,WAAW,CAAE/G,IAAI,EAAE6G,QAAS,CAAC;IAEpC;IAEA,IAAKA,QAAQ,CAAEvH,WAAW,CAAE,KAAKiB,SAAS,EAAGsG,QAAQ,CAAEvH,WAAW,CAAE,GAAG,CAAC,CAAC;IAEzE,OAAOuH,QAAQ,CAAEvH,WAAW,CAAE;EAE/B;EAEA0H,iBAAiBA,CAAEhH,IAAI,EAAEV,WAAW,GAAG,KAAK,EAAG;IAE9C,MAAMuH,QAAQ,GAAG,IAAI,CAACF,eAAe,CAAE3G,IAAI,EAAEV,WAAY,CAAC;IAE1D,OAAOuH,QAAQ,CAACI,UAAU,KAAMJ,QAAQ,CAACI,UAAU,GAAG;MAAEC,UAAU,EAAE;IAAK,CAAC,CAAE;EAE7E;EAEAC,0BAA0BA,CAAEnH,IAAI,EAAEgD,IAAI,EAAG;IAExC,MAAM6D,QAAQ,GAAG,IAAI,CAACF,eAAe,CAAE3G,IAAK,CAAC;IAE7C,IAAIoH,eAAe,GAAGP,QAAQ,CAACO,eAAe;IAE9C,IAAKA,eAAe,KAAK7G,SAAS,EAAG;MAEpC,MAAMvC,KAAK,GAAG,IAAI,CAACD,QAAQ,CAACC,KAAK,EAAG;MAEpCoJ,eAAe,GAAG,IAAI/N,aAAa,CAAE,eAAe,GAAG2E,KAAK,EAAEgF,IAAI,EAAEhD,IAAK,CAAC;MAE1E,IAAI,CAAC1B,gBAAgB,CAACmC,IAAI,CAAE2G,eAAgB,CAAC;MAE7CP,QAAQ,CAACO,eAAe,GAAGA,eAAe;IAE3C;IAEA,OAAOA,eAAe;EAEvB;EAEAC,qBAAqBA,CAAErH,IAAI,EAAEV,WAAW,GAAG,IAAI,CAACA,WAAW,EAAG;IAE7D,MAAMuH,QAAQ,GAAG,IAAI,CAACF,eAAe,CAAE3G,IAAI,EAAEV,WAAY,CAAC;IAE1D,IAAKuH,QAAQ,CAACS,UAAU,KAAK/G,SAAS,EAAG;MAExC,MAAMvC,KAAK,GAAG,IAAI,CAACC,OAAO,CAACD,KAAK,EAAG;MAEnCgC,IAAI,CAACqE,IAAI,GAAI,aAAarG,KAAO,EAAC;MAClC,IAAI,CAACC,OAAO,CAAEqB,WAAW,CAAE,CAACmB,IAAI,CAAET,IAAK,CAAC;MAExC6G,QAAQ,CAACS,UAAU,GAAGtH,IAAI;IAE3B;IAEA,OAAOA,IAAI;EAEZ;EAEAuH,kBAAkBA,CAAEvH,IAAI,EAAEgD,IAAI,EAAE1D,WAAW,GAAG,IAAI,CAACA,WAAW,EAAE+E,IAAI,GAAG,IAAI,EAAG;IAE7E,MAAMwC,QAAQ,GAAG,IAAI,CAACF,eAAe,CAAE3G,IAAI,EAAEV,WAAW,EAAE,IAAI,CAACH,WAAY,CAAC;IAE5E,IAAIqI,WAAW,GAAGX,QAAQ,CAACY,OAAO;IAElC,IAAKD,WAAW,KAAKjH,SAAS,EAAG;MAEhC,MAAMvC,KAAK,GAAG,IAAI,CAACD,QAAQ,CAACC,KAAK,EAAG;MAEpCwJ,WAAW,GAAG,IAAIpO,WAAW,CAAEiL,IAAI,IAAM,aAAa,GAAGrG,KAAO,EAAEgF,IAAI,EAAEhD,IAAK,CAAC;MAE9E,IAAI,CAACjC,QAAQ,CAAEuB,WAAW,CAAE,CAACmB,IAAI,CAAE+G,WAAY,CAAC;MAEhDX,QAAQ,CAACY,OAAO,GAAGD,WAAW;IAE/B;IAEA,OAAOA,WAAW;EAEnB;EAEAE,cAAcA,CAAE1H,IAAI,EAAEqE,IAAI,GAAG,IAAI,EAAErB,IAAI,GAAGhD,IAAI,CAAC2H,WAAW,CAAE,IAAK,CAAC,EAAErI,WAAW,GAAG,IAAI,CAACA,WAAW,EAAG;IAEpG,MAAMuH,QAAQ,GAAG,IAAI,CAACF,eAAe,CAAE3G,IAAI,EAAEV,WAAY,CAAC;IAE1D,IAAIsI,OAAO,GAAGf,QAAQ,CAACgB,QAAQ;IAE/B,IAAKD,OAAO,KAAKrH,SAAS,EAAG;MAE5B,MAAM9B,IAAI,GAAG,IAAI,CAACA,IAAI,CAAEa,WAAW,CAAE,KAAM,IAAI,CAACb,IAAI,CAAEa,WAAW,CAAE,GAAG,EAAE,CAAE;MAE1E,IAAK+E,IAAI,KAAK,IAAI,EAAGA,IAAI,GAAG,SAAS,GAAG5F,IAAI,CAAC8C,MAAM;MAEnDqG,OAAO,GAAG,IAAIrO,OAAO,CAAE8K,IAAI,EAAErB,IAAK,CAAC;MAEnCvE,IAAI,CAACgC,IAAI,CAAEmH,OAAQ,CAAC;MAEpBf,QAAQ,CAACgB,QAAQ,GAAGD,OAAO;IAE5B;IAEA,OAAOA,OAAO;EAEf;EAEAE,kBAAkBA,CAAE9H,IAAI,EAAEqE,IAAI,GAAG,IAAI,EAAErB,IAAI,GAAGhD,IAAI,CAAC2H,WAAW,CAAE,IAAK,CAAC,EAAG;IAExE,MAAMd,QAAQ,GAAG,IAAI,CAACF,eAAe,CAAE3G,IAAI,EAAE,KAAM,CAAC;IAEpD,IAAI+H,WAAW,GAAGlB,QAAQ,CAACmB,OAAO;IAElC,IAAKD,WAAW,KAAKxH,SAAS,EAAG;MAEhC,MAAMhC,QAAQ,GAAG,IAAI,CAACA,QAAQ;MAC9B,MAAMP,KAAK,GAAGO,QAAQ,CAACgD,MAAM;MAE7B,IAAK8C,IAAI,KAAK,IAAI,EAAGA,IAAI,GAAG,aAAa,GAAGrG,KAAK;MAEjD+J,WAAW,GAAG,IAAIzO,WAAW,CAAE+K,IAAI,EAAErB,IAAK,CAAC;MAE3CzE,QAAQ,CAACkC,IAAI,CAAEsH,WAAY,CAAC;MAE5BlB,QAAQ,CAACmB,OAAO,GAAGD,WAAW;IAE/B;IAEA,OAAOA,WAAW;EAEnB;EAEAE,eAAeA,CAAEjI,IAAI,EAAEgD,IAAI,EAAE1D,WAAW,GAAG,IAAI,CAACA,WAAW,EAAG;IAE7D,MAAMuH,QAAQ,GAAG,IAAI,CAACF,eAAe,CAAE3G,IAAK,CAAC;IAE7C,IAAIkI,QAAQ,GAAGrB,QAAQ,CAAClI,IAAI;IAE5B,IAAKuJ,QAAQ,KAAK3H,SAAS,EAAG;MAE7B,MAAM/B,KAAK,GAAG,IAAI,CAACA,KAAK,CAAEc,WAAW,CAAE,KAAM,IAAI,CAACd,KAAK,CAAEc,WAAW,CAAE,GAAG,EAAE,CAAE;MAC7E,MAAMtB,KAAK,GAAGQ,KAAK,CAAC+C,MAAM;MAE1B2G,QAAQ,GAAG,IAAI1O,QAAQ,CAAE,UAAU,GAAGwE,KAAK,EAAEgF,IAAK,CAAC;MAEnDxE,KAAK,CAACiC,IAAI,CAAEyH,QAAS,CAAC;MAEtBrB,QAAQ,CAAClI,IAAI,GAAGuJ,QAAQ;IAEzB;IAEA,OAAOA,QAAQ;EAEhB;EAEAC,eAAeA,CAAExJ,IAAI,EAAG;IAEvB,IAAKA,IAAI,KAAK,EAAE,EAAG,OAAO,IAAI;IAE9BA,IAAI,GAAG,IAAI,CAACG,GAAG,GAAGH,IAAI;IAEtB,IAAK,CAAE,OAAO,CAAC+F,IAAI,CAAE/F,IAAK,CAAC,EAAG;MAE7BA,IAAI,GAAGA,IAAI,GAAG,KAAK;IAEpB;IAEA,IAAI,CAACD,IAAI,CAACC,IAAI,IAAIA,IAAI;IAEtB,OAAO,IAAI;EAEZ;EAEAyJ,WAAWA,CAAEzJ,IAAI,EAAG;IAEnB,IAAI,CAACD,IAAI,CAACC,IAAI,IAAIA,IAAI;IAEtB,OAAO,IAAI;EAEZ;EAEA0J,UAAUA,CAAA,EAAG;IAEZ,IAAI,CAACvJ,GAAG,IAAI,IAAI;IAEhB,OAAO,IAAI;EAEZ;EAEAwJ,aAAaA,CAAA,EAAG;IAEf,IAAI,CAACxJ,GAAG,GAAG,IAAI,CAACA,GAAG,CAACyJ,KAAK,CAAE,CAAC,EAAE,CAAE,CAAE,CAAC;IAEnC,OAAO,IAAI;EAEZ;EAEAC,WAAWA,CAAExI,IAAI,oBAAoB;IAEpC,OAAO,IAAI,CAACZ,SAAS,CAACkB,GAAG,CAAEN,IAAK,CAAC;EAElC;EAEAyI,QAAQA,CAAEzI,IAAI,EAAG;IAEhB,MAAM0I,MAAM,GAAG1I,IAAI,CAAC2H,WAAW,CAAE,IAAK,CAAC;IAEvC,MAAMgB,QAAQ,GAAG,IAAI,CAACC,aAAa,CAAE5I,IAAI,EAAE0I,MAAO,CAAC;IAEnD,IAAI,CAACtJ,SAAS,CAACoB,GAAG,CAAER,IAAI,EAAE2I,QAAS,CAAC;IAEpC,OAAOA,QAAQ;EAEhB;EAEAE,iBAAiBA,CAAEC,UAAU,EAAG;IAE/B,MAAMC,EAAE,GAAG,IAAInP,YAAY,CAAC,CAAC;IAE7B,MAAMoP,QAAQ,GAAG,IAAI,CAACjK,mBAAmB;IAEzC,IAAI,CAACA,mBAAmB,GAAGgK,EAAE;IAE7BA,EAAE,CAACpK,IAAI,GAAG,IAAI,CAACsK,iBAAiB,CAAEH,UAAW,CAAC;IAE9C,IAAI,CAAC/J,mBAAmB,GAAGiK,QAAQ;IAEnC,OAAOD,EAAE;EAEV;EAEAG,cAAcA,CAAEJ,UAAU,EAAG;IAE5B,MAAMK,MAAM,GAAGL,UAAU,CAACK,MAAM;IAEhC,IAAIC,MAAM;IAEV,IAAKN,UAAU,CAACO,YAAY,EAAG;MAE9BD,MAAM,GAAG,EAAE;MAEX,KAAM,MAAME,KAAK,IAAIH,MAAM,CAACC,MAAM,EAAG;QAEpCA,MAAM,CAAC3I,IAAI,CAAE,IAAI9G,aAAa,CAAE2P,KAAK,CAACtG,IAAI,EAAEsG,KAAK,CAACjF,IAAK,CAAE,CAAC;MAE3D;IAED,CAAC,MAAM;MAEN+E,MAAM,GAAG,CAAC,CAAC;MAEX,KAAM,MAAME,KAAK,IAAIH,MAAM,CAACC,MAAM,EAAG;QAEpCA,MAAM,CAAEE,KAAK,CAACjF,IAAI,CAAE,GAAG,IAAI1K,aAAa,CAAE2P,KAAK,CAACtG,IAAI,EAAEsG,KAAK,CAACjF,IAAK,CAAC;MAEnE;IAED;;IAEA;;IAEAyE,UAAU,CAACK,MAAM,GAAG,IAAI;IAExB,MAAMI,QAAQ,GAAGT,UAAU,CAACU,IAAI,CAAEJ,MAAO,CAAC;IAC1C,MAAMT,QAAQ,GAAG,IAAI,CAACc,cAAc,CAAEF,QAAQ,EAAEJ,MAAM,CAACnG,IAAK,CAAC;IAE7D8F,UAAU,CAACK,MAAM,GAAGA,MAAM;IAE1B,OAAOR,QAAQ;EAEhB;EAEAc,cAAcA,CAAEzJ,IAAI,EAAE0I,MAAM,GAAG,IAAI,EAAG;IAErC,MAAMgB,YAAY,GAAG,IAAI,CAAChL,IAAI;IAC9B,MAAMiL,YAAY,GAAG,IAAI,CAAClL,IAAI;IAC9B,MAAMmL,aAAa,GAAG,IAAI,CAAC1K,KAAK;IAChC,MAAM2K,kBAAkB,GAAG,IAAI,CAACtK,UAAU;IAC1C,MAAMuK,aAAa,GAAG,IAAI,CAAC3O,KAAK;IAEhC,MAAMuD,IAAI,GAAG;MACZC,IAAI,EAAE;IACP,CAAC;IAED,IAAI,CAACD,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACD,IAAI,GAAG,CAAC,CAAC;IACd,IAAI,CAACS,KAAK,GAAG,IAAIxF,SAAS,CAAC,CAAC;IAC5B,IAAI,CAACyB,KAAK,GAAGA,KAAK,CAAC,CAAC;IAEpB,KAAM,MAAMoE,UAAU,IAAItF,kBAAkB,EAAG;MAE9C,IAAI,CAAC8P,aAAa,CAAExK,UAAW,CAAC;MAEhCb,IAAI,CAACsL,MAAM,GAAGhK,IAAI,CAACiK,KAAK,CAAE,IAAI,EAAEvB,MAAO,CAAC;IAEzC;IAEAhK,IAAI,CAACD,IAAI,GAAG,IAAI,CAACyL,OAAO,CAAE,IAAI,CAAC5K,WAAY,CAAC;IAE5C,IAAI,CAACZ,IAAI,GAAGgL,YAAY;IACxB,IAAI,CAACjL,IAAI,GAAGkL,YAAY;IACxB,IAAI,CAACzK,KAAK,GAAG0K,aAAa;IAC1B,IAAI,CAACzO,KAAK,GAAG2O,aAAa;IAE1B,IAAI,CAACC,aAAa,CAAEF,kBAAmB,CAAC;IAExC,OAAOnL,IAAI;EAEZ;EAEAyL,mBAAmBA,CAAA,EAAG;IAErB,OAAO,IAAI;EAEZ;EAEAvB,aAAaA,CAAE5I,IAAI,EAAE0I,MAAM,GAAG,IAAI,EAAG;IAEpC,MAAMgB,YAAY,GAAG,IAAI,CAAChL,IAAI;IAE9B,MAAMA,IAAI,GAAG;MACZC,IAAI,EAAE;IACP,CAAC;IAED,IAAI,CAACD,IAAI,GAAGA,IAAI;IAEhBA,IAAI,CAACsL,MAAM,GAAGhK,IAAI,CAACiK,KAAK,CAAE,IAAI,EAAEvB,MAAO,CAAC;IAExC,IAAI,CAAChK,IAAI,GAAGgL,YAAY;IAExB,OAAOhL,IAAI;EAEZ;EAEA0L,uBAAuBA,CAAE9K,WAAW,EAAEU,IAAI,EAAE0I,MAAM,GAAG,IAAI,EAAE2B,YAAY,GAAG,IAAI,EAAG;IAEhF,MAAMC,mBAAmB,GAAG,IAAI,CAAChL,WAAW;IAE5C,IAAI,CAACiL,cAAc,CAAEjL,WAAY,CAAC;IAElC,MAAMqJ,QAAQ,GAAG,IAAI,CAACC,aAAa,CAAE5I,IAAI,EAAE0I,MAAO,CAAC;IAEnD,IAAK2B,YAAY,KAAK,IAAI,EAAG;MAE5B1B,QAAQ,CAAChK,IAAI,IAAK,GAAG,IAAI,CAACG,GAAG,GAAGuL,YAAc,MAAM1B,QAAQ,CAACqB,MAAQ,KAAI;IAE1E;IAEA,IAAI,CAAClM,QAAQ,CAAEwB,WAAW,CAAE,GAAG,IAAI,CAACxB,QAAQ,CAAEwB,WAAW,CAAE,GAAGqJ,QAAQ,CAAChK,IAAI;IAE3E,IAAI,CAAC4L,cAAc,CAAED,mBAAoB,CAAC;IAE1C,OAAO3B,QAAQ;EAEhB;EAEA6B,kBAAkBA,CAAA,EAAG;IAEpB,OAAO,IAAI,CAACnM,UAAU,CAACoM,MAAM,CAAE,IAAI,CAACnM,gBAAiB,CAAC;EAEvD;EAEAoM,aAAaA,CAAA,CAAE;EAAA,EAAkB;IAEhCnI,OAAO,CAACC,IAAI,CAAE,oBAAqB,CAAC;EAErC;EAEAmI,WAAWA,CAAA,CAAE;EAAA,EAAkB;IAE9BpI,OAAO,CAACC,IAAI,CAAE,oBAAqB,CAAC;EAErC;EAEAoI,MAAMA,CAAE5H,IAAI,EAAEqB,IAAI,EAAG;IAEpB,OAAQ,GAAG,IAAI,CAAClB,OAAO,CAAEH,IAAK,CAAG,IAAIqB,IAAM,EAAC;EAE7C;EAEA6F,OAAOA,CAAE5K,WAAW,EAAG;IAEtB,IAAIuL,OAAO,GAAG,EAAE;IAEhB,MAAMpM,IAAI,GAAG,IAAI,CAACA,IAAI,CAAEa,WAAW,CAAE;IAErC,IAAKb,IAAI,KAAK8B,SAAS,EAAG;MAEzB,KAAM,MAAMsH,QAAQ,IAAIpJ,IAAI,EAAG;QAE9BoM,OAAO,IAAK,GAAG,IAAI,CAACD,MAAM,CAAE/C,QAAQ,CAAC7E,IAAI,EAAE6E,QAAQ,CAACxD,IAAK,CAAG,IAAG;MAEhE;IAED;IAEA,OAAOwG,OAAO;EAEf;EAEAC,WAAWA,CAAA,CAAE;EAAA,EAAkB;IAE9BvI,OAAO,CAACC,IAAI,CAAE,oBAAqB,CAAC;EAErC;EAEAuI,QAAQA,CAAEzL,WAAW,EAAG;IAEvB,MAAMd,KAAK,GAAG,IAAI,CAACA,KAAK,CAAEc,WAAW,CAAE;IAEvC,IAAIX,IAAI,GAAG,EAAE;IAEb,IAAKH,KAAK,KAAK+B,SAAS,EAAG;MAE1B,KAAM,MAAM2H,QAAQ,IAAI1J,KAAK,EAAG;QAE/BG,IAAI,IAAIuJ,QAAQ,CAACvJ,IAAI,GAAG,IAAI;MAE7B;IAED;IAEA,OAAOA,IAAI;EAEZ;EAEAmC,OAAOA,CAAA,EAAG;IAET,OAAO,IAAI,CAACvD,YAAY,GAAG,IAAI,CAACC,cAAc,GAAG,IAAI,CAACC,aAAa;EAEpE;EAEA8M,cAAcA,CAAEjL,WAAW,EAAG;IAE7B,IAAI,CAACA,WAAW,GAAGA,WAAW;EAE/B;EAEA0L,cAAcA,CAAA,EAAG;IAEhB,OAAO,IAAI,CAAC1L,WAAW;EAExB;EAEAyK,aAAaA,CAAExK,UAAU,EAAG;IAE3B,IAAI,CAACA,UAAU,GAAGA,UAAU;EAE7B;EAEA0L,aAAaA,CAAA,EAAG;IAEf,OAAO,IAAI,CAAC1L,UAAU;EAEvB;EAEA2L,SAASA,CAAA,EAAG;IAEX3I,OAAO,CAACC,IAAI,CAAE,oBAAqB,CAAC;EAErC;EAEAyH,KAAKA,CAAA,EAAG;IAEP,MAAM;MAAExN,MAAM;MAAEI;IAAS,CAAC,GAAG,IAAI;IAGjC,IAAKA,QAAQ,KAAK,IAAI,EAAG;MAExB9C,YAAY,CAACoR,YAAY,CAAEtO,QAAS,CAAC,CAACoN,KAAK,CAAE,IAAK,CAAC;IAEpD,CAAC,MAAM;MAEN,IAAI,CAACjI,OAAO,CAAE,SAAS,EAAEvF,MAAO,CAAC;IAElC;;IAEA;IACA;IACA;;IAEA,KAAM,MAAM8C,UAAU,IAAItF,kBAAkB,EAAG;MAE9C,IAAI,CAAC8P,aAAa,CAAExK,UAAW,CAAC;MAEhC,IAAK,IAAI,CAACP,OAAO,CAACrB,MAAM,IAAI,IAAI,CAACqB,OAAO,CAACrB,MAAM,CAACyN,MAAM,EAAG;QAExD,IAAI,CAAChB,uBAAuB,CAAE,QAAQ,EAAE,IAAI,CAACpL,OAAO,CAACrB,MAAO,CAAC;MAE9D;MAEA,KAAM,MAAM2B,WAAW,IAAIpF,YAAY,EAAG;QAEzC,IAAI,CAACqQ,cAAc,CAAEjL,WAAY,CAAC;QAElC,MAAM5B,SAAS,GAAG,IAAI,CAACA,SAAS,CAAE4B,WAAW,CAAE;QAE/C,KAAM,MAAMU,IAAI,IAAItC,SAAS,EAAG;UAE/B,IAAK6B,UAAU,KAAK,UAAU,EAAG;YAEhC,IAAI,CAACkJ,QAAQ,CAAEzI,IAAK,CAAC;UAEtB,CAAC,MAAM;YAENA,IAAI,CAACiK,KAAK,CAAE,IAAK,CAAC;UAEnB;QAED;MAED;IAED;IAEA,IAAI,CAACF,aAAa,CAAE,IAAK,CAAC;IAC1B,IAAI,CAACQ,cAAc,CAAE,IAAK,CAAC;;IAE3B;;IAEA,IAAI,CAACW,SAAS,CAAC,CAAC;IAChB,IAAI,CAACnK,gBAAgB,CAAC,CAAC;IAEvB,OAAO,IAAI;EAEZ;EAEAsK,cAAcA,CAAEC,WAAW,EAAEtI,IAAI,EAAG;IAEnC,IAAKA,IAAI,KAAK,OAAO,EAAG,OAAO,IAAI7I,gBAAgB,CAAEmR,WAAY,CAAC;IAClE,IAAKtI,IAAI,KAAK,MAAM,EAAG,OAAO,IAAI5I,kBAAkB,CAAEkR,WAAY,CAAC;IACnE,IAAKtI,IAAI,KAAK,MAAM,EAAG,OAAO,IAAI3I,kBAAkB,CAAEiR,WAAY,CAAC;IACnE,IAAKtI,IAAI,KAAK,MAAM,EAAG,OAAO,IAAI1I,kBAAkB,CAAEgR,WAAY,CAAC;IACnE,IAAKtI,IAAI,KAAK,OAAO,EAAG,OAAO,IAAIzI,gBAAgB,CAAE+Q,WAAY,CAAC;IAClE,IAAKtI,IAAI,KAAK,MAAM,EAAG,OAAO,IAAIxI,kBAAkB,CAAE8Q,WAAY,CAAC;IACnE,IAAKtI,IAAI,KAAK,MAAM,EAAG,OAAO,IAAIvI,kBAAkB,CAAE6Q,WAAY,CAAC;IAEnE,MAAM,IAAI1J,KAAK,CAAG,YAAWoB,IAAK,iBAAiB,CAAC;EAErD;EAEAuI,kBAAkBA,CAAEvI,IAAI,GAAG,cAAc,EAAG;IAE3C;;IAEA,OAAOnJ,0BAA0B,CAAEmJ,IAAK,CAAC;EAE1C;EAEAwI,MAAMA,CAAEX,OAAO,EAAEY,QAAQ,EAAEC,MAAM,EAAG;IAEnCD,QAAQ,GAAG,IAAI,CAACvG,aAAa,CAAEuG,QAAS,CAAC;IACzCC,MAAM,GAAG,IAAI,CAACxG,aAAa,CAAEwG,MAAO,CAAC;IAErC,IAAKD,QAAQ,KAAKC,MAAM,IAAIA,MAAM,KAAK,IAAI,IAAI,IAAI,CAAC9G,WAAW,CAAE8G,MAAO,CAAC,EAAG;MAE3E,OAAOb,OAAO;IAEf;IAEA,MAAMc,cAAc,GAAG,IAAI,CAACnI,aAAa,CAAEiI,QAAS,CAAC;IACrD,MAAMG,YAAY,GAAG,IAAI,CAACpI,aAAa,CAAEkI,MAAO,CAAC;IAEjD,IAAKC,cAAc,GAAG,CAAC,EAAG;MAAE;;MAE3B;;MAEA,OAAOd,OAAO;IAEf;IAEA,IAAKe,YAAY,GAAG,CAAC,IAAIA,YAAY,KAAK,CAAC,EAAG;MAAE;;MAE/C;;MAEA,OAAOf,OAAO;IAEf;IAEA,IAAKc,cAAc,KAAKC,YAAY,EAAG;MAEtC,OAAQ,GAAG,IAAI,CAACzI,OAAO,CAAEuI,MAAO,CAAG,KAAKb,OAAS,IAAG;IAErD;IAEA,IAAKc,cAAc,GAAGC,YAAY,EAAG;MAEpC,OAAO,IAAI,CAACJ,MAAM,CAAG,GAAGX,OAAS,IAAI,KAAK,CAACtC,KAAK,CAAE,CAAC,EAAEqD,YAAa,CAAG,EAAC,EAAE,IAAI,CAACxG,iBAAiB,CAAEwG,YAAY,EAAE,IAAI,CAAClI,gBAAgB,CAAE+H,QAAS,CAAE,CAAC,EAAEC,MAAO,CAAC;IAE5J;IAEA,IAAKE,YAAY,KAAK,CAAC,IAAID,cAAc,GAAG,CAAC,EAAG;MAAE;;MAEjD,OAAQ,GAAG,IAAI,CAACxI,OAAO,CAAEuI,MAAO,CAAG,KAAK,IAAI,CAACF,MAAM,CAAEX,OAAO,EAAEY,QAAQ,EAAE,MAAO,CAAG,SAAQ;IAE3F;IAEA,IAAKE,cAAc,KAAK,CAAC,EAAG;MAAE;;MAE7B,OAAQ,GAAG,IAAI,CAACxI,OAAO,CAAEuI,MAAO,CAAG,KAAK,IAAI,CAACF,MAAM,CAAEX,OAAO,EAAEY,QAAQ,EAAE,MAAO,CAAG,SAAQ;IAE3F;IAEA,IAAKE,cAAc,KAAK,CAAC,IAAIC,YAAY,GAAG,CAAC,IAAIH,QAAQ,CAAE,CAAC,CAAE,KAAKC,MAAM,CAAE,CAAC,CAAE,EAAG;MAAE;;MAElF;MACA;;MAEAb,OAAO,GAAI,GAAG,IAAI,CAAC1H,OAAO,CAAE,IAAI,CAACO,gBAAgB,CAAEgI,MAAO,CAAE,CAAG,KAAKb,OAAS,IAAG;IAEjF;IAEA,OAAQ,GAAG,IAAI,CAAC1H,OAAO,CAAEuI,MAAO,CAAG,KAAKb,OAAS,IAAG,CAAC,CAAC;EAEvD;;EAEAgB,YAAYA,CAAA,EAAG;IAEd,OAAQ,gBAAgBnR,QAAU,0BAAyB;EAE5D;AAED;AAEA,eAAe6B,WAAW"},"metadata":{},"sourceType":"module","externalDependencies":[]}