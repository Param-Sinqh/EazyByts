{"ast":null,"code":"import TextureNode from '../accessors/TextureNode.js';\nimport { nodeObject, vec2 } from '../shadernode/ShaderNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { viewportTopLeft } from '../display/ViewportNode.js';\nimport { Matrix4, Vector2, Vector3, Vector4, Object3D, Plane, RenderTarget, HalfFloatType, LinearMipMapLinearFilter } from 'three';\nconst _reflectorPlane = new Plane();\nconst _normal = new Vector3();\nconst _reflectorWorldPosition = new Vector3();\nconst _cameraWorldPosition = new Vector3();\nconst _rotationMatrix = new Matrix4();\nconst _lookAtPosition = new Vector3(0, 0, -1);\nconst clipPlane = new Vector4();\nconst _view = new Vector3();\nconst _target = new Vector3();\nconst _q = new Vector4();\nconst _size = new Vector2();\nconst _defaultRT = new RenderTarget();\nconst _defaultUV = vec2(viewportTopLeft.x.oneMinus(), viewportTopLeft.y);\nlet _inReflector = false;\nclass ReflectorNode extends TextureNode {\n  constructor(parameters = {}) {\n    super(_defaultRT.texture, _defaultUV);\n    const {\n      target = new Object3D(),\n      resolution = 1,\n      generateMipmaps = false,\n      bounces = true\n    } = parameters;\n\n    //\n\n    this.target = target;\n    this.resolution = resolution;\n    this.generateMipmaps = generateMipmaps;\n    this.bounces = bounces;\n    this.updateBeforeType = bounces ? NodeUpdateType.RENDER : NodeUpdateType.FRAME;\n    this.virtualCameras = new WeakMap();\n    this.renderTargets = new WeakMap();\n  }\n  _updateResolution(renderTarget, renderer) {\n    const resolution = this.resolution;\n    renderer.getDrawingBufferSize(_size);\n    renderTarget.setSize(Math.round(_size.width * resolution), Math.round(_size.height * resolution));\n  }\n  setup(builder) {\n    this._updateResolution(_defaultRT, builder.renderer);\n    return super.setup(builder);\n  }\n  getTextureNode() {\n    return this.textureNode;\n  }\n  getVirtualCamera(camera) {\n    let virtualCamera = this.virtualCameras.get(camera);\n    if (virtualCamera === undefined) {\n      virtualCamera = camera.clone();\n      this.virtualCameras.set(camera, virtualCamera);\n    }\n    return virtualCamera;\n  }\n  getRenderTarget(camera) {\n    let renderTarget = this.renderTargets.get(camera);\n    if (renderTarget === undefined) {\n      renderTarget = new RenderTarget(0, 0, {\n        type: HalfFloatType\n      });\n      if (this.generateMipmaps === true) {\n        renderTarget.texture.minFilter = LinearMipMapLinearFilter;\n        renderTarget.texture.generateMipmaps = true;\n      }\n      this.renderTargets.set(camera, renderTarget);\n    }\n    return renderTarget;\n  }\n  updateBefore(frame) {\n    if (this.bounces === false && _inReflector) return false;\n    _inReflector = true;\n    const {\n      scene,\n      camera,\n      renderer,\n      material\n    } = frame;\n    const {\n      target\n    } = this;\n    const virtualCamera = this.getVirtualCamera(camera);\n    const renderTarget = this.getRenderTarget(virtualCamera);\n    renderer.getDrawingBufferSize(_size);\n    this._updateResolution(renderTarget, renderer);\n\n    //\n\n    _reflectorWorldPosition.setFromMatrixPosition(target.matrixWorld);\n    _cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n    _rotationMatrix.extractRotation(target.matrixWorld);\n    _normal.set(0, 0, 1);\n    _normal.applyMatrix4(_rotationMatrix);\n    _view.subVectors(_reflectorWorldPosition, _cameraWorldPosition);\n\n    // Avoid rendering when reflector is facing away\n\n    if (_view.dot(_normal) > 0) return;\n    _view.reflect(_normal).negate();\n    _view.add(_reflectorWorldPosition);\n    _rotationMatrix.extractRotation(camera.matrixWorld);\n    _lookAtPosition.set(0, 0, -1);\n    _lookAtPosition.applyMatrix4(_rotationMatrix);\n    _lookAtPosition.add(_cameraWorldPosition);\n    _target.subVectors(_reflectorWorldPosition, _lookAtPosition);\n    _target.reflect(_normal).negate();\n    _target.add(_reflectorWorldPosition);\n\n    //\n\n    virtualCamera.coordinateSystem = camera.coordinateSystem;\n    virtualCamera.position.copy(_view);\n    virtualCamera.up.set(0, 1, 0);\n    virtualCamera.up.applyMatrix4(_rotationMatrix);\n    virtualCamera.up.reflect(_normal);\n    virtualCamera.lookAt(_target);\n    virtualCamera.near = camera.near;\n    virtualCamera.far = camera.far;\n    virtualCamera.updateMatrixWorld();\n    virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n\n    // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n    // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n    _reflectorPlane.setFromNormalAndCoplanarPoint(_normal, _reflectorWorldPosition);\n    _reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n    clipPlane.set(_reflectorPlane.normal.x, _reflectorPlane.normal.y, _reflectorPlane.normal.z, _reflectorPlane.constant);\n    const projectionMatrix = virtualCamera.projectionMatrix;\n    _q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n    _q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n    _q.z = -1.0;\n    _q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n\n    // Calculate the scaled plane vector\n    clipPlane.multiplyScalar(1.0 / clipPlane.dot(_q));\n    const clipBias = 0;\n\n    // Replacing the third row of the projection matrix\n    projectionMatrix.elements[2] = clipPlane.x;\n    projectionMatrix.elements[6] = clipPlane.y;\n    projectionMatrix.elements[10] = clipPlane.z - clipBias;\n    projectionMatrix.elements[14] = clipPlane.w;\n\n    //\n\n    this.value = renderTarget.texture;\n    material.visible = false;\n    const currentRenderTarget = renderer.getRenderTarget();\n    renderer.setRenderTarget(renderTarget);\n    renderer.render(scene, virtualCamera);\n    renderer.setRenderTarget(currentRenderTarget);\n    material.visible = true;\n    _inReflector = false;\n  }\n}\nexport const reflector = parameters => nodeObject(new ReflectorNode(parameters));\nexport default ReflectorNode;","map":{"version":3,"names":["TextureNode","nodeObject","vec2","NodeUpdateType","viewportTopLeft","Matrix4","Vector2","Vector3","Vector4","Object3D","Plane","RenderTarget","HalfFloatType","LinearMipMapLinearFilter","_reflectorPlane","_normal","_reflectorWorldPosition","_cameraWorldPosition","_rotationMatrix","_lookAtPosition","clipPlane","_view","_target","_q","_size","_defaultRT","_defaultUV","x","oneMinus","y","_inReflector","ReflectorNode","constructor","parameters","texture","target","resolution","generateMipmaps","bounces","updateBeforeType","RENDER","FRAME","virtualCameras","WeakMap","renderTargets","_updateResolution","renderTarget","renderer","getDrawingBufferSize","setSize","Math","round","width","height","setup","builder","getTextureNode","textureNode","getVirtualCamera","camera","virtualCamera","get","undefined","clone","set","getRenderTarget","type","minFilter","updateBefore","frame","scene","material","setFromMatrixPosition","matrixWorld","extractRotation","applyMatrix4","subVectors","dot","reflect","negate","add","coordinateSystem","position","copy","up","lookAt","near","far","updateMatrixWorld","projectionMatrix","setFromNormalAndCoplanarPoint","matrixWorldInverse","normal","z","constant","sign","elements","w","multiplyScalar","clipBias","value","visible","currentRenderTarget","setRenderTarget","render","reflector"],"sources":["D:/dumps/online-learning-platform-main/Frontend/node_modules/three/examples/jsm/nodes/utils/ReflectorNode.js"],"sourcesContent":["import TextureNode from '../accessors/TextureNode.js';\nimport { nodeObject, vec2 } from '../shadernode/ShaderNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { viewportTopLeft } from '../display/ViewportNode.js';\nimport { Matrix4, Vector2, Vector3, Vector4, Object3D, Plane, RenderTarget, HalfFloatType, LinearMipMapLinearFilter } from 'three';\n\nconst _reflectorPlane = new Plane();\nconst _normal = new Vector3();\nconst _reflectorWorldPosition = new Vector3();\nconst _cameraWorldPosition = new Vector3();\nconst _rotationMatrix = new Matrix4();\nconst _lookAtPosition = new Vector3( 0, 0, - 1 );\nconst clipPlane = new Vector4();\n\nconst _view = new Vector3();\nconst _target = new Vector3();\nconst _q = new Vector4();\n\nconst _size = new Vector2();\n\nconst _defaultRT = new RenderTarget();\nconst _defaultUV = vec2( viewportTopLeft.x.oneMinus(), viewportTopLeft.y );\n\nlet _inReflector = false;\n\nclass ReflectorNode extends TextureNode {\n\n\tconstructor( parameters = {} ) {\n\n\t\tsuper( _defaultRT.texture, _defaultUV );\n\n\t\tconst {\n\t\t\ttarget = new Object3D(),\n\t\t\tresolution = 1,\n\t\t\tgenerateMipmaps = false,\n\t\t\tbounces = true\n\t\t} = parameters;\n\n\t\t//\n\n\t\tthis.target = target;\n\t\tthis.resolution = resolution;\n\t\tthis.generateMipmaps = generateMipmaps;\n\t\tthis.bounces = bounces;\n\n\t\tthis.updateBeforeType = bounces ? NodeUpdateType.RENDER : NodeUpdateType.FRAME;\n\n\t\tthis.virtualCameras = new WeakMap();\n\t\tthis.renderTargets = new WeakMap();\n\n\n\t}\n\n\t_updateResolution( renderTarget, renderer ) {\n\n\t\tconst resolution = this.resolution;\n\n\t\trenderer.getDrawingBufferSize( _size );\n\n\t\trenderTarget.setSize( Math.round( _size.width * resolution ), Math.round( _size.height * resolution ) );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis._updateResolution( _defaultRT, builder.renderer );\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\tgetTextureNode() {\n\n\t\treturn this.textureNode;\n\n\t}\n\n\tgetVirtualCamera( camera ) {\n\n\t\tlet virtualCamera = this.virtualCameras.get( camera );\n\n\t\tif ( virtualCamera === undefined ) {\n\n\t\t\tvirtualCamera = camera.clone();\n\n\t\t\tthis.virtualCameras.set( camera, virtualCamera );\n\n\t\t}\n\n\t\treturn virtualCamera;\n\n\t}\n\n\tgetRenderTarget( camera ) {\n\n\t\tlet renderTarget = this.renderTargets.get( camera );\n\n\t\tif ( renderTarget === undefined ) {\n\n\t\t\trenderTarget = new RenderTarget( 0, 0, { type: HalfFloatType } );\n\n\t\t\tif ( this.generateMipmaps === true ) {\n\n\t\t\t    renderTarget.texture.minFilter = LinearMipMapLinearFilter;\n\t\t\t    renderTarget.texture.generateMipmaps = true;\n\n\t\t\t}\n\n\t\t\tthis.renderTargets.set( camera, renderTarget );\n\n\t\t}\n\n\t\treturn renderTarget;\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tif ( this.bounces === false && _inReflector ) return false;\n\n\t\t_inReflector = true;\n\n\t\tconst { scene, camera, renderer, material } = frame;\n\t\tconst { target } = this;\n\n\t\tconst virtualCamera = this.getVirtualCamera( camera );\n\t\tconst renderTarget = this.getRenderTarget( virtualCamera );\n\n\t\trenderer.getDrawingBufferSize( _size );\n\n\t\tthis._updateResolution( renderTarget, renderer );\n\n\t\t//\n\n\t\t_reflectorWorldPosition.setFromMatrixPosition( target.matrixWorld );\n\t\t_cameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\t_rotationMatrix.extractRotation( target.matrixWorld );\n\n\t\t_normal.set( 0, 0, 1 );\n\t\t_normal.applyMatrix4( _rotationMatrix );\n\n\t\t_view.subVectors( _reflectorWorldPosition, _cameraWorldPosition );\n\n\t\t// Avoid rendering when reflector is facing away\n\n\t\tif ( _view.dot( _normal ) > 0 ) return;\n\n\t\t_view.reflect( _normal ).negate();\n\t\t_view.add( _reflectorWorldPosition );\n\n\t\t_rotationMatrix.extractRotation( camera.matrixWorld );\n\n\t\t_lookAtPosition.set( 0, 0, - 1 );\n\t\t_lookAtPosition.applyMatrix4( _rotationMatrix );\n\t\t_lookAtPosition.add( _cameraWorldPosition );\n\n\t\t_target.subVectors( _reflectorWorldPosition, _lookAtPosition );\n\t\t_target.reflect( _normal ).negate();\n\t\t_target.add( _reflectorWorldPosition );\n\n\t\t//\n\n\t\tvirtualCamera.coordinateSystem = camera.coordinateSystem;\n\t\tvirtualCamera.position.copy( _view );\n\t\tvirtualCamera.up.set( 0, 1, 0 );\n\t\tvirtualCamera.up.applyMatrix4( _rotationMatrix );\n\t\tvirtualCamera.up.reflect( _normal );\n\t\tvirtualCamera.lookAt( _target );\n\n\t\tvirtualCamera.near = camera.near;\n\t\tvirtualCamera.far = camera.far;\n\n\t\tvirtualCamera.updateMatrixWorld();\n\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n\t\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\t\t_reflectorPlane.setFromNormalAndCoplanarPoint( _normal, _reflectorWorldPosition );\n\t\t_reflectorPlane.applyMatrix4( virtualCamera.matrixWorldInverse );\n\n\t\tclipPlane.set( _reflectorPlane.normal.x, _reflectorPlane.normal.y, _reflectorPlane.normal.z, _reflectorPlane.constant );\n\n\t\tconst projectionMatrix = virtualCamera.projectionMatrix;\n\n\t\t_q.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\t\t_q.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\t\t_q.z = - 1.0;\n\t\t_q.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t\t// Calculate the scaled plane vector\n\t\tclipPlane.multiplyScalar( 1.0 / clipPlane.dot( _q ) );\n\n\t\tconst clipBias = 0;\n\n\t\t// Replacing the third row of the projection matrix\n\t\tprojectionMatrix.elements[ 2 ] = clipPlane.x;\n\t\tprojectionMatrix.elements[ 6 ] = clipPlane.y;\n\t\tprojectionMatrix.elements[ 10 ] = clipPlane.z - clipBias;\n\t\tprojectionMatrix.elements[ 14 ] = clipPlane.w;\n\n\t\t//\n\n\t\tthis.value = renderTarget.texture;\n\n\t\tmaterial.visible = false;\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\trenderer.setRenderTarget( renderTarget );\n\n\t\trenderer.render( scene, virtualCamera );\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\tmaterial.visible = true;\n\n\t\t_inReflector = false;\n\n\t}\n\n}\n\nexport const reflector = ( parameters ) => nodeObject( new ReflectorNode( parameters ) );\n\nexport default ReflectorNode;\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}